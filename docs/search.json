[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Procesamiento y análisis de series temporales con GRASS GIS",
    "section": "",
    "text": "Gran parte de la investigación en ecología y problemas asociados al ambiente en la actualidad requiere de conocimientos técnicos en el procesamiento avanzado de grandes conjuntos de datos espacio-temporales. En las dos últimas décadas se ha producido un cambio notable en la forma en que los datos se difunden de manera abierta y a través de Internet. Con esta libre disponibilidad de petabytes de datos de sensado remoto, modelos climáticos globales, redes de sensores y otros datos geoespaciales existe una urgente necesidad de formar usuarios en lo que respecta a su manejo eficiente y procesamiento. Las herramientas libres y de código abierto también han ganado gran popularidad y estabilidad, simultáneamente con la creciente cantidad de datos libres. Este curso abordará el procesamiento y análisis de datos espacio-temporales con GRASS GIS (https://grass.osgeo.org/).\nGRASS GIS es un software que nació hace 40 años y sigue siendo hoy en día uno de los SIG libre y de código abierto más potentes y versátiles. Sus prestaciones de alto nivel y sus capacidades analíticas tanto en el trabajo con datos vectoriales como en el trabajo con datos raster, hacen de GRASS una excelente herramienta para desempẽnar trabajos de análisis espacial o geográfico en muchos campos de aplicacíon, desde el análisis ambiental hasta el análisis de redes, pasando por la teledetección o la simulación de modelos. GRASS GIS consta de más de 500 módulos base a los que se adicionan cientos de complementos que permiten extender su potencialidad para el procesamiento de datos raster, vectoriales, ráster 3D y temporales. Por otra parte, GRASS GIS puede ser un potente SIG de escritorio o la columna vertebral de una infraestructura SIG dadas sus diferentes APIs. Proporciona interfaces a muchos otros programas en geoestadística, bases de datos, servicios de mapas web y otros SIG como por ejemplo QGIS. Más aún, GRASS GIS se utiliza en el ámbito académico, en el escenario comercial y también en instituciones públicas de todo el mundo para una amplia gama de aplicaciones."
  },
  {
    "objectID": "index.html#resumen",
    "href": "index.html#resumen",
    "title": "Procesamiento y análisis de series temporales con GRASS GIS",
    "section": "",
    "text": "TBD"
  },
  {
    "objectID": "index.html#contenidos",
    "href": "index.html#contenidos",
    "title": "Procesamiento y análisis de series temporales con GRASS GIS",
    "section": "Contenidos",
    "text": "Contenidos\n\nUnidad 1: Introducción a GRASS GIS\nUnidad 2: Análisis de datos raster y satelitales\n\nbla\nbla\n\nUnidad 3: OBIA\nUnidad 4: Series de tiempo\nUnidad 5: Modelado de nicho"
  },
  {
    "objectID": "index.html#software",
    "href": "index.html#software",
    "title": "Procesamiento y análisis de series temporales con GRASS GIS",
    "section": "Software",
    "text": "Software\nIf you still want to run the workshop locally, you’ll find instructions and requirements below.\n\nGRASS GIS\nWe will use GRASS GIS 8.2+. It can be installed either through standalone installers/binaries or through OSGeo-Live (a linux based virtual machine which includes all OSGeo software and packages).\n\nMS Windows\nThere are two different options to install GRASS GIS in MS Windows:\n\nStandalone installer 64-bit\nOSGeo4W 64-bit\n\nFor Windows users, we strongly recommend installing GRASS GIS through the OSGeo4W package (second option), since it allows to install all OSGeo software and resolves dependencies.\n\n\nUbuntu Linux\nInstall GRASS GIS 8.2+ from the “unstable” package repository:\n  sudo add-apt-repository ppa:ubuntugis/ubuntugis-unstable\n  sudo apt-get update\n  sudo apt-get install grass grass-gui grass-dev\n\n\nFedora, openSuSe Linux\nFor other Linux distributions including Fedora and openSuSe, simply install GRASS GIS with the respective package manager. See also here\n\n\nMac OS\nFind GRASS GIS binaries on http://grassmac.wikidot.com/ or install the latest available version from MacPorts.\n\n\nGRASS GIS Add-ons\n\nr.bioclim: Calculates bioclimatic indices as those in WorldClim.\n\nInstall with g.extension extension=name_of_addon\n\n\n\nR packages\nThe following R packages should be installed beforehand:\n  install.packages(c(\"rgrass\",\"terra\",\"sf\",\"raster\",\"mapview\",\"biomod2\",\"dismo\",\"usdm\",\"SDMtune\",\"zeallot\",\"rJava\",\"ggpubr\"))\n\n\nPython libraries\nThe following Python libraries should be installed beforehand:\n  pip install folium"
  },
  {
    "objectID": "index.html#data",
    "href": "index.html#data",
    "title": "Procesamiento y análisis de series temporales con GRASS GIS",
    "section": "Data",
    "text": "Data\nDownload the following ready to use location with reconstructed daily LST averages (Metz et al. (2017)) for Northern Italy. This dataset is courtesy of mundialis GmbH & Co. KG.\n\nNorthern Italy (1.7 Gb)\n\nWe will also use a points vector map representing Aedes albopictus presence data:\n\nMosquito occurrence data"
  },
  {
    "objectID": "index.html#references",
    "href": "index.html#references",
    "title": "Procesamiento y análisis de series temporales con GRASS GIS",
    "section": "References",
    "text": "References"
  },
  {
    "objectID": "unidad_1/unit1_index.html",
    "href": "unidad_1/unit1_index.html",
    "title": "GRASS GIS 2023",
    "section": "",
    "text": "En esta unidad vamos a ver dos presentaciones introductorias y otras dos con ejercicios para familiarizarnos principalmente con la interfaz gŕafica de GRASS GIS. Comencemos!\n\n\n\nVer en otra pestaña\n\n\nVer en otra pestaña\n\n\n\n\n\nVer en otra pestaña\n\n\nVer en otra pestaña"
  },
  {
    "objectID": "unidad_1/unit1_index.html#presentaciones-unidad-1",
    "href": "unidad_1/unit1_index.html#presentaciones-unidad-1",
    "title": "GRASS GIS 2023",
    "section": "",
    "text": "En esta unidad vamos a ver dos presentaciones introductorias y otras dos con ejercicios para familiarizarnos principalmente con la interfaz gŕafica de GRASS GIS. Comencemos!\n\n\n\nVer en otra pestaña\n\n\nVer en otra pestaña\n\n\n\n\n\nVer en otra pestaña\n\n\nVer en otra pestaña"
  },
  {
    "objectID": "unidad_1/intro_to_grass.html#references",
    "href": "unidad_1/intro_to_grass.html#references",
    "title": "Intro a GRASS GIS",
    "section": "Referencias",
    "text": "Referencias\n\n\nHaedrich, C., Petras, V., Petrasova, A., Blumentrath, S., y Mitasova, H. (2023), «Integrating GRASS GIS and Jupyter Notebooks to facilitate advanced geospatial modeling education», Transactions in GIS, 27, 686-702. https://doi.org/10.1111/tgis.13031.\n\n\nNeteler, M., Bowman, M. H., Landa, M., y Metz, M. (2012), «GRASS GIS: A multi-purpose open source GIS», Environmental Modelling & Software, 31, 124-130. https://doi.org/10.1016/j.envsoft.2011.11.014.\n\n\nNeteler, M., y Mitasova, H. (2013), Open source GIS: a GRASS GIS approach, Springer Science & Business Media.\n\n\nWhite, C. T., Petrasova, A., Petras, V., Tateosian, L. G., Vukomanovic, J., Mitasova, H., y Meentemeyer, R. K. (2023), «An open-source platform for geospatial participatory modeling in the cloud», Environmental Modelling & Software, 167, 105767. https://doi.org/10.1016/j.envsoft.2023.105767."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Verónica Andreo",
    "section": "",
    "text": "Verónica Andreo is a biologist. She holds a PhD in Biological Sciences and an MSc in Remote Sensing and GIS applications. She works as a researcher for CONICET and lecturer at Gulich Institute - Argentinian Space Agency (CONAE) in Córdoba, Argentina. Her research is focused on uncovering environmental drivers of vector-borne disease outbreaks. She is mostly interested in those environmental features that can be derived by means of satellite image analysis, remote sensing time series and GIS-based techniques.\nVerónica is part of the GRASS GIS Development team and currently serves as the PSC chair. She is a strong advocate for OSGeo and free and open source software for geo-spatial (FOSS4G). She was the Program Committee chair for FOSS4G 2021. Among other things, she has volunteered as a mentor for GRASS GIS in the Google Code-In contest introducing high school students into the Open Source world.\n\n\n\n\nRemote sensing time series\nImage analysis\nGIS\nSDM\nVector-borne diseases\nFree and Open Source Software\n\n\n\n\n\nPhD in Biological Sciences. National University of Río Cuarto. 2012.\nMSc in Spatial Applications for Early Warning and Response to Emergencies. National University of Córdoba. 2015.\nBiologist. National University of Río Cuarto. 2005."
  },
  {
    "objectID": "about.html#fa-solid-dna-about",
    "href": "about.html#fa-solid-dna-about",
    "title": "Verónica Andreo",
    "section": "",
    "text": "Verónica Andreo is a biologist. She holds a PhD in Biological Sciences and an MSc in Remote Sensing and GIS applications. She works as a researcher for CONICET and lecturer at Gulich Institute - Argentinian Space Agency (CONAE) in Córdoba, Argentina. Her research is focused on uncovering environmental drivers of vector-borne disease outbreaks. She is mostly interested in those environmental features that can be derived by means of satellite image analysis, remote sensing time series and GIS-based techniques.\nVerónica is part of the GRASS GIS Development team and currently serves as the PSC chair. She is a strong advocate for OSGeo and free and open source software for geo-spatial (FOSS4G). She was the Program Committee chair for FOSS4G 2021. Among other things, she has volunteered as a mentor for GRASS GIS in the Google Code-In contest introducing high school students into the Open Source world."
  },
  {
    "objectID": "about.html#fa-solid-heart-interests",
    "href": "about.html#fa-solid-heart-interests",
    "title": "Verónica Andreo",
    "section": "",
    "text": "Remote sensing time series\nImage analysis\nGIS\nSDM\nVector-borne diseases\nFree and Open Source Software"
  },
  {
    "objectID": "about.html#fa-solid-graduation-cap-education",
    "href": "about.html#fa-solid-graduation-cap-education",
    "title": "Verónica Andreo",
    "section": "",
    "text": "PhD in Biological Sciences. National University of Río Cuarto. 2012.\nMSc in Spatial Applications for Early Warning and Response to Emergencies. National University of Córdoba. 2015.\nBiologist. National University of Río Cuarto. 2005."
  },
  {
    "objectID": "unidad_2/imagery_data_in_grass.html",
    "href": "unidad_2/imagery_data_in_grass.html",
    "title": "Datos satelitales en GRASS GIS",
    "section": "",
    "text": "Los datos satelitales en general vienen en formato raster, por lo tanto aplican las mismas reglas.\nLos comandos i.* se orientan explícitamente al procesamiento de datos satelitales aunque algunos puedan usarse para otros datos raster."
  },
  {
    "objectID": "unidad_2/imagery_data_in_grass.html#procesamiento-de-datos-satelitales-en-grass-gis",
    "href": "unidad_2/imagery_data_in_grass.html#procesamiento-de-datos-satelitales-en-grass-gis",
    "title": "Datos satelitales en GRASS GIS",
    "section": "",
    "text": "Nociones básicas sobre datos satelitales en GRASS GIS\nBúsqueda y descarga de datos Landsat\nCalibración y corrección atmosférica: de número digital a reflectancia\nAjuste de colores y composiciones RGB\nMáscara de nubes a partir de banda de calidad\nFusión de datos/Pansharpening\nÍndices espectrales de agua y vegetación\nClasificación no supervisada\n\n\n\n\nLos datos satelitales en general vienen en formato raster (fa?, arrow-right text-green) aplican las mismas reglas \n\nLos comandos *i.** se orientan explícitamente al procesamiento de datos satelitales (aunque algunos puedan usarse para otros datos raster)\n\nPara más detalles ver el manual Imagery Intro y la wiki Image Processing\n\n\n\nEscenas Landsat 8 (OLI)\n\nFechas: 14/01/2020 y 02/03/2020\nPath/Row: 229/082\nCRS: UTM zona 20 N (EPSG:32620)\n\n\n\n\nL8\n\n\nDescargar las escenas L8 14/01/2020 (979Mb) y L8 02/03/2020 (880Mb) y moverlas a $HOME/gisdata/landsat_data. No descomprimir!\n\n\n\n\n\n\n\nL8 vs L7 bands\n\n\nComparación entre las bandas de Landsat 7 ETM+ y Landsat 8 OLI. Fuente: https://landsat.gsfc.nasa.gov/landsat-data-continuity-mission/ y detalle de las bandas Landsat\n\n\n\nIniciar GRASS GIS, crear un nuevo mapset y establecer la región computacional\nIniciar GRASS GIS en posgar2007_4_cba/PERMANENT\n\n# paths\ngrassdata='/home/veroandreo/grassdata/'\nlocation='sa_latlong_wgs84'\nmapset='hansen_gfc_south_america'\n\n\nimport os\nimport subprocess\nimport sys\n\n# Ask GRASS GIS where its Python packages are to be able to start it from the notebook\nsys.path.append(\n    subprocess.check_output([\"grass\", \"--config\", \"python_path\"], text=True).strip()\n)\n\n# Importar los paquetes python de GRASS\nimport grass.script as gs\nimport grass.jupyter as gj\n\n# Iniciar GRASS\nsession = gj.init(grassdata, location, mapset)\n\nCorroborar la proyección\n\n# check the projection of the location\ng.proj -p\n\nCrear un nuevo mapset llamado landsat8\n\n# Create a new mapset\ng.mapset -c mapset=landsat8\n\nListar los mapsets accesibles\n\n# list all the mapsets in the search path\ng.mapsets -p\n\nListar los mapas vectoriales disponibles\n\n# list vector maps in all mapsets in the search path\ng.list type=vector\n\nExtraer el radio urbano de Córdoba\n\n# extract Cordoba urban area from `radios_urbanos`\nv.extract input=radios_urbanos \\\n  where=\"nombre == 'CORDOBA'\" \\\n  output=radio_urbano_cba\n\nEstablecer la región computacional al radio urbano de Córdoba\n\n# set the computational region to the extent of Cordoba urban area\ng.region -p vector=radio_urbano_cba\n\n\n\n\nInstalar la extensión i.landsat\n\n# install i.landsat toolset\ng.extension extension=i.landsat\n\nBuscar escenas de Landsat 8 disponibles\n\n# search for Landsat 8 scenes\ni.landsat.download -l settings=$HOME/gisdata/USGS_SETTING.txt \\\n  dataset=landsat_8_c1 clouds=35 \\\n  start='2019-10-27' end='2020-03-15'\n\nNO EJECUTAR! Descargar las escenas seleccionadas\n\n# download selected scenes\ni.landsat.download settings=$HOME/gisdata/USGS_SETTING.txt \\\n  id=LC82290822020062LGN00,LC82290822020014LGN00 \\\n  output=$HOME/gisdata/landsat_data\n\nImprimir las bandas dentro de la carpeta\n\n# print all landsat bands within landsat_data folder\ni.landsat.import -p input=$HOME/gisdata/landsat_data\n\nImprimir sólo las bandas seleccionadas con un patrón\n\n# print a selection of bands - might be sloooow\ni.landsat.import -p \\\n  input=$HOME/gisdata/landsat_data \\\n  pattern='B(2|3|4|5|6|8)'\n\nImportar bandas, recortar y reproyectar al vuelo\n\n# import all bands, subset to region and reproject\ni.landsat.import -r \\\n  input=$HOME/gisdata/landsat_data \\\n  extent=region\n\nListar bandas importadas y revisar metadatos\n\n# list raster maps\ng.list type=raster mapset=.\n\n# check metadata of some imported bands\nr.info map=LC08_L1TP_229082_20200114_20200127_01_T1_B4\nr.info map=LC08_L1TP_229082_20200114_20200127_01_T1_B8\n\n\n\n\n\n\n\n\n\n\n\n\nWorkflow\n\n\n\n\n\n\nLos datos L8 OLI vienen en 16-bit con rango de datos entre 0 y 65535.\ni.landsat.toar convierte ND en reflectancia TOA (y temperatura de brillo) para todos los sensores Landsat. Opcionalmente proporciona reflectancia de superficie (BOA) después de la corrección DOS.\ni.atcorr proporciona un método de corrección atmosférica más complejo para gran variedad de sensores (S6).\n\nDefinir region computacional a banda de 30m\n\n# set the region to a 30m band\ng.region -p raster=LC08_L1TP_229082_20200114_20200127_01_T1_B4\n\nConvertir DN a reflectancia superficial y temperatura - método DOS\n\n# convert from DN to surface reflectance and temperature - requires to uncompress data locally\ni.landsat.toar \\\n  input=LC08_L1TP_229082_20200114_20200127_01_T1_B \\\n  output=LC08_229082_20200114_toar_B \\\n  sensor=oli8 \\\n  metfile=$HOME/gisdata/landsat_data/LC08_L1TP_229082_20200114_20200127_01_T1_MTL.txt \\\n  method=dos1\n\nCorroborar info antes y después de la conversión para una banda\n\n# list output maps\ng.list type=raster mapset=. pattern=\"*toar*\"\n\n# check info before and after for one band\nr.info map=LC08_L1TP_229082_20200114_20200127_01_T1_B3\nr.info map=LC08_229082_20200114_toar_B3\n\n\nBanda 10 de L8 con la paleta de colores kelvin\n\nTarea:\nAhora, sigan los mismos pasos para la escena del 02/03/2020. Qué notan de diferente?\n\n\n\n\nAjuste de colores para una composición RGB color natural\n\n# enhance the colors\ni.colors.enhance \\\n  red=LC08_229082_20200114_toar_B4 \\\n  green=LC08_229082_20200114_toar_B3 \\\n  blue=LC08_229082_20200114_toar_B2 \\\n  strength=95\n\nMostrar la combinación RGB - d.rgb\n\n# display RGB\nd.mon wx0\nd.rgb \\\n  red=LC08_229082_20200114_toar_B4 \\\n  green=LC08_229082_20200114_toar_B3 \\\n  blue=LC08_229082_20200114_toar_B2\n\n\nTarea:\nSeguir los mismos pasos para una composición falso color 543. Sobre qué bandas debieran realizar el ajuste?\n\n \nComposiciones color natural 432 y falso color 543\n\n\n\n\nLandsat 8 proporciona una banda de calidad (QA) con valores enteros de 16 bits que representan las combinaciones de superficie, atmósfera y condiciones del sensor que pueden afectar la utilidad general de un determinado pixel.\nLa extensión i.landsat.qa reclasifica la banda QA de Landsat 8 de acuerdo a la calidad del pixel.\n\nMás información sobre la banda QA de L8:https://www.usgs.gov/core-science-systems/nli/landsat\nCrear las reglas para identificar las nubes y sombras de nubes\n\n# create a rule set\ni.landsat.qa \\\n  collection=1 \\\n  cloud_shadow_confidence=\"Medium,High\" \\\n  cloud_confidence=\"Medium,High\" \\\n  output=Cloud_Mask_rules.txt\n\nReclasificar la banda QA en función de las reglas\n\n# reclass the BQA band based on the rule set created\nr.reclass \\\n  input=LC08_L1TP_229082_20200114_20200127_01_T1_BQA \\\n  output=LC08_229082_20200114_Cloud_Mask \\\n  rules=Cloud_Mask_rules.txt\n\nReporte del porcentaje de nubes y sombras\n\n# report % of clouds and shadows\nr.report -e map=LC08_229082_20200114_Cloud_Mask units=p\n\nMostrar el mapa reclasificado\n\n# display reclassified map over RGB\nd.mon wx0\nd.rgb \\\n  red=LC08_229082_20200114_toar_B4 \\\n  green=LC08_229082_20200114_toar_B3 \\\n  blue=LC08_229082_20200114_toar_B2\nd.rast LC08_229082_20200114_Cloud_Mask\n\n\nTarea:\nComparar visualmente la cobertura de nubes con la composición RGB 543.\n\n \nComposición falso color y máscara de nubes\n\n\n\nVamos a usar la banda PAN (15 m) para mejorar la definición de las bandas espectrales de 30 m, por medio de:\n\ni.fusion.hpf, que aplica un método de adición basado en un filtro de paso alto\n\nOtros métodos están implementados en i.pansharpen\nInstalar la extensión i.fusion.hpf\n\n# Install the reqquired addon\ng.extension extension=i.fusion.hpf\n\nCambiar la región a la banda PAN\n\n# Set the region to PAN band (15m)\ng.region -p raster=LC08_229082_20200114_toar_B8\n\nEjecutar la fusión\n\n# Apply the fusion based on high pass filter\ni.fusion.hpf -l -c pan=LC08_229082_20200114_toar_B8 \\\n  msx=`g.list type=raster mapset=. pattern=*_toar_B[1-7] separator=,` \\\n  suffix=_hpf \\\n  center=high \\\n  modulation=max \\\n  trim=0.0\n\nListar los mapas resultantes usando un patrón de búsqueda\n\n# list the fused maps\ng.list type=raster mapset=. pattern=*_hpf\n\nVisualizar las diferencias con la herramienta mapswipe\n\n# display original and fused maps\ng.gui.mapswipe \\\n  first=LC08_229082_20200114_toar_B5 \\\n  second=LC08_229082_20200114_toar_B5_hpf\n\n\nDatos originales 30 m y datos fusionados 15 m\n\n\n\nEstablecer la máscara de nubes para evitar el cómputo sobre las nubes\n\n# Set the cloud mask to avoid computing over clouds\nr.mask raster=LC08_229082_20200114_Cloud_Mask\n\nCalcular el NDVI y establecer la paleta de colores\n\n# Compute NDVI\nr.mapcalc \\\n  expression=\"LC08_229082_20200114_NDVI = \\\n  (LC08_229082_20200114_toar_B5_hpf - LC08_229082_20200114_toar_B4_hpf) / \\\n  (LC08_229082_20200114_toar_B5_hpf + LC08_229082_20200114_toar_B4_hpf) * 1.0\"\n# Set the color palette\nr.colors map=LC08_229082_20200114_NDVI color=ndvi\n\nCalcular NDWI y establecer la paleta de colores\n\n# Compute NDWI\nr.mapcalc expression=\"LC08_229082_20200114_NDWI = \\\n  (LC08_229082_20200114_toar_B5_hpf - LC08_229082_20200114_toar_B6_hpf) / \\\n  (LC08_229082_20200114_toar_B5_hpf + LC08_229082_20200114_toar_B6_hpf) * 1.0\"\n# Set the color palette\nr.colors map=LC08_229082_20200114_NDWI color=ndwi\n\nMostrar los mapas\n\n# display maps in different monitors\nd.mon wx0\nd.rast map=LC08_229082_20200114_NDVI\n\nd.mon wx1\nd.rast map=LC08_229082_20200114_NDWI\n\n \nNDVI y NDWI a partir de datos Landsat 8\n\nTarea:\nEstimar NDVI y NDWI para la otra escena usando el módulo i.vi\n\n\n\n\n\nAgrupar las bandas (i.e., hacer un stack): i.group\nGenerar firmas para n número de clases: i.cluster\nClasificar: i.maxlik\n\nListar los mapas usando un patrón\n\n# list the bands needed for classification\ng.list type=raster mapset=. pattern=*_toar*_hpf\n\nCrear un grupo de imágenes o stack\n\n# add maps to an imagery group for easier management\ni.group group=l8 subgroup=l8 \\\n input=`g.list type=raster mapset=. pattern=*_toar*_hpf sep=\",\"`\n\nObtener estadísticos -firmas- para las n clases de interés con una muestra de pixeles\n\n# statistics for unsupervised classification\ni.cluster group=l8 subgroup=l8 \\\n sig=l8_hpf \\\n classes=7 \\\n separation=0.6\n\nRealizar la clasificación no supervisada de toda la imagen\n\n# Maximum Likelihood unsupervised classification\ni.maxlik group=l8 subgroup=l8 \\\n sig=l8_hpf \\\n output=l8_hpf_class \\\n rej=l8_hpf_rej\n\nMostrar el mapa clasificado\n\n# display results\nd.mon wx0\nd.rast map=l8_hpf_class\n\n\nInformación derivada adicional podría obtenerse con los siguientes módulos, entre otros:\n\nmedidas de textura: r.texture,\nmedidas de diversidad: r.diversity,\nestadísticas locales con información de contexto: r.neighbors,\ntransformación tasseled cap: i.tasscap,\netc.\n\n\n\n\n\nTopic classification en los manuales de GRASS GIS\nImage classification en la wiki\nEjemplos de clasificación en el curso dictado en Noruega en 2018\nClasificación con Random Forest en la presentación del OpenGeoHub Summer School 2018 en Praga\nDetección de cambios con Landsat\n\nGracias por su atención!!\n\n\n\nGRASS GIS logo"
  },
  {
    "objectID": "unidad_2/python_and_grass.html",
    "href": "unidad_2/python_and_grass.html",
    "title": "Python y GRASS GIS",
    "section": "",
    "text": "En esta notebook, nos vamos a introducir en el uso de GRASS GIS con Python. Para ello, primero vamos a recorrer brevemente los principales paquetes/librerías de python que son parte de GRASS y nos permiten ejcutar sus funciones, a la vez que podemos combinar las salidas con otras librerías más tradicionales de python."
  },
  {
    "objectID": "unidad_2/python_and_grass.html#python-y-grass-gis",
    "href": "unidad_2/python_and_grass.html#python-y-grass-gis",
    "title": "Python y GRASS GIS",
    "section": "",
    "text": "Jupyter notebooks\nPaquetes Python dentro de GRASS\n\ngrass.script\ngrass.jupyter\ngrass.pygrass"
  },
  {
    "objectID": "unidad_2/python_and_grass.html#why-jupyter-notebooks-and-how-to-use-them",
    "href": "unidad_2/python_and_grass.html#why-jupyter-notebooks-and-how-to-use-them",
    "title": "Python y GRASS GIS",
    "section": "Why Jupyter Notebooks and how to use them?",
    "text": "Why Jupyter Notebooks and how to use them?\nJupyter Notebooks are server-client applications that allow code written in a notebook document to be edited and executed through a web browser. They can be run on a local computer (no internet access required) or used to control computations on a remote server accessed via the Internet (see the documentation).\nJupyter Notebooks can be interactive and they allow to combine live code, explanatory text, and computational results in a single document. In general, they are:\n\nconvenient for initial code development (prototyping)\nideal for code segmentation with the ability to re-run cells\nable to store values of variables from already executed cells\n\nThe notebook can be saved as an executable Python script in addition to the native .ipynb format, or exported to various documentation formats such as PDF or Sphinx RST with nice styling.\n\nEditing and interactive use\nEditing a Jupyter Notebook is very easy: in the web browser, you can navigate between text or code cells using the mouse or keyboard shortcuts (see Menu &gt; Help &gt; Keyboard Shortcuts). You can execute small code chunks cell by cell, save the notebook in its current state, or modify and recalculate cells or return them to their previous state. In addition to executable code cells, you can use Markdown in documentation cells to make them presentable to others."
  },
  {
    "objectID": "unidad_2/python_and_grass.html#grass-python",
    "href": "unidad_2/python_and_grass.html#grass-python",
    "title": "Python y GRASS GIS",
    "section": "GRASS & Python",
    "text": "GRASS & Python\n\nPython package grass.script\nEl grass.script o GRASS GIS Python Scripting Library provee funciones para llamar módulos de GRASS dentro de scripts Python. Las funciones más comúnmente usadas incluyen:\n\nrun_command: usada cuando la salida de los módulos es un raster o vector, no se espera una salida de tipo texto.\nread_command: se utiliza cuando la salida de los módulos es de tipo texto\nparse_command: se utiliza con módulos cuya salida puede convertirse en pares `key=value\nwrite_command: se utiliza con módulos que esperan una entrada de texto, ya sea en forma de archivo o desde stdin.\n\nTambién proporciona varias funciones de envoltura para módulos de uso frecuente, por ejemplo:\n\nPara obtener información de un raster, se utiliza script.raster.raster_info(): gs.raster_info('dsm')\nPara obtener información de un vector, se utiliza script.vector.vector_info(): gs.vector_info('roads')\nPara listar el raster en una ubicación, se utiliza script.core.list_grouped(): gs.list_grouped(type=['raster'])\nPara obtener la región de cálculo, se utiliza script.core.region(): gs.region()\n\n\nMore info: https://grass.osgeo.org/grass-stable/manuals/libpython/script_intro.html\n\n\nPython package grass.jupyter\nLa librería grass.jupyter mejora la integración de GRASS y Jupyter, y proporciona diferentes clases para facilitar la visualización de mapas de GRASS:\n\ninit: inicia una sesión de GRASS y configura todas las variables de entorno necesarias\nMap: renderizado 2D\nMap3D: renderizado 3D\nInteractiveMap`: visualización interactiva con folium\nTimeSeriesMap`: visualización de datos espacio-temporales\n\n\nMore info: https://grass.osgeo.org/grass-stable/manuals/libpython/grass.jupyter.html\n\n\nPython package grass.pygrass\nPyGRASS es una interfaz de programación de aplicaciones (API) de Python orientada a objetos para GRASS GIS. PyGRASS ofrece interfaces a los módulos y funcionalidades de GRASS, así como a datos vectoriales y ráster. PyGRASS mejora la integración entre GRASS GIS y Python, haciendo el uso de Python bajo GRASS más consistente con el lenguaje mismo. Además, simplifica el scripting y la programación de GRASS y lo hace más natural para el usuario.\nNosotros vamos a usar grass.pygrass.modules.shorcuts que nos permite llamar a los módulos o funciones de GRASS de forma muy parecida a cómo lo haríamos en la consola de GRASS."
  },
  {
    "objectID": "unidad_2/python_and_grass.html#ejemplos",
    "href": "unidad_2/python_and_grass.html#ejemplos",
    "title": "Python y GRASS GIS",
    "section": "Ejemplos",
    "text": "Ejemplos\n\n1+1"
  },
  {
    "objectID": "unidad_2/python_and_grass.html#otras-notebooks-tutoriales-y-links-útiles",
    "href": "unidad_2/python_and_grass.html#otras-notebooks-tutoriales-y-links-útiles",
    "title": "Python y GRASS GIS",
    "section": "Otras notebooks, tutoriales y links útiles",
    "text": "Otras notebooks, tutoriales y links útiles"
  },
  {
    "objectID": "unidad_2/python_and_grass.html#referencias",
    "href": "unidad_2/python_and_grass.html#referencias",
    "title": "Python y GRASS GIS",
    "section": "Referencias",
    "text": "Referencias"
  },
  {
    "objectID": "unidad_2/unit2_index.html",
    "href": "unidad_2/unit2_index.html",
    "title": "GRASS GIS 2023",
    "section": "",
    "text": "En esta unidad nos vamos a introducir en el uso de GRASS y Python, vamos a ver las nociones básicas del manejo y procesamiento de datos ráster en GRASS, y finalmente, vamos a ver cómo trabajamos con datos satelitales en GRASS, aplicando algunas de sus funciones específicas.\n\n\n\nVer en otra pestaña\n\n\nVer en otra pestaña\n\n\n\n\n\nVer en otra pestaña\n\n\nVer en otra pestaña"
  },
  {
    "objectID": "unidad_2/unit2_index.html#presentaciones-unidad-2",
    "href": "unidad_2/unit2_index.html#presentaciones-unidad-2",
    "title": "GRASS GIS 2023",
    "section": "",
    "text": "En esta unidad nos vamos a introducir en el uso de GRASS y Python, vamos a ver las nociones básicas del manejo y procesamiento de datos ráster en GRASS, y finalmente, vamos a ver cómo trabajamos con datos satelitales en GRASS, aplicando algunas de sus funciones específicas.\n\n\n\nVer en otra pestaña\n\n\nVer en otra pestaña\n\n\n\n\n\nVer en otra pestaña\n\n\nVer en otra pestaña"
  },
  {
    "objectID": "unidad_4/unit4_index.html",
    "href": "unidad_4/unit4_index.html",
    "title": "GRASS GIS 2023",
    "section": "",
    "text": "En esta unidad vamos a ver bla…\n\n\n\nVer en otra pestaña\n\n\nVer en otra pestaña"
  },
  {
    "objectID": "unidad_4/unit4_index.html#presentaciones-unidad-4",
    "href": "unidad_4/unit4_index.html#presentaciones-unidad-4",
    "title": "GRASS GIS 2023",
    "section": "",
    "text": "En esta unidad vamos a ver bla…\n\n\n\nVer en otra pestaña\n\n\nVer en otra pestaña"
  },
  {
    "objectID": "unidad_3/unit3_index.html",
    "href": "unidad_3/unit3_index.html",
    "title": "GRASS GIS 2023",
    "section": "",
    "text": "En esta unidad vamos a ver bla…\n\n\n\nVer en otra pestaña\n\n\nVer en otra pestaña"
  },
  {
    "objectID": "unidad_3/unit3_index.html#presentaciones-unidad-3",
    "href": "unidad_3/unit3_index.html#presentaciones-unidad-3",
    "title": "GRASS GIS 2023",
    "section": "",
    "text": "En esta unidad vamos a ver bla…\n\n\n\nVer en otra pestaña\n\n\nVer en otra pestaña"
  },
  {
    "objectID": "unidad_5/unit5_index.html",
    "href": "unidad_5/unit5_index.html",
    "title": "GRASS GIS 2023",
    "section": "",
    "text": "En esta unidad vamos a ver …\n\nVer en otra pestaña"
  },
  {
    "objectID": "unidad_5/unit5_index.html#presentaciones-unidad-5",
    "href": "unidad_5/unit5_index.html#presentaciones-unidad-5",
    "title": "GRASS GIS 2023",
    "section": "",
    "text": "En esta unidad vamos a ver …\n\nVer en otra pestaña"
  },
  {
    "objectID": "trabajo_final.html",
    "href": "trabajo_final.html",
    "title": "Trabajo final",
    "section": "",
    "text": "El objetivo de este documento es poder brindar las pautas generales para la realización de la práctica final, requisito necesario para la conclusión del taller. En esta última instancia de aprendizaje se espera que los alumnos incorporen los conocimientos adquiridos durante el desarrollo del taller.\n\nConsignas\nSe proponen 2 modalidades diferentes:\n\nInforme y presentación de trabajo final abordando algún problema/pregunta de interés utilizando herramientas de GRASS GIS\nTutorial abordando algún problema/pregunta de interés utilizando herramientas de GRASS GIS o demostrando el uso/aplicación de algún conjunto de módulos de GRASS\n\nLa selección de los grupos se realizará en la reunión del día Martes 23/03, mediante una aplicación online.\n\n1. Informe\nLa modalidad informe del trabajo integrador se realizará en grupos de 4 integrantes. El mismo debe abordar algún problema/pregunta de su interés utilizando herramientas que aprendimos durante el taller u otras de su interés disponibles en GRASS (ver modulos core y addons). Los trabajos deben incluir al menos los siguientes ítems: - Título - Integrantes del equipo - Introducción (descripción breve de problema, presentando la pregunta de investigación - máximo 2 párrafos) - Objetivo claro (i.e., orientado a los resultados que se desean obtener) - Descripción de datos empleados - Descripción de la metodología (incluyendo el código, se pueden incluir diagramas de flujo para ilustrar la metodología seguida) - Resultados (comentar los resultados más relevantes presentando mapas de salida, tablas y/o gráficos; los mapas deben contener como mínimo leyenda y escala) - Discusión y conclusiones\nSe entregará un informe de un máximo de 10 páginas en formato odt o pdf (letra tamaño 12). El trabajo deberá ser presentado mediante una exposición. Se valorará la calidad del trabajo técnico y la prolijidad y fluidez de la exposición. El tiempo de presentación de cada grupo será de 15 min + 5 min para preguntas.\nSe otorgará un reconocimiento al mejor trabajo seleccionado que consistirá en un espacio de exposición en directo en el canal de Youtube del Instituto Gulich.\nLos criterios de selección incluyen: - códigos reproducibles y documentados (legibilidad, estilo y escritura) - aplicabilidad de la propuesta - originalidad - resultados comprensibles\n\n\n2. Tutorial:\nEn grupos de 4 integrantes, escribir un tutorial del estilo de Working with i.landsat. Se puede optar por alguna temática o grupo de módulos de interés incluyendo cosas que no se hayan visto durante el taller pero se deseen aprender.\nEl tutorial debe estar escrito en Inglés y en formato markdown, incluir una breve introducción, descripción/link a datos, código explicado paso a paso, resultados parciales y finales en forma de mapas, tablas o gráficos, una mínima discusión y referencias.\nPara este trabajo requerirán crear una cuenta en GitHub, y un repositorio donde alojar el archivo markdown (.md). Se presentará directamente desde el archivo md (15 min de exposición + 5 min de preguntas) y se valorará con los mismos criterios descriptos anteriormente.\nCon los dos trabajos seleccionados, se realizará un pull request al repositorio donde de encuentra el sitio web de GRASS. Allí, será revisado por la comunidad y de ser aprobado, se publicará en las noticias y las redes sociales de GRASS GIS.\n\n\n\nFecha de entrega\nEl plazo límite para la entrega de los trabajos en cualquiera de sus formatos es el día 20/04/2021 a las 13:00. Los mismos deberán subirse a la Moodle en la Unidad 5.\nLa exposición de los trabajos se realizará el día 23/04/2021 en horario a acordar."
  },
  {
    "objectID": "trabajo_final.html#especificación-del-trabajo-integrador",
    "href": "trabajo_final.html#especificación-del-trabajo-integrador",
    "title": "Trabajo final",
    "section": "",
    "text": "El objetivo de este documento es poder brindar las pautas generales para la realización de la práctica final, requisito necesario para la conclusión del taller. En esta última instancia de aprendizaje se espera que los alumnos incorporen los conocimientos adquiridos durante el desarrollo del taller.\n\n\nSe proponen 2 modalidades diferentes:\n\nInforme y presentación de trabajo final abordando algún problema/pregunta de interés utilizando herramientas de GRASS GIS\nTutorial abordando algún problema/pregunta de interés utilizando herramientas de GRASS GIS o demostrando el uso/aplicación de algún conjunto de módulos de GRASS\n\nLa selección de los grupos se realizará en la reunión del día Martes 23/03, mediante una aplicación online.\n\n\nLa modalidad informe del trabajo integrador se realizará en grupos de 4 integrantes. El mismo debe abordar algún problema/pregunta de su interés utilizando herramientas que aprendimos durante el taller u otras de su interés disponibles en GRASS (ver modulos core y addons). Los trabajos deben incluir al menos los siguientes ítems: - Título - Integrantes del equipo - Introducción (descripción breve de problema, presentando la pregunta de investigación - máximo 2 párrafos) - Objetivo claro (i.e., orientado a los resultados que se desean obtener) - Descripción de datos empleados - Descripción de la metodología (incluyendo el código, se pueden incluir diagramas de flujo para ilustrar la metodología seguida) - Resultados (comentar los resultados más relevantes presentando mapas de salida, tablas y/o gráficos; los mapas deben contener como mínimo leyenda y escala) - Discusión y conclusiones\nSe entregará un informe de un máximo de 10 páginas en formato odt o pdf (letra tamaño 12). El trabajo deberá ser presentado mediante una exposición. Se valorará la calidad del trabajo técnico y la prolijidad y fluidez de la exposición. El tiempo de presentación de cada grupo será de 15 min + 5 min para preguntas.\nSe otorgará un reconocimiento al mejor trabajo seleccionado que consistirá en un espacio de exposición en directo en el canal de Youtube del Instituto Gulich.\nLos criterios de selección incluyen: - códigos reproducibles y documentados (legibilidad, estilo y escritura) - aplicabilidad de la propuesta - originalidad - resultados comprensibles\n\n\n\nEn grupos de 4 integrantes, escribir un tutorial del estilo de Working with i.landsat. Se puede optar por alguna temática o grupo de módulos de interés incluyendo cosas que no se hayan visto durante el taller pero se deseen aprender.\nEl tutorial debe estar escrito en Inglés y en formato markdown, incluir una breve introducción, descripción/link a datos, código explicado paso a paso, resultados parciales y finales en forma de mapas, tablas o gráficos, una mínima discusión y referencias.\nPara este trabajo requerirán crear una cuenta en GitHub, y un repositorio donde alojar el archivo markdown (.md). Se presentará directamente desde el archivo md (15 min de exposición + 5 min de preguntas) y se valorará con los mismos criterios descriptos anteriormente.\nCon los dos trabajos seleccionados, se realizará un pull request al repositorio donde de encuentra el sitio web de GRASS. Allí, será revisado por la comunidad y de ser aprobado, se publicará en las noticias y las redes sociales de GRASS GIS.\n\n\n\n\nEl plazo límite para la entrega de los trabajos en cualquiera de sus formatos es el día 20/04/2021 a las 13:00. Los mismos deberán subirse a la Moodle en la Unidad 5.\nLa exposición de los trabajos se realizará el día 23/04/2021 en horario a acordar."
  },
  {
    "objectID": "unidad_5/grass_and_r_sdm.html",
    "href": "unidad_5/grass_and_r_sdm.html",
    "title": "R y GRASS: Modelado de nicho",
    "section": "",
    "text": "En esta última sesión, vamos a demostrar y ejemplificar el uso combinado de GRASS y R para modelar la distribución de Aedes aegypti en la provincia de Córdoba en función de variables ambientales. Algunas de estas variables provienen de los ejercicios realizados en la unidad de series de tiempo y otras serán generadas durante este ejercicio."
  },
  {
    "objectID": "unidad_5/grass_and_r_sdm.html#usage",
    "href": "unidad_5/grass_and_r_sdm.html#usage",
    "title": "R y GRASS: Modelado de nicho",
    "section": "Usage",
    "text": "Usage\nGRASS GIS and R can be used together in two ways:\nA. Using R within a GRASS GIS session, i.e. starting R (or RStudio) from GRASS terminal \n\ntype R or rstudio & in the GRASS GIS terminal\nload rgrass library\nuse read_VECT(), read_RAST() to read data from GRASS into R\naccess GRASS GIS modules and database through execGRASS()\n\nwrite data (back) to GRASS database with write_VECT() and write_RAST()\n\n\n\n\n\n\nB. Using GRASS GIS within an R session, i.e. we connect to GRASS GIS database from within R (or RStudio). \n\nwe need to start GRASS GIS with initGRASS() from R\nwe access GRASS GIS modules through execGRASS()\n\nuse read_VECT(), read_RAST(), write_VECT() and write_RAST() to read data from and to GRASS database\n\n\n\n\n\n\n\nNote\n\n\n\nrgrass was originally intended to apply GRASS functions on data outside GRASS database; hence some prefer to create throw away locations"
  },
  {
    "objectID": "unidad_5/grass_and_r_sdm.html#references",
    "href": "unidad_5/grass_and_r_sdm.html#references",
    "title": "R y GRASS: Modelado de nicho",
    "section": "References",
    "text": "References\n\n\nBivand, R. (2022), rgrass: Interface Between ’GRASS’ Geographical Information System and ’R’.\n\n\nHijmans, R. J. (2022), terra: Spatial Data Analysis.\n\n\nVignali, S., Barras, A. G., Arlettaz, R., y Braunisch, V. (2020), «SDMtune: An R package to tune and evaluate species distribution models», Ecology and Evolution, 00, 1-18. https://doi.org/10.1002/ece3.6786."
  },
  {
    "objectID": "unidad_1/functions_in_grass.html#references",
    "href": "unidad_1/functions_in_grass.html#references",
    "title": "Funciones de GRASS GIS",
    "section": "Referencias",
    "text": "Referencias\n\n\nJasiewicz, J., y Metz, M. (2011), «A new GRASS GIS toolkit for Hortonian analysis of drainage networks», Computers & Geosciences, 37, 1162-1173. https://doi.org/10.1016/j.cageo.2011.03.003.\n\n\nWegmann, M., Leutner, B. F., Metz, M., Neteler, M., Dech, S., y Rocchini, D. (2018), «r.pi: A grass gis package for semi-automatic spatial pattern analysis of remotely sensed land cover data», Methods in Ecology and Evolution, 9, 191-199. https://doi.org/10.1111/2041-210X.12827."
  },
  {
    "objectID": "unidad_2/python_and_grass.html#por-qué-jupyter-notebooks-y-cómo-usarlos",
    "href": "unidad_2/python_and_grass.html#por-qué-jupyter-notebooks-y-cómo-usarlos",
    "title": "Python y GRASS GIS",
    "section": "¿Por qué Jupyter Notebooks y cómo usarlos?",
    "text": "¿Por qué Jupyter Notebooks y cómo usarlos?\nLos Cuadernos Jupyter son aplicaciones servidor-cliente que permiten que el código escrito en un documento de cuaderno sea editado y ejecutado a través de un navegador web. Pueden ejecutarse en un ordenador local (sin necesidad de acceso a Internet) o utilizarse para controlar cálculos en un servidor remoto al que se accede a través de Internet (véase la documentación).\nLos Jupyter Notebooks pueden ser interactivos y permiten combinar código en vivo, texto explicativo y resultados computacionales en un único documento. En general, son:\n\nconvenientes para el desarrollo inicial de código (prototipado)\nideales para la segmentación de código, con la posibilidad de volver a ejecutar celdas\ncapaces de almacenar valores de variables de celdas ya ejecutadas\n\nEl cuaderno puede guardarse como un script ejecutable de Python además del formato nativo .ipynb, o exportado a varios formatos de documentación como PDF o Sphinx RST con un bonito estilo.\n\nEdición y uso interactivo\nEditar un Jupyter Notebook es muy fácil: en el navegador web, puedes navegar entre celdas de texto o código utilizando el ratón o atajos de teclado (ver Menú &gt; Ayuda &gt; Atajos de teclado). Puede ejecutar pequeños fragmentos de código celda por celda, guardar el cuaderno en su estado actual, o modificar y recalcular celdas o devolverlas a su estado anterior. Además de las celdas de código ejecutables, puede puede utilizar Markdown en las celdas de documentación para hacerlas presentables a los demás."
  },
  {
    "objectID": "unidad_2/python_and_grass.html#por-qué-jupyter-notebooks-y-cómo-usarlas",
    "href": "unidad_2/python_and_grass.html#por-qué-jupyter-notebooks-y-cómo-usarlas",
    "title": "Python y GRASS GIS",
    "section": "¿Por qué Jupyter Notebooks y cómo usarlas?",
    "text": "¿Por qué Jupyter Notebooks y cómo usarlas?\nLas Jupyter Notebook son aplicaciones servidor-cliente que permiten que el código escrito en un documento de cuaderno sea editado y ejecutado a través de un navegador web. Pueden ejecutarse en un ordenador local (sin necesidad de acceso a Internet) o utilizarse para controlar cálculos en un servidor remoto al que se accede a través de Internet (véase la documentación).\nLos Jupyter Notebooks pueden ser interactivos y permiten combinar código en vivo, texto explicativo y resultados computacionales en un único documento. En general, son:\n\nconvenientes para el desarrollo inicial de código (prototipado)\nideales para la segmentación de código, con la posibilidad de volver a ejecutar celdas\ncapaces de almacenar valores de variables de celdas ya ejecutadas\n\nEl cuaderno puede guardarse como un script ejecutable de Python además del formato nativo .ipynb, o exportado a varios formatos de documentación como PDF o Sphinx RST con un bonito estilo.\n\nEdición y uso interactivo\nEditar un Jupyter Notebook es muy fácil: en el navegador web, puedes navegar entre celdas de texto o código utilizando el ratón o atajos de teclado (ver Menú &gt; Ayuda &gt; Atajos de teclado). Puede ejecutar pequeños fragmentos de código celda por celda, guardar el cuaderno en su estado actual, o modificar y recalcular celdas o devolverlas a su estado anterior. Además de las celdas de código ejecutables, puede puede utilizar Markdown en las celdas de documentación para hacerlas presentables a los demás."
  },
  {
    "objectID": "unidad_2/python_and_grass.html#grass.script",
    "href": "unidad_2/python_and_grass.html#grass.script",
    "title": "Python y GRASS GIS",
    "section": "grass.script",
    "text": "grass.script\nEl paquete grass.script o GRASS GIS Python Scripting Library provee funciones para llamar módulos de GRASS dentro de scripts o rutinas Python. Las funciones más comúnmente usadas incluyen:\n\nrun_command: usada cuando la salida de los módulos es un raster o vector, no se espera una salida de tipo texto.\nread_command: se utiliza cuando la salida de los módulos es de tipo texto.\nparse_command: se utiliza con módulos cuya salida puede convertirse en pares key=value o diccionarios.\nwrite_command: se utiliza con módulos que esperan una entrada de texto, ya sea en forma de archivo o desde stdin.\n\nEste paquete también proporciona varias funciones de wrapping para módulos de uso muy frecuente en GRASS, por ejemplo:\n\nPara obtener información de un raster, se utiliza script.raster.raster_info(): gs.raster_info('elevation')\nPara obtener información de un vector, se utiliza script.vector.vector_info(): gs.vector_info('roadsmajor')\nPara listar mapas de diferente tipo en un mapset, se utiliza script.core.list_grouped(): gs.list_grouped(type=['raster'])\nPara obtener la región computacional, se utiliza script.core.region(): gs.region()\n\n\n\n\n\n\n\nNota\n\n\n\nPara más detalles, ver la documentación del paquete en: https://grass.osgeo.org/grass-stable/manuals/libpython/script_intro.html"
  },
  {
    "objectID": "unidad_2/python_and_grass.html#grass.jupyter",
    "href": "unidad_2/python_and_grass.html#grass.jupyter",
    "title": "Python y GRASS GIS",
    "section": "grass.jupyter",
    "text": "grass.jupyter\nLa librería grass.jupyter mejora la integración de GRASS y Jupyter, y proporciona diferentes clases para facilitar la visualización de mapas de GRASS en el entorno Jupyter. Este paquete fue desarrollado por Haedrich et al. (2023) como parte de su proyecto para Google Summer of Code y con una student grant de GRASS.\nLas classes más importantes son:\n\ninit: inicia una sesión de GRASS y configura todas las variables de entorno necesarias para ejecutar GRASS desde Python y dentro de una Notebook.\nMap: renderiza mapas 2D\nMap3D: renderiza mapas 3D\nInteractiveMap: permite la visualización interactiva utilizando la librería folium\nTimeSeriesMap: permite la visualización de datos espacio-temporales\n\n\n\n\n\n\n\nNota\n\n\n\nPara más detalles, ver la documentación del paquete en: https://grass.osgeo.org/grass-stable/manuals/libpython/grass.jupyter.html"
  },
  {
    "objectID": "unidad_2/python_and_grass.html#grass.pygrass",
    "href": "unidad_2/python_and_grass.html#grass.pygrass",
    "title": "Python y GRASS GIS",
    "section": "grass.pygrass",
    "text": "grass.pygrass\nPyGRASS es una interfaz de programación de aplicaciones (API) de Python orientada a objetos para GRASS GIS desarrollada por Zambelli et al. (2013). PyGRASS ofrece interfaces a los módulos y funcionalidades de GRASS, así como a los datos vectoriales y ráster, de modo que permite acceder a cada minima unidad y desarrollar nuevos módulos con funciones de más bajo nivel. PyGRASS mejora la integración entre GRASS GIS y Python, haciendo el uso de Python bajo GRASS más consistente con el lenguaje mismo. Además, simplifica el scripting y la programación de GRASS y lo hace más natural para el usuario.\nDentro de esta librería, vamos a usar especialmente grass.pygrass.modules.shorcuts que nos permite llamar a los módulos o funciones de GRASS de forma muy parecida a cómo lo haríamos en la consola de GRASS.\n\n\n\n\n\n\nNota\n\n\n\nPara más detalles, ver la documentación del paquete en: https://grass.osgeo.org/grass-stable/manuals/libpython/pygrass_index.html"
  },
  {
    "objectID": "unidad_2/python_and_grass.html#ejemplos-con-grass.script",
    "href": "unidad_2/python_and_grass.html#ejemplos-con-grass.script",
    "title": "Python y GRASS GIS",
    "section": "Ejemplos con grass.script",
    "text": "Ejemplos con grass.script\nListamos los mapas raster del mapset PERMANENT:\n\nlista = gs.list_grouped(type = \"raster\")[\"PERMANENT\"]\nlista[:5]\n\nObtenemos info de un mapa raster:\n\ngs.raster_info(\"aspect\")[\"cols\"]\n\n\n\n\n\n\n\nTarea\n\n\n\nAhora, hagamos lo mismo pero para los mapas de tipo vectorial.\n\n\n\n# gs.list_grouped(type = \"vector\")\n\nImprimimos la region computacional actual:\n\ngs.region()\n\nCambiamos la región computacional al vector urbanarea:\n\ngs.region_env(vector=\"urbanarea\")\n\nVerificamos los atributos del vector seleccionado:\n\ngs.vector_db_select('urbanarea').values()\n\nExtraemos el área urbana de Raleigh:\n\ngs.run_command(\"v.extract\", \n               input=\"urbanarea\", \n               where=\"NAME == 'Raleigh'\", \n               output=\"urban_area_raleigh\")\n\nListamos los vectores por un patrón:\n\ngs.list_grouped(type=\"vector\", pattern=\"urban*\")\n\nVerificamos los atributos del nuevo vector creado:\n\ngs.vector_db_select(\"urban_area_raleigh\")\n\ny obtenemos información sobre el mismo. Notar que podemos seleccionar qué información queremos extraer, i.e., la salida es un diccionario.\n\n# show attributes\ngs.vector_info(\"urban_area_raleigh\")\n\nUsamos otra manera de establecer la región computacional:\n\nregion = gs.parse_command(\"g.region\", \n                          vector=\"urban_area_raleigh\", \n                          flags=\"g\")\nregion"
  },
  {
    "objectID": "unidad_2/python_and_grass.html#ejemplos-con-grass.jupyter",
    "href": "unidad_2/python_and_grass.html#ejemplos-con-grass.jupyter",
    "title": "Python y GRASS GIS",
    "section": "Ejemplos con grass.jupyter",
    "text": "Ejemplos con grass.jupyter\nAhora vamos a demostrar el uso de las dos clases más comunes del paquete grass.jupyter para graficar mapas. Usamos primeramente la clase interactiva que nos permite mostrar nuestras salidas sobre mapas base como el de OpenStreetMap, por ejemplo.\n\nraleigh_map = gj.InteractiveMap(width = 500, use_region=True, tiles=\"OpenStreetMap\")\nraleigh_map.add_raster(\"elevation\")\nraleigh_map.add_vector(\"urban_area_raleigh\")\nraleigh_map.add_layer_control(position = \"bottomright\")\nraleigh_map.show()\n\nA continuación, creamos una salida estática, utilizando la clase Map. Esta salida es similar a utilizar el Map Display en la GUI y exportar el resultado.\n\nraleigh_map = gj.Map(width=500)\nraleigh_map.d_rast(map=\"elevation\")\nraleigh_map.d_vect(map=\"lakes\")\nraleigh_map.d_legend(raster=\"elevation\", \n                     title=\"Height (m)\", \n                     fontsize=10, \n                     at=(70, 90, 80, 90), \n                     flags=\"b\")\nraleigh_map.d_barscale()\nraleigh_map.show()"
  },
  {
    "objectID": "unidad_2/python_and_grass.html#ejemplos-con-grass.pygrass",
    "href": "unidad_2/python_and_grass.html#ejemplos-con-grass.pygrass",
    "title": "Python y GRASS GIS",
    "section": "Ejemplos con grass.pygrass",
    "text": "Ejemplos con grass.pygrass\nFinalmente, vamos a ejemplificar el uso de la interfaz modules dentro de grass.pygrass. Si bien esta interfaz nos permite ejecutar comandos de GRASS casi como si los ejecutásemos en la terminal, las salidas no están optimizadas para ser usadas como entrada para otros comandos. Para ello, es más conveniente usar grass.script o funciones de más bajo nivel de grass.pygrass que permiten acceder a los componentes básicos de los objetos dentro de GRASS.\n\nfrom grass.pygrass.modules.shortcuts import general as g\nfrom grass.pygrass.modules.shortcuts import raster as r\nfrom grass.pygrass.modules.shortcuts import vector as v\n\n\ng.region(flags=\"p\")\n\n\nv.info(map=\"roadsmajor\")\n\n\nr.report(map=\"elevation\", nsteps=\"10\", quiet=True)"
  },
  {
    "objectID": "unidad_2/raster_data_in_grass.html",
    "href": "unidad_2/raster_data_in_grass.html",
    "title": "Datos raster en GRASS GIS",
    "section": "",
    "text": "Un mapa raster es un arreglo de celdas en forma de grilla. Tiene filas y columnas y en cada celda hay un dato o un indicador de no-data (valor nulo). En GRASS, los mapas raster pueden ser arreglos 2D o 3D.\n\nLos límites se describen en los campos norte (n), sur (s), este (e) y oeste (w).\nLa extensión se calcula a partir de los límites externos de todas las celdas del mapa.\n\n\n\n\n\n\n\nNota\n\n\n\nPara más info ver la página raster intro"
  },
  {
    "objectID": "unidad_2/raster_data_in_grass.html#precisión-de-datos-raster",
    "href": "unidad_2/raster_data_in_grass.html#precisión-de-datos-raster",
    "title": "Datos raster en GRASS GIS",
    "section": "Precisión de datos raster",
    "text": "Precisión de datos raster\nLa precisión de los datos raster en GRASS, se clasifica en:\n\nCELL DATA TYPE: un mapa raster de tipo ENTERO (sólo números enteros)\nFCELL DATA TYPE: un mapa raster de tipo FLOTANTE (4 bytes, 7-9 dígitos de precisión)\nDCELL DATA TYPE: un mapa raster de tipo DOBLE (8 bytes, 15-17 dígitos de precisión)\n\n\n\n\n\n\n\nNota\n\n\n\nPara más info ver la wiki sobre semántica de rasters"
  },
  {
    "objectID": "unidad_2/raster_data_in_grass.html#reglas-generales-para-raster-en-grass",
    "href": "unidad_2/raster_data_in_grass.html#reglas-generales-para-raster-en-grass",
    "title": "Datos raster en GRASS GIS",
    "section": "Reglas generales para raster en GRASS",
    "text": "Reglas generales para raster en GRASS\n\nMapas raster de salida u output tienen sus límites y resolución iguales a los de la región computacional\nMapas raster de entrada o input son automáticamente cortados y reajustados a la región computacional\nMapas raster de entrada o input se enmascaran automáticamente si existe un mapa raster llamado MASK.\n\n\nExcepción: Todos los módulos r.in.* leen los datos celda por celda sin remuestreo (a menos que se especifique lo contrario"
  },
  {
    "objectID": "unidad_2/raster_data_in_grass.html#null-valores-nulos-en-grass-gis",
    "href": "unidad_2/raster_data_in_grass.html#null-valores-nulos-en-grass-gis",
    "title": "Datos raster en GRASS GIS",
    "section": "NULL: valores nulos en GRASS GIS",
    "text": "NULL: valores nulos en GRASS GIS\n\nNULL representa “sin dato” en los mapas raster\nOperaciones con celdas NULL producen celdas NULL\nLos valores NULL son gestionados con r.null\n\n# establecer el valor no-data\nr.null map=mapname setnull=-9999\n\n# reemplazar NULL por un número \nr.null map=mapname null=256"
  },
  {
    "objectID": "unidad_2/raster_data_in_grass.html#máscaras-en-grass-gis",
    "href": "unidad_2/raster_data_in_grass.html#máscaras-en-grass-gis",
    "title": "Datos raster en GRASS GIS",
    "section": "Máscaras en GRASS GIS",
    "text": "Máscaras en GRASS GIS\n\nSe puede crear un mapa raster llamado MASK para enmascarar ciertas áreas, como por ejemplo el mar, los lagos, o el área por fuera de un polígono de interés.\nTodas las celdas que sean NULL en el mapa MASK serán ignoradas, del mismo modo que son ignoradas todas las celdas por fuera de la región computacional.\nLas máscaras se gestionan con r.mask o creando un raster con el nombre MASK via álgebra de mapas.\nLos mapas vectoriales también pueden usarse como máscaras y se pueden establecer máscaras inversas.\n\n\n\n\na- Raster elevation y vector lakes. b- Sólo los datos raster dentro de la máscara son usados para análisis posteriores. c- Máscara inversa.\n\n\nVeamos algunos ejemplos de cómo aplicar máscaras\n# usar un vector como máscara\nr.mask vector=lakes\n\n# usar un vector como máscara inversa\nr.mask -i vector=lakes\n\n# enmascarar solo algunos valores de un mapa raster \nr.mask raster=landclass96 maskcats=\"5 thru 7\"\n\n# crear un raster MASK\nr.mapcalc expression=\"MASK = if(elevation &lt; 100, 1, null())\"\n\n# remover la máscara\nr.mask -r\nUna máscara sólo se aplica realmente cuando se lee un mapa raster, es decir, cuando se usa como entrada en un módulo.\nVeamos un ejemplo:\ng.region -p raster=elevation\nr.mask -i vector=lakes\nr.grow.distance -n input=elevation distance=distance\nr.mask -r\n\n\n\na- Máscara activa. b- Máscara desactivada.\n\n\nr.mask -i vector=lakes\nr.out.gdal input=distance output=distance.tif\nqgis distance.tif\n\n\n\nMáscara leída al exportar\n\n\n\nRegión computacional\n\nLa región computacional está definida en función de la extensión dada por los límites norte, sur, este y oeste y una resolución espacial. Aplica únicamente a las operaciones con datos raster.\nLa región de un mapa raster está definida por la extensión del mapa y la resolución del mapa. Cada mapa raster tiene su región, pero la región computacional tiene precedencia.\nLa región de visualizacion es la extensión del map display independiente de la región computacional y la región del mapa raster.\n\n\nLa región computacional puede definirse y modificarse mediante el módulo g.region a la extensión de un mapa vectorial, un raster o manualmente a alguna zona de interés. También puede establecerse a la extensión de un vector y alinear la resolución a un determinado mapa raster. Por ejemplo:\ng.region -p vector=lakes align=elevation\nPor otra, es posible establecer la región computacional a partir de la región de visualización y guardarla con un nombre para luego volver a aplicarla."
  },
  {
    "objectID": "unidad_2/raster_data_in_grass.html#importarexportar-máscara-y-región",
    "href": "unidad_2/raster_data_in_grass.html#importarexportar-máscara-y-región",
    "title": "Datos raster en GRASS GIS",
    "section": "Importar/exportar, máscara y región",
    "text": "Importar/exportar, máscara y región\n\nr.in.* y r.import importan siempre el mapa completo (a menos que se establezca el recorte a la región). Luego, es posible establecer la región a la resolución (y extensión) del mapa con g.región -p raster=mapname.\nr.out.* exportan mapas raster según la definición de la región computacional (extensión y resolución) y respetan la máscara si está presente. Se aplica interpolación por vecino más cercano por defecto.\n\n\n\n\n\n\n\nImportante\n\n\n\nEn la importación y la exportación, los mapas vectoriales se consideran siempre en toda su extensión."
  },
  {
    "objectID": "unidad_2/raster_data_in_grass.html#reportes-y-estadísticas",
    "href": "unidad_2/raster_data_in_grass.html#reportes-y-estadísticas",
    "title": "Datos raster en GRASS GIS",
    "section": "Reportes y estadísticas",
    "text": "Reportes y estadísticas\n\nr.report: reporta área y número de celdas\nr.coin: reporta la matriz o tabla de coincidencia entre dos mapas raster\n\n# Ejemplos\nr.report map=zipcodes,landclass96 units=h,p\nr.coin first=zipcodes second=landclass96 units=p\n\nr.univar: calcula estadísticas descriptivas a partir de las celdas no nulas de un mapa raster\nr.stats: calcula el área de cada una de las categorías o intervalos de un mapa raster\nr.statistics y r.stats.zonal: estadística zonal\nr.neighbors: estadística local basada en las celdas vecinas\n\n# estadísticas descriptivas\nr.univar map=elevation\n\n# estadística zonal: elevacion promedio por código postal\nr.stats.zonal base=zipcodes cover=elevation method=average output=zipcodes_elev_avg"
  },
  {
    "objectID": "unidad_2/raster_data_in_grass.html#álgebra-de-mapas-raster",
    "href": "unidad_2/raster_data_in_grass.html#álgebra-de-mapas-raster",
    "title": "Datos raster en GRASS GIS",
    "section": "Álgebra de mapas raster",
    "text": "Álgebra de mapas raster\nEl módulo r.mapcalc nos permite realizar múltiples operaciones entre mapas. Así, podemos crear nuevos mapas ráster que sean expresiones aritméticas en las que intervengan mapas ráster existentes, constantes enteras o de punto flotante y funciones.\n\n\n\n\n\n\nOperadores\nLos operadores se aplican de izquierda a derecha, aplicándose los de mayor precedencia antes que los de menor precedencia. La división por 0 y el módulo por 0 son aceptables y dan un resultado NULL. Los operadores lógicos dan un resultado 1 si la comparación es verdadera, 0 en caso contrario.\n\n\n\n\nOperator\nMeaning\nType\n\n\n\n\n-\nnegation\nArithmetic\n\n\n~\none’s complement\nBitwise\n\n\n!\nnot\nLogical\n\n\n^\nexponentiation\nArithmetic\n\n\n%\nmodulus\nArithmetic\n\n\n/\ndivision\nArithmetic\n\n\n*\nmultiplication\nArithmetic\n\n\n+\naddition\nArithmetic\n\n\n-\nsubtraction\nArithmetic\n\n\n&lt;&lt;\nleft shift\nBitwise\n\n\n&gt;&gt;\nright shift\nBitwise\n\n\n&gt;&gt;&gt;\nright shift (unsigned)\nBitwise\n\n\n&gt;\ngreater than\nLogical\n\n\n&gt;=\ngreater than or equal\nLogical\n\n\n&lt;\nless than\nLogical\n\n\n&lt;=\nless than or equal\nLogical\n\n\n==\nequal\nLogical\n\n\n!=\nnot equal\nLogical\n\n\n&\nbitwise and\nBitwise\n\n\n|\nbitwise or\nBitwise\n\n\n&&\nlogical and\nLogical\n\n\n&&&\nlogical and1\nLogical\n\n\n||\nlogical or\nLogical\n\n\n|||\nlogical or2\nLogical\n\n\n?:\nconditional\nLogical\n\n\n\n\n\n\nOperador vecinos o índices [row,col]\nLos mapas y las imágenes son matrices bidimensionales. En r.mapcalc, los mapas pueden ir seguidos de un modificador de vecindad que especifica un desplazamiento relativo desde la celda actual que se está evaluando. El formato es map[r,c], donde r es el desplazamiento de fila y c es el desplazamiento de columna. Por ejemplo, map[1,2] se refiere a la celda situada una fila por debajo y dos columnas a la derecha de la celda actual, map[-2,-1] se refiere a la celda situada dos filas por encima y una columna a la izquierda de la celda actual, y map[0,1] se refiere a la celda situada una columna a la derecha de la celda actual. Esta sintaxis permite desarrollar filtros de vecindad dentro de un mismo mapa o en varios mapas.\n# ejemplo filtro de paso bajo con operador de vecinos\nr.mapcalc \\\nexpression=\"lsat7_2002_10_smooth = (lsat7_2002_10[-1,-1] + \n                                    lsat7_2002_10[-1,0] + \n                                    lsat7_2002_10[1,1] + \n                                    lsat7_2002_10[0,-1] + \n                                    lsat7_2002_10[0,0] + \n                                    lsat7_2002_10[0,1] + \n                                    lsat7_2002_10[1,-1] + \n                                    lsat7_2002_10[1,0] + \n                                    lsat7_2002_10[1,1]) / 9\"\nPodemos comparar con la herramienta mapswipe, por ejemplo:\ng.gui.mapswipe first=lsat7_2002_10 second=lsat7_2002_10_smooth\n\n\n\n\n\n\n\nFunciones\nLas funciones actualmente admitidas se enumeran en la tabla siguiente. El tipo del resultado se indica en la última columna. F significa que las funciones siempre dan como resultado un valor de coma flotante, I significa que la función da un resultado entero, y * indica que el resultado es flotante si alguno de los argumentos de la función son valores de coma flotante y entero si todos los argumentos son enteros.\n\n\n\n\n\n\n\nCláusula if\n# Ejemplo: \n# Determinar las zonas forestales situadas por encima \n# de una cierta elevación\n\n# establecer la región computacional\ng.region rast=landclass96\n\n# reportar las clases de cobertura\nr.report map=landclass96 units=p\n\n# estadística univariada del mapa de elevacion\nr.univar map=elevation\n\n# seleccionar áreas &gt; 120m y con bosque\nr.mapcalc expression=\"forest_high = if(elevation &gt; 120 && landclass96 == 5, 1, null())\""
  },
  {
    "objectID": "unidad_2/raster_data_in_grass.html#regresión-simple-y-múltiple",
    "href": "unidad_2/raster_data_in_grass.html#regresión-simple-y-múltiple",
    "title": "Datos raster en GRASS GIS",
    "section": "Regresión simple y múltiple",
    "text": "Regresión simple y múltiple\n\nr.regression.line: regresión simple\nr.regression.multi: regresión múltiple\n\n# regresión simple\ng.region raster=elev_srtm_30m -p\nr.regression.line mapx=elev_ned_30m mapy=elev_srtm_30m \n\n# regresión múltiple\ng.region raster=soils_Kfactor -p\nr.regression.multi mapx=elevation,aspect,slope mapy=soils_Kfactor \\\n  residuals=soils_Kfactor.resid estimates=soils_Kfactor.estim"
  },
  {
    "objectID": "unidad_2/raster_data_in_grass.html#definición",
    "href": "unidad_2/raster_data_in_grass.html#definición",
    "title": "Datos raster en GRASS GIS",
    "section": "",
    "text": "Un mapa raster es un arreglo de celdas en forma de grilla. Tiene filas y columnas y en cada celda hay un dato o un indicador de no-data (valor nulo). En GRASS, los mapas raster pueden ser arreglos 2D o 3D.\n\nLos límites se describen en los campos norte (n), sur (s), este (e) y oeste (w).\nLa extensión se calcula a partir de los límites externos de todas las celdas del mapa.\n\n\n\n\n\n\n\nNota\n\n\n\nPara más info ver la página raster intro"
  },
  {
    "objectID": "unidad_2/raster_data_in_grass.html#reglas-generales-para-los-datos-raster-en-grass",
    "href": "unidad_2/raster_data_in_grass.html#reglas-generales-para-los-datos-raster-en-grass",
    "title": "Datos raster en GRASS GIS",
    "section": "Reglas generales para los datos raster en GRASS",
    "text": "Reglas generales para los datos raster en GRASS\n\nLos mapas raster de salida u output tienen sus límites y resolución iguales a los de la región computacional establecida.\nLos mapas raster de entrada o input son automáticamente cortados y reajustados a la región computacional.\nMapas raster de entrada o input se enmascaran automáticamente si existe un mapa raster llamado MASK en el mapset.\n\n\n\n\n\n\n\nExcepción\n\n\n\nTodos los módulos r.in.* leen los datos celda por celda sin remuestreo y con su resolución y extensión originales -a menos que se especifique lo contrario."
  },
  {
    "objectID": "unidad_2/raster_data_in_grass.html#reportes-y-estadísticas-de-mapas-raster",
    "href": "unidad_2/raster_data_in_grass.html#reportes-y-estadísticas-de-mapas-raster",
    "title": "Datos raster en GRASS GIS",
    "section": "Reportes y estadísticas de mapas raster",
    "text": "Reportes y estadísticas de mapas raster\nExisten diversos módulos que nos permiten generar reportes y estadísticas de los mapas raster. Algunos de los más usados son:\n\nr.report: reporta área y número de celdas de un mapa raster\nr.coin: reporta la matriz o tabla de coincidencia entre dos mapas raster\nr.univar: calcula estadísticas descriptivas a partir de las celdas no nulas de un mapa raster\nr.stats: calcula el área de cada una de las categorías o intervalos de un mapa raster\nr.statistics y r.stats.zonal: estadística zonal\nr.neighbors: estadística local basada en las celdas vecinas\n\nVeamos algunos ejemplos:\n# reportes\nr.report map=zipcodes,landclass96 units=h,p\nr.coin first=zipcodes second=landclass96 units=p\n\n# estadísticas descriptivas\nr.univar map=elevation\n\n# estadística zonal: elevacion promedio por código postal\nr.stats.zonal base=zipcodes cover=elevation method=average output=zipcodes_elev_avg"
  },
  {
    "objectID": "unidad_2/raster_data_in_grass.html#footnotes",
    "href": "unidad_2/raster_data_in_grass.html#footnotes",
    "title": "Datos raster en GRASS GIS",
    "section": "Notas",
    "text": "Notas\n\n\nThe &&& and ||| operators handle null values differently to other operators. See the section entitled NULL support in the manual for more details.↩︎\nThe &&& and ||| operators handle null values differently to other operators. See the section entitled NULL support in the manual for more details.↩︎"
  },
  {
    "objectID": "unidad_2/raster_data_in_grass.html#resampleo-e-interpolacion",
    "href": "unidad_2/raster_data_in_grass.html#resampleo-e-interpolacion",
    "title": "Datos raster en GRASS GIS",
    "section": "Resampleo e interpolacion",
    "text": "Resampleo e interpolacion\nEl procesamiento de mapas raster de GRASS se realiza siempre en la configuración actual de la región, es decir, se utiliza la extensión y resolución actual de la región. Si la resolución de la región difiere de la del mapa(s) raster de entrada, se realiza un remuestreo sobre la marcha (remuestreo del vecino más cercano). Si no se desea, los mapas de entrada deben remuestrearse previamente con uno de los módulos específicos.\nLos siguientes módulos están disponibles para la reinterpolación de mapas raster “rellenos” (datos continuos) a una resolución diferente:\n\nr.resample utiliza el remuestreo incorporado, por lo que debería producir resultados idénticos al remuestreo sobre la marcha realizado a través de los módulos de importación raster.\nr.resamp.interp remuestreo con el método del vecino más cercano, bilineal y bicúbico. Para r.resamp.interp method=bilinear y method=bicubic, los valores ráster se tratan como muestras en el centro de cada celda ráster, definiendo una superficie continua a trozos. Los valores raster resultantes se obtienen muestreando la superficie en el centro de cada celda de la región. Como el algoritmo sólo interpola, y no extrapola, se pierde un margen de 0,5 (para bilineal) o 1,5 (para bicúbica) celdas de la extensión de la trama original. Cualquier muestra tomada dentro de este margen será nula.\nr.resamp.rst (Regularized Spline with Tension - RST): Se comporta de forma similar, es decir, calcula una superficie asumiendo que los valores son muestras en el centro de cada celda del raster, y muestrea la superficie en el centro de cada celda de la región.\nr.resamp.bspline Interpolación spline bicúbica o bilineal con regularización Tykhonov.\nPara r.resamp.stats sin -w, el valor de cada celda de región es el agregado elegido de los valores de todas las celdas ráster cuyos centros caen dentro de los límites de la celda de región. Con -w, las muestras se ponderan de acuerdo con la proporción de la celda ráster que cae dentro de los límites de la celda de la región, por lo que el resultado normalmente no se ve afectado por el error de redondeo.\nr.fillnulls para el relleno de agujeros (por ejemplo, SRTM DEM).\n\nAdemás, hay módulos disponibles para la reinterpolación de mapas “dispersos” (puntos o líneas dispersos):\n\nInterpolación de la media ponderada de la distancia inversa (IDW) (r.surf.idw)\nInterpolación a partir de curvas de nivel (r.contour)\nVarios módulos vectoriales para la interpolación: v.surf.*\nPara datos Lidar y similares, r.in.pdal y r.in.xyz permiten cargar y agrupar datos ASCII x,y,z sin cuadricular en un nuevo mapa ráster. El usuario puede elegir entre diversos métodos estadísticos para crear el nuevo mapa de trama."
  },
  {
    "objectID": "unidad_2/raster_data_in_grass.html#parcheo-y-agregaciones-temporales",
    "href": "unidad_2/raster_data_in_grass.html#parcheo-y-agregaciones-temporales",
    "title": "Datos raster en GRASS GIS",
    "section": "Parcheo y agregaciones temporales",
    "text": "Parcheo y agregaciones temporales\n\nr.patch: Crea un mapa raster utilizando los valores de las categorías de uno (o más) mapa(s) para rellenar las áreas “sin datos” en otro mapa\n\n\n\n\nParcheo de mapas raster\n\n\n\nr.series: Permite agregar una lista de mapas con diferentes métodos como promedio, mínimo, máximo, etc.\n\n\n\n\nOperaciones con varios mapas raster"
  },
  {
    "objectID": "unidad_2/raster_data_in_grass.html#correlación-regresión-simple-y-múltiple",
    "href": "unidad_2/raster_data_in_grass.html#correlación-regresión-simple-y-múltiple",
    "title": "Datos raster en GRASS GIS",
    "section": "Correlación, regresión simple y múltiple",
    "text": "Correlación, regresión simple y múltiple\n\nr.covar: matriz de covarianza o correlación entre mapas raster\nr.regression.line: regresión lineal simple\nr.regression.multi: regresión lineal múltiple\n\n# correlación\ng.region raster=elevation\nr.covar -r map=elevation,aspect,slope\n\n# regresión simple\ng.region raster=elev_srtm_30m -p\nr.regression.line mapx=elev_ned_30m mapy=elev_srtm_30m \n\n# regresión múltiple\ng.region raster=soils_Kfactor -p\nr.regression.multi mapx=elevation,aspect,slope mapy=soils_Kfactor \\\n  residuals=soils_Kfactor.resid estimates=soils_Kfactor.estim"
  },
  {
    "objectID": "unidad_2/raster_data_in_grass.html#compresión-de-datos",
    "href": "unidad_2/raster_data_in_grass.html#compresión-de-datos",
    "title": "Datos raster en GRASS GIS",
    "section": "Compresión de datos",
    "text": "Compresión de datos\nTodos los tipos de mapas raster de GRASS GIS están por defecto comprimidos con ZSTD si la librería está disponible, de lo contrario se usa ZLIB. El método de compresión se establece a través de la variable de ambiente GRASS_COMPRESSOR. Los métodos disponibles son: RLE, ZLIB, LZ4, BZIP2, o ZSTD.\nImportante: la compresión de archivos NULL puede ser desactivada con export GRASS_COMPRESS_NULLS=0. La compresión de archivos NULL para un mapa raster en particular puede ser manejada con r.null -z.\nLos mapas raster de punto flotante (FCELL, DCELL) nunca usan compresión RLE; son comprimidos con ZLIB, LZ4, BZIP2, ZSTD o sin compresión.\nLa descompresión está controlada por el módulo r.compress, no por la variable de entorno."
  },
  {
    "objectID": "unidad_2/exercise_sentinel2.html",
    "href": "unidad_2/exercise_sentinel2.html",
    "title": "Ejercicio: Datos satelitales en GRASS GIS",
    "section": "",
    "text": "Sentinel 2 satellite\n\n\n\nLanzamiento: Sentinel-2A en 2015, Sentinel-2B en 2017\nTiempo de revisita: ~5 días\nCobertura sistemática de áreas terrestres y costeras entre los 84°N y 56°S\n13 bandas espectrales con resolución espacial de 10 m (VIS y NIR), 20 m (red-edge y SWIR) y 60 m (otras)\n\n\n\n\nSentinels\n\n\nESA - Satélites Copernicus Sentinel. Más información en: https://www.copernicus.eu/en/about-copernicus/infrastructure/discover-our-satellites\nDistribución de bandas de Sentinel 2 comparadas con Landsat\n\n\n\nSentinel and Landsat bands\n\n\n\n\n\ni.sentinel.download: descarga productos Copernicus Sentinel de Copernicus Open Access Hub\ni.sentinel.import: importa datos Sentinel descargados de Copernicus Open Access Hub\ni.sentinel.preproc: importa y realiza corrección atmosférica y topográfica de imágenes S2\ni.sentinel.mask: crea máscaras de nubes y sombras para imágenes S2\n\nVer Sentinel wiki para más detalles)\nRecientemente, se sumaron nuevos miembros en la familia i.sentinel:\n\ni.sentinel.coverage: comprueba la cobertura de área de las escenas de S1 o S2 seleccionadas\ni.sentinel.parallel.download: descarga imagenes Sentinel en paralelo\nPara conectarse al Copernicus Open Access Hub a través de i.sentinel.download, se necesita ser usuario registrado\nCrear el archivo SENTINEL_SETTING.txt en el directorio $HOME/gisdata/ con el siguiente contenido:\n\nyour_username\nyour_password\n\n\n\n\nL1C: Reflectancia a tope de atmósfera o Top of Atmosphere (TOA). Disponibles desde el lanzamiento.\nL2A: Reflectancia Superficial o Bottom of Atmosphere (BOA), i.e., los datos han sido corregidos para remover los efectos de la atmósfera. Sólo desde 2019.\n\n\n\n\n\nLong Term Archive (LTA)\nTodos los productos (1C o 2A) de más de un año son movidos fuera de línea y se requiere un tiempo de espera para ponerlos a disposición del usuario. Esto dificulta la automatización de tareas con productos de más de 12 meses de antigüedad.\n\nIniciar GRASS GIS, crear nuevo mapset y establecer región computacional\n\nimport os\n\n# data directory\nhomedir = os.path.expanduser('~')\n\n# GRASS GIS database variables\ngrassdata = os.path.join(homedir, \"grassdata\")\nproject = \"posgar2007_4_cba\"\nmapset = \"PERMANENT\"\n\n\nimport subprocess\nimport sys\n\n# Ask GRASS GIS where its Python packages are to be able to start it from the notebook\nsys.path.append(\n    subprocess.check_output([\"grass\", \"--config\", \"python_path\"], text=True).strip()\n)\n\n# Importar los paquetes python de GRASS\nimport grass.script as gs\nimport grass.jupyter as gj\n\n# Iniciar GRASS\nsession = gj.init(grassdata, location, mapset)\n\nCrear un nuevo mapset sentinel2\n\n# Create a new mapset\ng.mapset -c mapset=sentinel2\n\nDefinir la región computacionalal radio urbano de Córdoba\n\n# set the computational region to the extent of Cordoba urban area\ng.region -p vector=radio_urbano_cba\n\n\n\n\nInstalar la extensión i.sentinel\n\n# install i.sentinel extension\ng.extension extension=i.sentinel\n\nLista de escenas disponibles que intersectan la región computacional\n\n# explore list of scenes for a certain date range\ni.sentinel.download -l \\\n  settings=$HOME/gisdata/SENTINEL_SETTING.txt \\\n  start=\"2020-03-01\" \\\n  end=\"2020-04-30\" \\\n  producttype=S2MSI2A \\\n  clouds=30\n\nLista de escenas disponibles que contienen la región computacional\n\n# filter list of scenes by area_relation=Contains\ni.sentinel.download -l \\\n  settings=$HOME/gisdata/SENTINEL_SETTING.txt \\\n  start=\"2020-03-01\" \\\n  end=\"2020-04-30\" \\\n  producttype=S2MSI2A \\\n  clouds=30 \\\n  area_relation=Contains\n\nDescargar la escena seleccionada - NO EJECUTAR\n\n# download the scene that fully contains our region\n# i.sentinel.download \\\n#   settings=$HOME/gisdata/SENTINEL_SETTING.txt \\\n#   uuid=9a1ea49c-0561-4aa5-ba7a-dc820dc1a316 \\\n#   output=$HOME/gisdata/s2_data\n\nComo la descarga desde el Copernicus Open Access Hub toma su tiempo, vamos a descargar la escena Sentinel 2 que usaremos y moverla a HOME/gisdata/s2_data\nHagamos una prueba con datos del LTA…\n\ni.sentinel.download -l \\\n  settings=$HOME/gisdata/SENTINEL_SETTING.txt \\\n  start=\"2019-01-01\" \\\n  end=\"2020-02-28\" \\\n  clouds=30\n\ni.sentinel.download \\\n  settings=$HOME/gisdata/SENTINEL_SETTING.txt \\\n  uuid=d4e5df0e-7ead-4407-ba82-d2583be1a6b8 \\\n  output=$HOME/gisdata/s2_data\n\n\n\n\n\n\n\n\n\n\n\nPara obtener un valor de AOD, tenemos 2 opciones:\nA. Estimar el valor desde un grafico\n\nB. Descargar un archivo y el valor sera estimado \nhttp://aeronet.gsfc.nasa.gov\nObtener AOD de  http://aeronet.gsfc.nasa.gov\n\n\nEstación ARM_Cordoba o Pilar_Cordoba\nSeleccionar fechas de inicio y final\nSeleccionar: Combined file y All points\nDescargar y descomprimir (el archivo final tiene extensión .dubovik)\nPasar el archivo con la opción aeronet_file\n\nMapa de elevación\n\nr.in.srtm.region: importa (y re-proyecta) los mosaicos SRTM que cubren la región computacional, parchea los mosaicos e interpola datos faltantes\nr.in.nasadem: importa (y re-proyecta) los mosaicos de NASADEM que cubren la región computacional y parchea los mosaicos\n\n\nSi el DEM es más chico que la región computacional, sólo la región cubierta por el DEM será corregida atmosféricamente…\n\nEjemplo\n# enter directory with Sentinel scene and unzip file\ncd $HOME/gisdata/s2_data/\nunzip $HOME/gisdata/s2_data/name_of_S2_scene\n\ni.sentinel.preproc -atr \\\n  input_dir=$HOME/gisdata/s2_data/name_of_S2_scene.SAFE \\\n  elevation=NASADEM \\\n  aeronet_file=$HOME/gisdata/s2_data/name_of_aeronet_station.dubovik\n\n\n\n\n\n\nImprimir información sobre las bandas antes de importarlas\n\n# print bands info before importing\n# (1 -proj match, 0 -no proj match)\ni.sentinel.import -p input=$HOME/gisdata/s2_data\n\nImportar bandas seleccionadas, recortar y reproyectar al vuelo\n\n# import bands relevant for RGB, NDVI and NDWI\ni.sentinel.import -rc \\\n  input=$HOME/gisdata/s2_data \\\n  pattern='B(02_1|03_1|04_1|08_1|8A_2|11_2|12_2)0m' \\\n  extent=region\n\nListar bandas importadas y revisar metadatos\n\n# list raster maps\ng.list type=raster mapset=.\n\n# check metadata of some imported bands\nr.info map=T20JLL_20200330T141049_B03_10m\nr.info map=T20JLL_20200330T141049_B8A_20m\n\n\n\n\n\nAsignar grey como paleta de colores\n\n# apply grey color to RGB bands\nr.colors \\\n  map=T20JLL_20200330T141049_B04_10m,T20JLL_20200330T141049_B03_10m,T20JLL_20200330T141049_B02_10m \\\n  color=grey\n\nAjuste de colores para una composición RGB color natural\n\n# perform color auto-balancing for RGB bands\ni.colors.enhance \\\n  red=T20JLL_20200330T141049_B04_10m \\\n  green=T20JLL_20200330T141049_B03_10m \\\n  blue=T20JLL_20200330T141049_B02_10m \\\n  strength=95\n\nMostrar la combinación RGB 432\n\n# display the enhanced RGB combination\nd.mon wx0\nd.rgb -n \\\n  red=T20JLL_20200330T141049_B04_10m \\\n  green=T20JLL_20200330T141049_B03_10m \\\n  blue=T20JLL_20200330T141049_B02_10m\n\n\nTarea\nRealizar balance de colores y mostrar combinacion falso color NIR-RED-GREEN\n\n\n\n\nIdentificar y enmascarar nubes y sus sombras\n\n# identify and mask clouds and clouds shadows: i.sentinel.mask\ni.sentinel.mask -s --o \\\n  blue=T20JLL_20200330T141049_B02_10m \\\n  green=T20JLL_20200330T141049_B03_10m \\\n  red=T20JLL_20200330T141049_B04_10m \\\n  nir=T20JLL_20200330T141049_B08_10m \\\n  nir8a=T20JLL_20200330T141049_B8A_20m \\\n  swir11=T20JLL_20200330T141049_B11_20m \\\n  swir12=T20JLL_20200330T141049_B12_20m \\\n  cloud_mask=cloud \\\n  shadow_mask=shadow \\\n  scale_fac=10000 \\\n  mtd=$HOME/gisdata/s2_data/S2B_MSIL2A_20200330T141049_N0214_R110_T20JLL_20200330T182252.SAFE/GRANULE/L2A_T20JLL_A016009_20200330T141532/MTD_TL.xml\n\nVisualización de la salida: Nubes y sombras de nubes identificadas con i.sentinel.mask\n\n# display output\nd.mon wx0\nd.rgb \\\n  red=T20JLL_20200330T141049_B04_10m \\\n  green=T20JLL_20200330T141049_B03_10m \\\n  blue=T20JLL_20200330T141049_B02_10m\nd.vect map=cloud fill_color=red\nd.vect map=shadow fill_color=blue\n\n\n\n\n\nDefinir región computacional\n\n# set region\ng.region -p raster=T20JLL_20200330T141049_B08_10m\n\nEstablecer máscara\n\n# set clouds mask\nv.patch input=cloud,shadow \\\n output=cloud_shadow_mask\nr.mask -i vector=cloud_shadow_mask\n\nEstimación de los índices de vegetación\n\n# estimate vegetation indices\ni.vi \\\n  red=T20JLL_20200330T141049_B04_10m \\\n  nir=T20JLL_20200330T141049_B08_10m \\\n  output=T20JLL_20200330T141049_NDVI_10m \\\n  viname=ndvi\n\nInstalar extensión i.wi\n\n# install extension\ng.extension extension=i.wi\n\nEstimación de índice de agua\nVisualización de los resultados\n\n# estimate water indices and set color palette\ni.wi \\\n  green=T20JLL_20200330T141049_B03_10m \\\n  nir=T20JLL_20200330T141049_B08_10m \\\n  output=T20JLL_20200330T141049_NDWI_10m \\\n  winame=ndwi_mf\nr.colors map=T20JLL_20200330T141049_NDWI_10m \\\n  color=ndwi\n\n\n\n\nInstalar la extensión i.superpixels.slic\n\n# install extension\ng.extension extension=i.superpixels.slic\n\nListar los mapas y crear grupos y subgrupos\n\n# list maps\ng.list type=raster pattern=\"*20200330T141049*\" \\\n  mapset=. output=list.txt\n\n# create groups and subgroups\ni.group group=s2 subgroup=s2 file=list.txt\n\nEjecutar i.superpixels.slic\n\n# run i.superpixels.slic\ni.superpixels.slic input=s2 \\\n  output=superpixels \\\n  num_pixels=2000\n\nConvertir el resultado a vector\n\n# convert the resulting raster to vector\nr.to.vect input=superpixels \\\n  output=superpixels type=area\n\nEjecutar i.segment\n\n# run i.segment\ni.segment group=s2 output=segments \\\n  threshold=0.5 minsize=50 memory=500\n\nConvertir el resultado a vector\n\n# convert the resulting raster to vector\nr.to.vect input=segments \\\n  output=segments type=area\n\nMostrar NDVI junto con las 2 salidas de la segmentación\n\n# display NDVI along with the 2 segmentation outputs\nd.mon wx0\nd.rast map=T20JLL_20200330T141049_NDVI_10m\nd.vect map=superpixels color=yellow fill_color=none\nd.vect map=segments color=red fill_color=none\n\n\nTarea\nEjecutar cualquiera de los 2 métodos de segmentación con diferentes parámetros y comparar los resultados\n\n\n\n\nTarea\n\ndigitalizar áreas de entrenamiento para 3 clases con g.gui.iclass\nguardarlas en un mapa vectorial: training\n\n\n\n\ng.gui.iclass\n\n\nClasificación supervisada con Maximum Likelihood\nConvertir el vector de áreas de entrenamiento a raster\n\n# convert to raster\nv.to.rast input=training output=training \\\n  use=cat label_column=class\n\nGenerar archivos de firma espectral\n\n# obtain signature files\ni.gensig trainingmap=training \\\n  group=s2 subgroup=s2 \\\n  signaturefile=sig_sentinel\n\nRealizar la clasificación por Maximum Likelihood\n\n# perform ML supervised classification\ni.maxlik group=s2 subgroup=s2 \\\n  signaturefile=sig_sentinel \\\n  output=sentinel_maxlik\n\nAñadir etiquetas a las clases\n\n# label classes\nr.category sentinel_maxlik separator=\":\" rules=- &lt;&lt; EOF\n1:vegetation\n2:urban\n3:bare soil\nEOF\n\nClasificación supervisada con Maximum Likelihood\n\n\n\nInstalar la extensión r.learn.ml\n\n# install extension\ng.extension extension=r.learn.ml\n\nRealizar la clasificación por RF\n\n# perform random forest classification\nr.learn.ml trainingmap=training group=s2 \\\n  output=sentinel_rf n_estimators=300\n\nAñadir etiquetas a las clases\n\n# label classes\nr.category sentinel_rf separator=\":\" rules=- &lt;&lt; EOF\n1:vegetation\n2:urban\n3:bare soil\nEOF\n\nClasificación supervisada con Random Forest\n\nTarea\nComparar los resultados de ambos tipos de clasificación supervisada a través del índice Kappa\n\nHay un módulo r.kappa\n\n\n\n\nr.reclass.area para eliminar pequeñas áreas, enmascarar nuevos valores y rellenar los huecos con r.neighbors o r.fillnulls\nconvertir la salida en vector y ejecutar v.clean con tool=rmarea\nr.kappa para la validación (idealmente también digitalizar una muestra de prueba)"
  },
  {
    "objectID": "unidad_2/exercise_sentinel2.html#datos-sentinel-2",
    "href": "unidad_2/exercise_sentinel2.html#datos-sentinel-2",
    "title": "Ejercicio: Datos satelitales en GRASS GIS",
    "section": "",
    "text": "Sentinel 2 satellite\n\n\n\nLanzamiento: Sentinel-2A en 2015, Sentinel-2B en 2017\nTiempo de revisita: ~5 días\nCobertura sistemática de áreas terrestres y costeras entre los 84°N y 56°S\n13 bandas espectrales con resolución espacial de 10 m (VIS y NIR), 20 m (red-edge y SWIR) y 60 m (otras)\n\n\n\n\nSentinels\n\n\nESA - Satélites Copernicus Sentinel. Más información en: https://www.copernicus.eu/en/about-copernicus/infrastructure/discover-our-satellites\nDistribución de bandas de Sentinel 2 comparadas con Landsat\n\n\n\nSentinel and Landsat bands\n\n\n\n\n\ni.sentinel.download: descarga productos Copernicus Sentinel de Copernicus Open Access Hub\ni.sentinel.import: importa datos Sentinel descargados de Copernicus Open Access Hub\ni.sentinel.preproc: importa y realiza corrección atmosférica y topográfica de imágenes S2\ni.sentinel.mask: crea máscaras de nubes y sombras para imágenes S2\n\nVer Sentinel wiki para más detalles)\nRecientemente, se sumaron nuevos miembros en la familia i.sentinel:\n\ni.sentinel.coverage: comprueba la cobertura de área de las escenas de S1 o S2 seleccionadas\ni.sentinel.parallel.download: descarga imagenes Sentinel en paralelo\nPara conectarse al Copernicus Open Access Hub a través de i.sentinel.download, se necesita ser usuario registrado\nCrear el archivo SENTINEL_SETTING.txt en el directorio $HOME/gisdata/ con el siguiente contenido:\n\nyour_username\nyour_password\n\n\n\n\nL1C: Reflectancia a tope de atmósfera o Top of Atmosphere (TOA). Disponibles desde el lanzamiento.\nL2A: Reflectancia Superficial o Bottom of Atmosphere (BOA), i.e., los datos han sido corregidos para remover los efectos de la atmósfera. Sólo desde 2019.\n\n\n\n\n\nLong Term Archive (LTA)\nTodos los productos (1C o 2A) de más de un año son movidos fuera de línea y se requiere un tiempo de espera para ponerlos a disposición del usuario. Esto dificulta la automatización de tareas con productos de más de 12 meses de antigüedad.\n\nIniciar GRASS GIS, crear nuevo mapset y establecer región computacional\n\nimport os\n\n# data directory\nhomedir = os.path.expanduser('~')\n\n# GRASS GIS database variables\ngrassdata = os.path.join(homedir, \"grassdata\")\nproject = \"posgar2007_4_cba\"\nmapset = \"PERMANENT\"\n\n\nimport subprocess\nimport sys\n\n# Ask GRASS GIS where its Python packages are to be able to start it from the notebook\nsys.path.append(\n    subprocess.check_output([\"grass\", \"--config\", \"python_path\"], text=True).strip()\n)\n\n# Importar los paquetes python de GRASS\nimport grass.script as gs\nimport grass.jupyter as gj\n\n# Iniciar GRASS\nsession = gj.init(grassdata, location, mapset)\n\nCrear un nuevo mapset sentinel2\n\n# Create a new mapset\ng.mapset -c mapset=sentinel2\n\nDefinir la región computacionalal radio urbano de Córdoba\n\n# set the computational region to the extent of Cordoba urban area\ng.region -p vector=radio_urbano_cba\n\n\n\n\nInstalar la extensión i.sentinel\n\n# install i.sentinel extension\ng.extension extension=i.sentinel\n\nLista de escenas disponibles que intersectan la región computacional\n\n# explore list of scenes for a certain date range\ni.sentinel.download -l \\\n  settings=$HOME/gisdata/SENTINEL_SETTING.txt \\\n  start=\"2020-03-01\" \\\n  end=\"2020-04-30\" \\\n  producttype=S2MSI2A \\\n  clouds=30\n\nLista de escenas disponibles que contienen la región computacional\n\n# filter list of scenes by area_relation=Contains\ni.sentinel.download -l \\\n  settings=$HOME/gisdata/SENTINEL_SETTING.txt \\\n  start=\"2020-03-01\" \\\n  end=\"2020-04-30\" \\\n  producttype=S2MSI2A \\\n  clouds=30 \\\n  area_relation=Contains\n\nDescargar la escena seleccionada - NO EJECUTAR\n\n# download the scene that fully contains our region\n# i.sentinel.download \\\n#   settings=$HOME/gisdata/SENTINEL_SETTING.txt \\\n#   uuid=9a1ea49c-0561-4aa5-ba7a-dc820dc1a316 \\\n#   output=$HOME/gisdata/s2_data\n\nComo la descarga desde el Copernicus Open Access Hub toma su tiempo, vamos a descargar la escena Sentinel 2 que usaremos y moverla a HOME/gisdata/s2_data\nHagamos una prueba con datos del LTA…\n\ni.sentinel.download -l \\\n  settings=$HOME/gisdata/SENTINEL_SETTING.txt \\\n  start=\"2019-01-01\" \\\n  end=\"2020-02-28\" \\\n  clouds=30\n\ni.sentinel.download \\\n  settings=$HOME/gisdata/SENTINEL_SETTING.txt \\\n  uuid=d4e5df0e-7ead-4407-ba82-d2583be1a6b8 \\\n  output=$HOME/gisdata/s2_data\n\n\n\n\n\n\n\n\n\n\n\nPara obtener un valor de AOD, tenemos 2 opciones:\nA. Estimar el valor desde un grafico\n\nB. Descargar un archivo y el valor sera estimado \nhttp://aeronet.gsfc.nasa.gov\nObtener AOD de  http://aeronet.gsfc.nasa.gov\n\n\nEstación ARM_Cordoba o Pilar_Cordoba\nSeleccionar fechas de inicio y final\nSeleccionar: Combined file y All points\nDescargar y descomprimir (el archivo final tiene extensión .dubovik)\nPasar el archivo con la opción aeronet_file\n\nMapa de elevación\n\nr.in.srtm.region: importa (y re-proyecta) los mosaicos SRTM que cubren la región computacional, parchea los mosaicos e interpola datos faltantes\nr.in.nasadem: importa (y re-proyecta) los mosaicos de NASADEM que cubren la región computacional y parchea los mosaicos\n\n\nSi el DEM es más chico que la región computacional, sólo la región cubierta por el DEM será corregida atmosféricamente…\n\nEjemplo\n# enter directory with Sentinel scene and unzip file\ncd $HOME/gisdata/s2_data/\nunzip $HOME/gisdata/s2_data/name_of_S2_scene\n\ni.sentinel.preproc -atr \\\n  input_dir=$HOME/gisdata/s2_data/name_of_S2_scene.SAFE \\\n  elevation=NASADEM \\\n  aeronet_file=$HOME/gisdata/s2_data/name_of_aeronet_station.dubovik\n\n\n\n\n\n\nImprimir información sobre las bandas antes de importarlas\n\n# print bands info before importing\n# (1 -proj match, 0 -no proj match)\ni.sentinel.import -p input=$HOME/gisdata/s2_data\n\nImportar bandas seleccionadas, recortar y reproyectar al vuelo\n\n# import bands relevant for RGB, NDVI and NDWI\ni.sentinel.import -rc \\\n  input=$HOME/gisdata/s2_data \\\n  pattern='B(02_1|03_1|04_1|08_1|8A_2|11_2|12_2)0m' \\\n  extent=region\n\nListar bandas importadas y revisar metadatos\n\n# list raster maps\ng.list type=raster mapset=.\n\n# check metadata of some imported bands\nr.info map=T20JLL_20200330T141049_B03_10m\nr.info map=T20JLL_20200330T141049_B8A_20m\n\n\n\n\n\nAsignar grey como paleta de colores\n\n# apply grey color to RGB bands\nr.colors \\\n  map=T20JLL_20200330T141049_B04_10m,T20JLL_20200330T141049_B03_10m,T20JLL_20200330T141049_B02_10m \\\n  color=grey\n\nAjuste de colores para una composición RGB color natural\n\n# perform color auto-balancing for RGB bands\ni.colors.enhance \\\n  red=T20JLL_20200330T141049_B04_10m \\\n  green=T20JLL_20200330T141049_B03_10m \\\n  blue=T20JLL_20200330T141049_B02_10m \\\n  strength=95\n\nMostrar la combinación RGB 432\n\n# display the enhanced RGB combination\nd.mon wx0\nd.rgb -n \\\n  red=T20JLL_20200330T141049_B04_10m \\\n  green=T20JLL_20200330T141049_B03_10m \\\n  blue=T20JLL_20200330T141049_B02_10m\n\n\nTarea\nRealizar balance de colores y mostrar combinacion falso color NIR-RED-GREEN\n\n\n\n\nIdentificar y enmascarar nubes y sus sombras\n\n# identify and mask clouds and clouds shadows: i.sentinel.mask\ni.sentinel.mask -s --o \\\n  blue=T20JLL_20200330T141049_B02_10m \\\n  green=T20JLL_20200330T141049_B03_10m \\\n  red=T20JLL_20200330T141049_B04_10m \\\n  nir=T20JLL_20200330T141049_B08_10m \\\n  nir8a=T20JLL_20200330T141049_B8A_20m \\\n  swir11=T20JLL_20200330T141049_B11_20m \\\n  swir12=T20JLL_20200330T141049_B12_20m \\\n  cloud_mask=cloud \\\n  shadow_mask=shadow \\\n  scale_fac=10000 \\\n  mtd=$HOME/gisdata/s2_data/S2B_MSIL2A_20200330T141049_N0214_R110_T20JLL_20200330T182252.SAFE/GRANULE/L2A_T20JLL_A016009_20200330T141532/MTD_TL.xml\n\nVisualización de la salida: Nubes y sombras de nubes identificadas con i.sentinel.mask\n\n# display output\nd.mon wx0\nd.rgb \\\n  red=T20JLL_20200330T141049_B04_10m \\\n  green=T20JLL_20200330T141049_B03_10m \\\n  blue=T20JLL_20200330T141049_B02_10m\nd.vect map=cloud fill_color=red\nd.vect map=shadow fill_color=blue\n\n\n\n\n\nDefinir región computacional\n\n# set region\ng.region -p raster=T20JLL_20200330T141049_B08_10m\n\nEstablecer máscara\n\n# set clouds mask\nv.patch input=cloud,shadow \\\n output=cloud_shadow_mask\nr.mask -i vector=cloud_shadow_mask\n\nEstimación de los índices de vegetación\n\n# estimate vegetation indices\ni.vi \\\n  red=T20JLL_20200330T141049_B04_10m \\\n  nir=T20JLL_20200330T141049_B08_10m \\\n  output=T20JLL_20200330T141049_NDVI_10m \\\n  viname=ndvi\n\nInstalar extensión i.wi\n\n# install extension\ng.extension extension=i.wi\n\nEstimación de índice de agua\nVisualización de los resultados\n\n# estimate water indices and set color palette\ni.wi \\\n  green=T20JLL_20200330T141049_B03_10m \\\n  nir=T20JLL_20200330T141049_B08_10m \\\n  output=T20JLL_20200330T141049_NDWI_10m \\\n  winame=ndwi_mf\nr.colors map=T20JLL_20200330T141049_NDWI_10m \\\n  color=ndwi\n\n\n\n\nInstalar la extensión i.superpixels.slic\n\n# install extension\ng.extension extension=i.superpixels.slic\n\nListar los mapas y crear grupos y subgrupos\n\n# list maps\ng.list type=raster pattern=\"*20200330T141049*\" \\\n  mapset=. output=list.txt\n\n# create groups and subgroups\ni.group group=s2 subgroup=s2 file=list.txt\n\nEjecutar i.superpixels.slic\n\n# run i.superpixels.slic\ni.superpixels.slic input=s2 \\\n  output=superpixels \\\n  num_pixels=2000\n\nConvertir el resultado a vector\n\n# convert the resulting raster to vector\nr.to.vect input=superpixels \\\n  output=superpixels type=area\n\nEjecutar i.segment\n\n# run i.segment\ni.segment group=s2 output=segments \\\n  threshold=0.5 minsize=50 memory=500\n\nConvertir el resultado a vector\n\n# convert the resulting raster to vector\nr.to.vect input=segments \\\n  output=segments type=area\n\nMostrar NDVI junto con las 2 salidas de la segmentación\n\n# display NDVI along with the 2 segmentation outputs\nd.mon wx0\nd.rast map=T20JLL_20200330T141049_NDVI_10m\nd.vect map=superpixels color=yellow fill_color=none\nd.vect map=segments color=red fill_color=none\n\n\nTarea\nEjecutar cualquiera de los 2 métodos de segmentación con diferentes parámetros y comparar los resultados\n\n\n\n\nTarea\n\ndigitalizar áreas de entrenamiento para 3 clases con g.gui.iclass\nguardarlas en un mapa vectorial: training\n\n\n\n\ng.gui.iclass\n\n\nClasificación supervisada con Maximum Likelihood\nConvertir el vector de áreas de entrenamiento a raster\n\n# convert to raster\nv.to.rast input=training output=training \\\n  use=cat label_column=class\n\nGenerar archivos de firma espectral\n\n# obtain signature files\ni.gensig trainingmap=training \\\n  group=s2 subgroup=s2 \\\n  signaturefile=sig_sentinel\n\nRealizar la clasificación por Maximum Likelihood\n\n# perform ML supervised classification\ni.maxlik group=s2 subgroup=s2 \\\n  signaturefile=sig_sentinel \\\n  output=sentinel_maxlik\n\nAñadir etiquetas a las clases\n\n# label classes\nr.category sentinel_maxlik separator=\":\" rules=- &lt;&lt; EOF\n1:vegetation\n2:urban\n3:bare soil\nEOF\n\nClasificación supervisada con Maximum Likelihood\n\n\n\nInstalar la extensión r.learn.ml\n\n# install extension\ng.extension extension=r.learn.ml\n\nRealizar la clasificación por RF\n\n# perform random forest classification\nr.learn.ml trainingmap=training group=s2 \\\n  output=sentinel_rf n_estimators=300\n\nAñadir etiquetas a las clases\n\n# label classes\nr.category sentinel_rf separator=\":\" rules=- &lt;&lt; EOF\n1:vegetation\n2:urban\n3:bare soil\nEOF\n\nClasificación supervisada con Random Forest\n\nTarea\nComparar los resultados de ambos tipos de clasificación supervisada a través del índice Kappa\n\nHay un módulo r.kappa\n\n\n\n\nr.reclass.area para eliminar pequeñas áreas, enmascarar nuevos valores y rellenar los huecos con r.neighbors o r.fillnulls\nconvertir la salida en vector y ejecutar v.clean con tool=rmarea\nr.kappa para la validación (idealmente también digitalizar una muestra de prueba)"
  },
  {
    "objectID": "unidad_2/imagery_data_in_grass.html#manos-a-la-obra",
    "href": "unidad_2/imagery_data_in_grass.html#manos-a-la-obra",
    "title": "Datos satelitales en GRASS GIS",
    "section": "",
    "text": "Iniciamos GRASS GIS en posgar2007_4_cba/PERMANENT\n\nimport os\n\n# data directory\nhomedir = os.path.expanduser('~')\n\n# GRASS GIS database variables\ngrassdata = os.path.join(homedir, \"grassdata\")\nproject = \"posgar2007_4_cba\"\nmapset = \"PERMANENT\"\n\n\n# import standard Python packages we need\nimport sys\nimport subprocess\n\n# ask GRASS GIS where its Python packages are to be able to run it from the notebook\nsys.path.append(\n    subprocess.check_output([\"grass\", \"--config\", \"python_path\"], text=True).strip()\n)\n\nAhora sí, estamos listos para importar los paquetes de GRASS e iniciar una sesión:\n\n# import the GRASS GIS packages we need\nimport grass.script as gs\nimport grass.jupyter as gj\n\n# Start the GRASS GIS Session\nsession = gj.init(grassdata, project, mapset)\n\nCorroboramos la proyección\n\n# check the CRS\ngs.read_command(\"g.proj\", flags=\"p\")\n\nCreamos un nuevo mapset llamado landsat8:\n\n# Create a new mapset\ng.mapset -c mapset=landsat8\n\nListamos los mapsets accesibles\n\n# list all the mapsets in the search path\ng.mapsets -p\n\nListamos los mapas vectoriales disponibles\n\n# list vector maps in all mapsets in the search path\ng.list type=vector\n\nExtraemos el radio urbano de Córdoba\n\n# extract Cordoba urban area from `radios_urbanos`\nv.extract input=radios_urbanos \\\n  where=\"nombre == 'CORDOBA'\" \\\n  output=radio_urbano_cba\n\nEstablecemos la región computacional al radio urbano de Córdoba\n\n# set the computational region to the extent of Cordoba urban area\ng.region -p vector=radio_urbano_cba\n\n\n\n\nInstalar la extensión i.landsat:\n\n# install i.landsat toolset\ng.extension extension=i.landsat\n\nBuscar escenas de Landsat 8 disponibles\n\n# search for Landsat 8 scenes\ni.landsat.download -l settings=$HOME/gisdata/USGS_SETTING.txt \\\n  dataset=landsat_8_c1 clouds=35 \\\n  start='2019-10-27' end='2020-03-15'\n\nNO EJECUTAR! Descargar las escenas seleccionadas\n\n# download selected scenes\n# i.landsat.download settings=$HOME/gisdata/USGS_SETTING.txt \\\n#   id=LC82290822020062LGN00,LC82290822020014LGN00 \\\n#   output=$HOME/gisdata/landsat_data\n\nImprimir las bandas dentro de la carpeta\n\n# print all landsat bands within landsat_data folder\ni.landsat.import -p input=$HOME/gisdata/landsat_data\n\nImprimir sólo las bandas seleccionadas con un patrón\n\n# print a selection of bands - might be sloooow\ni.landsat.import -p \\\n  input=$HOME/gisdata/landsat_data \\\n  pattern='B(2|3|4|5|6|8)'\n\nImportar bandas, recortar y reproyectar al vuelo\n\n# import all bands, subset to region and reproject\ni.landsat.import -r \\\n  input=$HOME/gisdata/landsat_data \\\n  extent=region\n\nListar bandas importadas y revisar metadatos\n\n# list raster maps\ng.list type=raster mapset=.\n\n# check metadata of some imported bands\nr.info map=LC08_L1TP_229082_20200114_20200127_01_T1_B4\nr.info map=LC08_L1TP_229082_20200114_20200127_01_T1_B8\n\n\n\n\nSelect directoryImport settings\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWorkflow de pre-procesamiento de datos satelitales\n\n\n\n\n\n\nLos datos L8 OLI vienen en 16-bit con rango de datos entre 0 y 65535.\ni.landsat.toar convierte ND en reflectancia TOA (y temperatura de brillo) para todos los sensores Landsat. Opcionalmente proporciona reflectancia de superficie (BOA) después de la corrección DOS.\ni.atcorr proporciona un método de corrección atmosférica más complejo para gran variedad de sensores (S6).\n\nDefinir region computacional a banda de 30m\n\n# set the region to a 30m band\ng.region -p raster=LC08_L1TP_229082_20200114_20200127_01_T1_B4\n\nConvertir DN a reflectancia superficial y temperatura - método DOS\n\n# convert from DN to surface reflectance and temperature - requires to uncompress data locally\ni.landsat.toar \\\n  input=LC08_L1TP_229082_20200114_20200127_01_T1_B \\\n  output=LC08_229082_20200114_toar_B \\\n  sensor=oli8 \\\n  metfile=$HOME/gisdata/landsat_data/LC08_L1TP_229082_20200114_20200127_01_T1_MTL.txt \\\n  method=dos1\n\nCorroborar info antes y después de la conversión para una banda\n\n# list output maps\ng.list type=raster mapset=. pattern=\"*toar*\"\n\n# check info before and after for one band\nr.info map=LC08_L1TP_229082_20200114_20200127_01_T1_B3\nr.info map=LC08_229082_20200114_toar_B3\n\n\nBanda 10 de L8 con la paleta de colores kelvin\n\nTarea:\nAhora, sigan los mismos pasos para la escena del 02/03/2020. Qué notan de diferente?\n\n\n\n\nAjuste de colores para una composición RGB color natural\n\n# enhance the colors\ni.colors.enhance \\\n  red=LC08_229082_20200114_toar_B4 \\\n  green=LC08_229082_20200114_toar_B3 \\\n  blue=LC08_229082_20200114_toar_B2 \\\n  strength=95\n\nMostrar la combinación RGB - d.rgb\n\n# display RGB\nd.mon wx0\nd.rgb \\\n  red=LC08_229082_20200114_toar_B4 \\\n  green=LC08_229082_20200114_toar_B3 \\\n  blue=LC08_229082_20200114_toar_B2\n\n\nTarea:\nSeguir los mismos pasos para una composición falso color 543. Sobre qué bandas debieran realizar el ajuste?\n\n \nComposiciones color natural 432 y falso color 543\n\n\n\n\nLandsat 8 proporciona una banda de calidad (QA) con valores enteros de 16 bits que representan las combinaciones de superficie, atmósfera y condiciones del sensor que pueden afectar la utilidad general de un determinado pixel.\nLa extensión i.landsat.qa reclasifica la banda QA de Landsat 8 de acuerdo a la calidad del pixel.\n\nMás información sobre la banda QA de L8:https://www.usgs.gov/core-science-systems/nli/landsat\nCrear las reglas para identificar las nubes y sombras de nubes\n\n# create a rule set\ni.landsat.qa \\\n  collection=1 \\\n  cloud_shadow_confidence=\"Medium,High\" \\\n  cloud_confidence=\"Medium,High\" \\\n  output=Cloud_Mask_rules.txt\n\nReclasificar la banda QA en función de las reglas\n\n# reclass the BQA band based on the rule set created\nr.reclass \\\n  input=LC08_L1TP_229082_20200114_20200127_01_T1_BQA \\\n  output=LC08_229082_20200114_Cloud_Mask \\\n  rules=Cloud_Mask_rules.txt\n\nReporte del porcentaje de nubes y sombras\n\n# report % of clouds and shadows\nr.report -e map=LC08_229082_20200114_Cloud_Mask units=p\n\nMostrar el mapa reclasificado\n\n# display reclassified map over RGB\nd.mon wx0\nd.rgb \\\n  red=LC08_229082_20200114_toar_B4 \\\n  green=LC08_229082_20200114_toar_B3 \\\n  blue=LC08_229082_20200114_toar_B2\nd.rast LC08_229082_20200114_Cloud_Mask\n\n\nTarea:\nComparar visualmente la cobertura de nubes con la composición RGB 543.\n\n \nComposición falso color y máscara de nubes\n\n\n\nVamos a usar la banda PAN (15 m) para mejorar la definición de las bandas espectrales de 30 m, por medio de:\n\ni.fusion.hpf, que aplica un método de adición basado en un filtro de paso alto\n\nOtros métodos están implementados en i.pansharpen\nInstalar la extensión i.fusion.hpf\n\n# Install the reqquired addon\ng.extension extension=i.fusion.hpf\n\nCambiar la región a la banda PAN\n\n# Set the region to PAN band (15m)\ng.region -p raster=LC08_229082_20200114_toar_B8\n\nEjecutar la fusión\n\n# Apply the fusion based on high pass filter\ni.fusion.hpf -l -c pan=LC08_229082_20200114_toar_B8 \\\n  msx=`g.list type=raster mapset=. pattern=*_toar_B[1-7] separator=,` \\\n  suffix=_hpf \\\n  center=high \\\n  modulation=max \\\n  trim=0.0\n\nListar los mapas resultantes usando un patrón de búsqueda\n\n# list the fused maps\ng.list type=raster mapset=. pattern=*_hpf\n\nVisualizar las diferencias con la herramienta mapswipe\n\n# display original and fused maps\ng.gui.mapswipe \\\n  first=LC08_229082_20200114_toar_B5 \\\n  second=LC08_229082_20200114_toar_B5_hpf\n\n\nDatos originales 30 m y datos fusionados 15 m\n\n\n\nEstablecer la máscara de nubes para evitar el cómputo sobre las nubes\n\n# Set the cloud mask to avoid computing over clouds\nr.mask raster=LC08_229082_20200114_Cloud_Mask\n\nCalcular el NDVI y establecer la paleta de colores\n\n# Compute NDVI\nr.mapcalc \\\n  expression=\"LC08_229082_20200114_NDVI = \\\n  (LC08_229082_20200114_toar_B5_hpf - LC08_229082_20200114_toar_B4_hpf) / \\\n  (LC08_229082_20200114_toar_B5_hpf + LC08_229082_20200114_toar_B4_hpf) * 1.0\"\n# Set the color palette\nr.colors map=LC08_229082_20200114_NDVI color=ndvi\n\nCalcular NDWI y establecer la paleta de colores\n\n# Compute NDWI\nr.mapcalc expression=\"LC08_229082_20200114_NDWI = \\\n  (LC08_229082_20200114_toar_B5_hpf - LC08_229082_20200114_toar_B6_hpf) / \\\n  (LC08_229082_20200114_toar_B5_hpf + LC08_229082_20200114_toar_B6_hpf) * 1.0\"\n# Set the color palette\nr.colors map=LC08_229082_20200114_NDWI color=ndwi\n\nMostrar los mapas\n\n# display maps in different monitors\nd.mon wx0\nd.rast map=LC08_229082_20200114_NDVI\n\nd.mon wx1\nd.rast map=LC08_229082_20200114_NDWI\n\n \nNDVI y NDWI a partir de datos Landsat 8\n\nTarea:\nEstimar NDVI y NDWI para la otra escena usando el módulo i.vi\n\n\n\n\n\nAgrupar las bandas (i.e., hacer un stack): i.group\nGenerar firmas para n número de clases: i.cluster\nClasificar: i.maxlik\n\nListar los mapas usando un patrón\n\n# list the bands needed for classification\ng.list type=raster mapset=. pattern=*_toar*_hpf\n\nCrear un grupo de imágenes o stack\n\n# add maps to an imagery group for easier management\ni.group group=l8 subgroup=l8 \\\n input=`g.list type=raster mapset=. pattern=*_toar*_hpf sep=\",\"`\n\nObtener estadísticos -firmas- para las n clases de interés con una muestra de pixeles\n\n# statistics for unsupervised classification\ni.cluster group=l8 subgroup=l8 \\\n sig=l8_hpf \\\n classes=7 \\\n separation=0.6\n\nRealizar la clasificación no supervisada de toda la imagen\n\n# Maximum Likelihood unsupervised classification\ni.maxlik group=l8 subgroup=l8 \\\n sig=l8_hpf \\\n output=l8_hpf_class \\\n rej=l8_hpf_rej\n\nMostrar el mapa clasificado\n\n# display results\nd.mon wx0\nd.rast map=l8_hpf_class\n\n\nInformación derivada adicional podría obtenerse con los siguientes módulos, entre otros:\n\nmedidas de textura: r.texture,\nmedidas de diversidad: r.diversity,\nestadísticas locales con información de contexto: r.neighbors,\ntransformación tasseled cap: i.tasscap,\netc.\n\n\n\n\n\nTopic classification en los manuales de GRASS GIS\nImage classification en la wiki\nEjemplos de clasificación en el curso dictado en Noruega en 2018\nClasificación con Random Forest en la presentación del OpenGeoHub Summer School 2018 en Praga\nDetección de cambios con Landsat"
  },
  {
    "objectID": "unidad_2/imagery_data_in_grass.html#iniciamos-grass-gis",
    "href": "unidad_2/imagery_data_in_grass.html#iniciamos-grass-gis",
    "title": "Datos satelitales en GRASS GIS",
    "section": "Iniciamos GRASS GIS",
    "text": "Iniciamos GRASS GIS\nIniciamos GRASS GIS en posgar2007_4_cba/PERMANENT\n\nimport os\n\n# data directory\nhomedir = os.path.expanduser('~')\n\n# GRASS GIS database variables\ngrassdata = os.path.join(homedir, \"grassdata\")\nproject = \"posgar2007_4_cba\"\nmapset = \"PERMANENT\"\n\n\n# import standard Python packages we need\nimport sys\nimport subprocess\n\n# ask GRASS GIS where its Python packages are to be able to run it from the notebook\nsys.path.append(\n    subprocess.check_output([\"grass\", \"--config\", \"python_path\"], text=True).strip()\n)\n\nAhora sí, estamos listos para importar los paquetes de GRASS e iniciar una sesión:\n\n# import the GRASS GIS packages we need\nimport grass.script as gs\nimport grass.jupyter as gj\n\n# Start the GRASS GIS Session\nsession = gj.init(grassdata, project, mapset)\n\nCorroboramos la proyección\n\n# check the CRS\ngs.read_command(\"g.proj\", flags=\"p\")"
  },
  {
    "objectID": "unidad_2/imagery_data_in_grass.html#crear-un-nuevo-mapset",
    "href": "unidad_2/imagery_data_in_grass.html#crear-un-nuevo-mapset",
    "title": "Datos satelitales en GRASS GIS",
    "section": "Crear un nuevo mapset",
    "text": "Crear un nuevo mapset\nCreamos un nuevo mapset llamado landsat8:\n\n# Create a new mapset\ngs.create_environment(grassdata, project, mapset=\"landsat8\")\n\nListamos los mapsets accesibles\n\n# list all the mapsets in the search path\ngs.mapsets()\n\nListamos los mapas vectoriales disponibles\n\n# list vector maps in all mapsets in the search path\ngs.list_grouped(type=\"vector\")"
  },
  {
    "objectID": "unidad_2/imagery_data_in_grass.html#región-de-interés",
    "href": "unidad_2/imagery_data_in_grass.html#región-de-interés",
    "title": "Datos satelitales en GRASS GIS",
    "section": "Región de interés",
    "text": "Región de interés\nExtraemos el radio urbano de Córdoba\n\n# extract Cordoba urban area from `radios_urbanos`\ngs.run_command(\"v.extract\", input=\"radios_urbanos\", where=\"nombre == 'CORDOBA'\", output=\"radio_urbano_cba\")\n\nEstablecemos la región computacional al radio urbano de Córdoba\n\n# set the computational region to the extent of Cordoba urban area\ngs.run_command(\"g.region\", flags=\"p\", vector=\"radio_urbano_cba\")"
  },
  {
    "objectID": "unidad_2/imagery_data_in_grass.html#descargar-e-importar-los-datos-l8",
    "href": "unidad_2/imagery_data_in_grass.html#descargar-e-importar-los-datos-l8",
    "title": "Datos satelitales en GRASS GIS",
    "section": "Descargar e importar los datos L8",
    "text": "Descargar e importar los datos L8\nInstalar la extensión i.landsat:\n\n# install i.landsat toolset\ng.extension extension=i.landsat\n\nBuscar escenas de Landsat 8 disponibles\n\n# search for Landsat 8 scenes\ni.landsat.download -l settings=$HOME/gisdata/USGS_SETTING.txt \\\n  dataset=landsat_8_c1 clouds=35 \\\n  start='2019-10-27' end='2020-03-15'\n\nNO EJECUTAR! Descargar las escenas seleccionadas\n\n# download selected scenes\n# i.landsat.download settings=$HOME/gisdata/USGS_SETTING.txt \\\n#   id=LC82290822020062LGN00,LC82290822020014LGN00 \\\n#   output=$HOME/gisdata/landsat_data\n\nImprimir las bandas dentro de la carpeta\n\n# print all landsat bands within landsat_data folder\ngs.run_command(i.landsat.import -p input=$HOME/gisdata/landsat_data)\n\nImprimir sólo las bandas seleccionadas con un patrón\n\n# print a selection of bands - might be sloooow\ngs.run_command(i.landsat.import -p input=$HOME/gisdata/landsat_data pattern='B(2|3|4|5|6|8)')\n\nImportar bandas, recortar y reproyectar al vuelo\n\n# import all bands, subset to region and reproject\ngs.run_command(i.landsat.import -r input=$HOME/gisdata/landsat_data extent=region)\n\nListar bandas importadas y revisar metadatos\n\n# list raster maps\ngs.list_grouped(type=raster)[\"landsat8\"]\n\n\n# check metadata of some imported bands\ngs.raster_info(map=LC08_L1TP_229082_20200114_20200127_01_T1_B4)\ngs.raster_info(map=LC08_L1TP_229082_20200114_20200127_01_T1_B8)"
  },
  {
    "objectID": "unidad_2/imagery_data_in_grass.html#pre-procesamiento-de-datos-satelitales",
    "href": "unidad_2/imagery_data_in_grass.html#pre-procesamiento-de-datos-satelitales",
    "title": "Datos satelitales en GRASS GIS",
    "section": "Pre-procesamiento de datos satelitales",
    "text": "Pre-procesamiento de datos satelitales\n\n\n\nWorkflow de pre-procesamiento de datos satelitales\n\n\n\nDe número digital (ND) a reflectancia y temperatura\n\nLos datos L8 OLI vienen en 16-bit con rango de datos entre 0 y 65535.\ni.landsat.toar convierte ND en reflectancia TOA (y temperatura de brillo) para todos los sensores Landsat. Opcionalmente proporciona reflectancia de superficie (BOA) después de la corrección DOS.\ni.atcorr proporciona un método de corrección atmosférica más complejo para gran variedad de sensores (S6).\n\nDefinir region computacional a banda de 30m\n\n# set the region to a 30m band\ngs.run_command(\"g.region\", raster=\"LC08_L1TP_229082_20200114_20200127_01_T1_B4\", flags=\"p\")\n\nConvertir DN a reflectancia superficial y temperatura - método DOS\n\n# convert from DN to surface reflectance and temperature - requires to uncompress data locally\ngs.run_command(i.landsat.toar input=\"LC08_L1TP_229082_20200114_20200127_01_T1_B\"   output=\"LC08_229082_20200114_toar_B\" sensor=\"oli8\" metfile=\"$HOME/gisdata/landsat_data/LC08_L1TP_229082_20200114_20200127_01_T1_MTL.txt\"\nmethod=\"dos1\")\n\nCorroborar info antes y después de la conversión para una banda\n\n# list output maps\ng.list type=raster mapset=. pattern=\"*toar*\"\n\n\n# check info before and after for one band\nr.info map=LC08_L1TP_229082_20200114_20200127_01_T1_B3\nr.info map=LC08_229082_20200114_toar_B3\n\n\n\n\nBanda 10 de L8 con la paleta de colores kelvin\n\n\n\nAhora, sigan los mismos pasos para la escena del 02/03/2020. ¿Qué notan de diferente?\n\n\n\nAjuste de color y composiciones RGB\nAjuste de colores para una composición RGB color natural\n\n# enhance the colors\ngs.run_command(i.colors.enhance red=LC08_229082_20200114_toar_B4   green=LC08_229082_20200114_toar_B3 blue=LC08_229082_20200114_toar_B2 strength=95)\n\nMostrar la combinación RGB\n\n# display RGB\nrgb = gj.\n\n\nSeguir los mismos pasos para una composición falso color 543. Sobre qué bandas debieran realizar el ajuste?\n\n\n\n\n\n\nComposición color natural 432\n\n\n\n\n\n\nComposición falso color 543\n\n\n\n\n\n\nEnmascarado de nubes con banda QA\n\nLandsat 8 proporciona una banda de calidad (quality assessment, QA) con valores enteros de 16 bits que representan las combinaciones de superficie, atmósfera y condiciones del sensor que pueden afectar la utilidad general de un determinado pixel.\nLa extensión i.landsat.qa reclasifica la banda QA de Landsat 8 de acuerdo a la calidad del pixel.\n\n\n\n\n\n\n\nNota\n\n\n\nMás información sobre la banda QA de L8 en la guía de usuario.\n\n\nCrear las reglas para identificar las nubes y sombras de nubes\n\n# create a rule set\ngs.run_command(i.landsat.qa collection=1 cloud_shadow_confidence=\"Medium,High\"   cloud_confidence=\"Medium,High\" output=Cloud_Mask_rules.txt)\n\nReclasificar la banda QA en función de las reglas\n\n# reclass the BQA band based on the rule set created\ngs.run_command(r.reclass input=LC08_L1TP_229082_20200114_20200127_01_T1_BQA\n  output=LC08_229082_20200114_Cloud_Mask rules=Cloud_Mask_rules.txt)\n\nReporte del porcentaje de nubes y sombras\n\n# report % of clouds and shadows\nprint(gs.read_command(r.report -e map=LC08_229082_20200114_Cloud_Mask units=p))\n\nMostrar el mapa reclasificado\n\n# display reclassified map over RGB\nd.mon wx0\nd.rgb \\\n  red=LC08_229082_20200114_toar_B4 \\\n  green=LC08_229082_20200114_toar_B3 \\\n  blue=LC08_229082_20200114_toar_B2\nd.rast LC08_229082_20200114_Cloud_Mask\n\n\nComparar visualmente la cobertura de nubes con la composición RGB 543.\n\n\n\n\n\n\nComposición falso color\n\n\n\n\n\n\nMáscara de nubes\n\n\n\n\n\n\nFusión de datos/Pansharpening\nVamos a usar la banda PAN (15 m) para mejorar la definición de las bandas espectrales de 30 m, por medio de: i.fusion.hpf, que aplica un método de adición basado en un filtro de paso alto. Otros métodos están implementados en i.pansharpen.\nInstalar la extensión i.fusion.hpf\n\n# Install the reqquired addon\ngs.run_command(g.extension extension=i.fusion.hpf)\n\nCambiar la región a la banda PAN\n\n# Set the region to PAN band (15m)\ngs.run_command(g.region -p raster=LC08_229082_20200114_toar_B8)\n\nEjecutar la fusión\n\n# Apply the fusion based on high pass filter\ngs.run_command(i.fusion.hpf -l -c pan=LC08_229082_20200114_toar_B8, msx=`g.list type=raster mapset=. pattern=*_toar_B[1-7] separator=,`, suffix=_hpf, center=high, modulation=max, trim=0.0)\n\nListar los mapas resultantes usando un patrón de búsqueda\n\n# list the fused maps\ngs.list_grouped(type=raster, pattern=*_hpf)[\"landsat8\"]\n\nVisualizar las diferencias\n\n\n\nDatos originales 30 m y datos fusionados 15 m\n\n\n\n# display original and fused maps\n\n\n\nÍndices de agua y vegetación\nEstablecer la máscara de nubes para evitar el cómputo sobre las nubes\n\n# Set the cloud mask to avoid computing over clouds\ngs.run_command(r.mask raster=LC08_229082_20200114_Cloud_Mask)\n\nCalcular el NDVI y establecer la paleta de colores\n\n# Compute NDVI\nr.mapcalc \\\n  expression=\"LC08_229082_20200114_NDVI = \\\n  (LC08_229082_20200114_toar_B5_hpf - LC08_229082_20200114_toar_B4_hpf) / \\\n  (LC08_229082_20200114_toar_B5_hpf + LC08_229082_20200114_toar_B4_hpf) * 1.0\"\n# Set the color palette\nr.colors map=LC08_229082_20200114_NDVI color=ndvi\n\nCalcular NDWI y establecer la paleta de colores\n\n# Compute NDWI\nr.mapcalc expression=\"LC08_229082_20200114_NDWI = \\\n  (LC08_229082_20200114_toar_B5_hpf - LC08_229082_20200114_toar_B6_hpf) / \\\n  (LC08_229082_20200114_toar_B5_hpf + LC08_229082_20200114_toar_B6_hpf) * 1.0\"\n# Set the color palette\nr.colors map=LC08_229082_20200114_NDWI color=ndwi\n\nMostrar los mapas\n\nndi = gj.InteractiveMap()\nndi.add_raster()\nndi.show()\n\n\n\n\n\n\nNDVI y NDWI a partir de datos Landsat 8\n\n\n\n\n\n\n\nTarea\n\n\n\nEstimar NDVI y NDWI para la otra escena usando el módulo i.vi\n\n\n\n\nClasificación No Supervisada\n\nAgrupar las bandas (i.e., hacer un stack): i.group\nGenerar firmas para n número de clases: i.cluster\nClasificar: i.maxlik\n\nListar los mapas usando un patrón\n\n# list the bands needed for classification\ng.list type=raster mapset=. pattern=*_toar*_hpf\n\nCrear un grupo de imágenes o stack\n\n# add maps to an imagery group for easier management\ni.group group=l8 subgroup=l8 \\\n input=`g.list type=raster mapset=. pattern=*_toar*_hpf sep=\",\"`\n\nObtener estadísticos -firmas- para las n clases de interés con una muestra de pixeles\n\n# statistics for unsupervised classification\ni.cluster group=l8 subgroup=l8 \\\n sig=l8_hpf \\\n classes=7 \\\n separation=0.6\n\nRealizar la clasificación no supervisada de toda la imagen\n\n# Maximum Likelihood unsupervised classification\ni.maxlik group=l8 subgroup=l8 \\\n sig=l8_hpf \\\n output=l8_hpf_class \\\n rej=l8_hpf_rej\n\nMostrar el mapa clasificado\n\n\n\nInformación derivada adicional\nInformación derivada adicional podría obtenerse con los siguientes módulos, entre otros:\n\nmedidas de textura: r.texture,\nmedidas de diversidad: r.diversity,\nestadísticas locales con información de contexto: r.neighbors,\ntransformación tasseled cap: i.tasscap,\netc.\n\n\n\nClasificación en GRASS GIS\n\nTopic classification en los manuales de GRASS GIS\nImage classification en la wiki\nEjemplos de clasificación en el curso dictado en Noruega en 2018\nClasificación con Random Forest en la presentación del OpenGeoHub Summer School 2018 en Praga\nDetección de cambios con Landsat"
  },
  {
    "objectID": "unidad_2/imagery_data_in_grass.html#semantic-labels",
    "href": "unidad_2/imagery_data_in_grass.html#semantic-labels",
    "title": "Datos satelitales en GRASS GIS",
    "section": "Semantic labels",
    "text": "Semantic labels\nUn concepto bastante nuevo en GRASS GIS son las etiquetas semánticas o semantic labels. Éstas son especialmente relevantes para las imágenes de satélite, ya que nos permiten identificar a qué sensor y banda corresponde una trama determinada. Estas etiquetas son especialmente relevantes a la hora de trabajar con colecciones de imágenes de satélite y también a la hora de clasificar diferentes escenas. Lo veremos más adelante, pero al generar una firma espectral para un determinado conjunto de bandas, puede reutilizarse para clasificar otra escena siempre que las etiquetas semánticas sean las mismas. Cuidado: aunque es posible reutilizar las firmas espectrales para cualquier escena con las mismas bandas, los cambios temporales (estaciones, impacto meteorológico) limitan su aplicabilidad sólo a escenas obtenidas más o menos al mismo tiempo."
  },
  {
    "objectID": "unidad_4/intro_temporal.html",
    "href": "unidad_4/intro_temporal.html",
    "title": "Intro a series de tiempo",
    "section": "",
    "text": "GRASS GIS es el primer SIG de código abierto que incorporó capacidades para gestionar, analizar, procesar y visualizar datos espacio-temporales, así como las relaciones temporales entre series de tiempo.\n\nCompletamente basado en metadatos, por lo que no hay duplicación de datos\nSigue una aproximación Snapshot, i.e., añade marcas de tiempo o timestamps a los mapas\nUna colección de mapas de la misma variable con timestamps se llama space-time dataset o STDS\nLos mapas en una STDS pueden tener diferentes extensiones espaciales y temporales\nTGRASS utiliza una base de datos SQLite para almacenar la extensión temporal y espacial de las STDS, así como las relaciones topológicas entre los mapas y entre las STDS en cada mapset.\n\nTGRASS o GRASS GIS temporal framework fue desarrollado por Sören Gebbert como parte de un proyecto Google Summer of Code en 2012. Detalles técnicos de la implementación pueden encontrarse en: Gebbert y Pebesma (2014), Gebbert y Pebesma (2017) y Gebbert et al. (2019).\n\n\n\nSpace time raster datasets (STRDS)\nSpace time 3D raster datasets (STR3DS)\nSpace time vector datasets (STVDS)\n\n\n\n\n\nEl tiempo puede definirse como intervalos (inicio y fin) o como instancias (sólo inicio)\nEl tiempo puede ser absoluto (por ejemplo, 2017-04-06 22:39:49) o relativo (por ejemplo, 4 años, 90 días)\nGranularidad es el mayor divisor común de todas las extensiones temporales (y posibles gaps) de los mapas de un STDS\n\n\n\n\nSeries de diferente granularidad y tipo de tiempo\n\n\n\nTopología se refiere a las relaciones temporales entre los intervalos de tiempo en una STDS\n\n\n\n\nRelaciones topológicas entre STDS y entre mapas\n\n\n\nMuestreo temporal se utiliza para determinar el estado de un proceso respecto un segundo proceso.\n\n\n\n\nMuestreo temporal\n\n\n\n\n\n\nt.*: Módulos generales para manejar STDS de todos los tipos\nt.rast.*: Módulos que tratan con STRDS\nt.rast3d.*: Módulos que tratan con STR3DS\nt.vect.*: Módulos que tratan con STVDS"
  },
  {
    "objectID": "unidad_4/intro_temporal.html#procesamiento-de-series-de-tiempo-en-grass-gis",
    "href": "unidad_4/intro_temporal.html#procesamiento-de-series-de-tiempo-en-grass-gis",
    "title": "Intro a series de tiempo",
    "section": "",
    "text": "Nociones básicas\nTGRASS framework\nCreación de series de tiempo\nÁlgebra temporal y variables temporales\nDistintos tipos de agregación\nEstadística zonal e islas de calor urbanas\nConexión con R\n\nGRASS GIS es el primer SIG de código abierto que incorporó capacidades para gestionar, analizar, procesar y visualizar datos espacio-temporales, así como las relaciones temporales entre series de tiempo."
  },
  {
    "objectID": "unidad_4/intro_temporal.html#tgrass-grass-temporal",
    "href": "unidad_4/intro_temporal.html#tgrass-grass-temporal",
    "title": "Intro a series de tiempo",
    "section": "TGRASS: GRASS Temporal",
    "text": "TGRASS: GRASS Temporal\n\nCompletamente basado en metadatos, por lo que no hay duplicación de datos\nSigue una aproximación Snapshot, i.e., añade marcas de tiempo o timestamps a los mapas\nUna colección de mapas de la misma variable con timestamps se llama space-time dataset o STDS\nLos mapas en una STDS pueden tener diferentes extensiones espaciales y temporales\nTGRASS utiliza una base de datos SQLite para almacenar la extensión temporal y espacial de las STDS, así como las relaciones topológicas entre los mapas y entre las STDS en cada mapset."
  },
  {
    "objectID": "unidad_4/intro_temporal.html#space-time-datasets",
    "href": "unidad_4/intro_temporal.html#space-time-datasets",
    "title": "Intro a series de tiempo",
    "section": "",
    "text": "Space time raster datasets (STRDS)\nSpace time 3D raster datasets (STR3DS)\nSpace time vector datasets (STVDS)"
  },
  {
    "objectID": "unidad_4/intro_temporal.html#otras-nociones-básicas-en-tgrass",
    "href": "unidad_4/intro_temporal.html#otras-nociones-básicas-en-tgrass",
    "title": "Intro a series de tiempo",
    "section": "",
    "text": "El tiempo puede definirse como intervalos (inicio y fin) o como instancias (sólo inicio)\nEl tiempo puede ser absoluto (por ejemplo, 2017-04-06 22:39:49) o relativo (por ejemplo, 4 años, 90 días)\nGranularidad es el mayor divisor común de todas las extensiones temporales (y posibles gaps) de los mapas de un STDS\n\n\n\n\nSeries de diferente granularidad y tipo de tiempo\n\n\n\nTopología se refiere a las relaciones temporales entre los intervalos de tiempo en una STDS\n\n\n\n\nRelaciones topológicas entre STDS y entre mapas\n\n\n\nMuestreo temporal se utiliza para determinar el estado de un proceso respecto un segundo proceso.\n\n\n\n\nMuestreo temporal"
  },
  {
    "objectID": "unidad_4/intro_temporal.html#módulos-temporales",
    "href": "unidad_4/intro_temporal.html#módulos-temporales",
    "title": "Intro a series de tiempo",
    "section": "",
    "text": "t.*: Módulos generales para manejar STDS de todos los tipos\nt.rast.*: Módulos que tratan con STRDS\nt.rast3d.*: Módulos que tratan con STR3DS\nt.vect.*: Módulos que tratan con STVDS"
  },
  {
    "objectID": "unidad_4/intro_temporal.html#tgrass-marco-general-y-flujo-de-trabajo",
    "href": "unidad_4/intro_temporal.html#tgrass-marco-general-y-flujo-de-trabajo",
    "title": "Intro a series de tiempo",
    "section": "TGRASS: marco general y flujo de trabajo",
    "text": "TGRASS: marco general y flujo de trabajo"
  },
  {
    "objectID": "unidad_4/intro_temporal.html#manos-a-la-obra-con-series-de-tiempo-raster-en-grass-gis",
    "href": "unidad_4/intro_temporal.html#manos-a-la-obra-con-series-de-tiempo-raster-en-grass-gis",
    "title": "Intro a series de tiempo",
    "section": "",
    "text": "Producto MODIS: MOD11B3 Collection 6\nTile: h12v12\nComposiciones mensuales\nResolución espacial: 5600m\nMapset modis_lst\n\n\n\n\n\n\nComandos GRASS\nComandos R\n\nIniciar GRASS GIS directamente en el mapset modis_lst\n\n# paths\ngrassdata='/home/veroandreo/grassdata/'\nlocation='posgar2007_4_cba'\nmapset='modis_lst'\n\n\nimport os\nimport subprocess\nimport sys\n\n# Ask GRASS GIS where its Python packages are to be able to start it from the notebook\nsys.path.append(\n    subprocess.check_output([\"grass\", \"--config\", \"python_path\"], text=True).strip()\n)\n\n# Importar los paquetes python de GRASS\nimport grass.script as gs\nimport grass.jupyter as gj\n\n# Iniciar GRASS\nsession = gj.init(grassdata, location, mapset)\n\nEstablecer región computacional y máscara\nListar los mapas raster y obtener información de uno de ellos\n\n# Get list of raster maps in the 'modis_lst' mapset\ng.list type=raster mapset=.\n\n# Get info from one of the raster maps\nr.info map=MOD11B3.A2015060.h12v12.single_LST_Day_6km\n\nEstablecer la región computacional\n\n# Set region to Cba boundaries with LST maps' resolution\ng.region -p vector=provincia_cba \\\n  align=MOD11B3.A2015060.h12v12.single_LST_Day_6km\n\nAplicar máscara\n\n# Set a MASK to Cba boundary\nr.mask vector=provincia_cba\n\n\n\n\nt.create  - Crea una tabla SQLite en la base de datos temporal - Permite manejar grandes cantidades de mapas usando el STDS como entrada - Necesitamos especificar: - tipo de mapas (raster, raster3d o vector) - tipo de tiempo (absoluto o relativo)\nCrear la STRDS\n\n# Create the STRDS\nt.create type=strds temporaltype=absolute output=LST_Day_monthly \\\n  title=\"Monthly LST Day 5.6 km\" \\\n  description=\"Monthly LST Day 5.6 km MOD11B3.006 Cordoba, 2015-2019\"\n\nChequear si la STRDS fue creada\n\n# Check if the STRDS is created\nt.list type=strds\n\nObtener información sobre la STRDS\n\n# Get info about the STRDS\nt.info input=LST_Day_monthly\n\n\n\n\nt.register  - Asigna o agrega timestamps a los mapas - Necesitamos: - el STDS vacío como entrada, i.e., la tabla SQLite contenedora, - la lista de mapas que se registrarán, - la fecha de inicio, - la opción de incremento junto con -i para la creación de intervalos\nAñadir timestamps a los mapas, i.e., registrar mapas\n\n# Add time stamps to maps (i.e., register maps)\nt.register -i input=LST_Day_monthly \\\n maps=`g.list type=raster pattern=\"MOD11B3*LST_Day*\" separator=comma` \\\n start=\"2015-01-01\" increment=\"1 months\"\n\nChequear la información sobre la STRDS nuevamente\n\n# Check info again\nt.info input=LST_Day_monthly\n\nObtener la lista de mapas en la STRDS\n\n# Check the list of maps in the STRDS\nt.rast.list input=LST_Day_monthly\n\nChequear los valores mínimos y máximos de cada mapa\n\n# Check min and max per map\nt.rast.list input=LST_Day_monthly columns=name,min,max\n\nPara más opciones, ver el manual de t.register y la wiki sobre opciones para registrar mapas en STDS.\nRepresentación gráfica de STDS\nCrear una representación gráfica de la serie de tiempo\n\n# graphical representation of our STRDS\ng.gui.timeline inputs=LST_Day_monthly\n\n\nVer el manual de g.gui.timeline\n\n\n\n\nRealiza una amplia gama de operaciones de álgebra temporal y espacial basadas en la topología temporal de los mapas\n\nOperadores temporales: unión, intersección, etc.\nFunciones temporales: start_time(), start_doy(), etc.\nOperadores espaciales (subconjunto de r.mapcalc)\nModificador de vecindario temporal: [x,y,t]\nOtras funciones temporales como t_snap(), buff_t() o t_shift()\n\n\n¡pueden combinarse en expresiones complejas!\n\n\nRe-escalar a grados Celsius\n\n# Re-scale data to degrees Celsius\nt.rast.algebra basename=LST_Day_monthly_celsius suffix=gran \\\n  expression=\"LST_Day_monthly_celsius = LST_Day_monthly * 0.02 - 273.15\"\n\nVer info de la nueva serie de tiempo\n\n# Check info\nt.info LST_Day_monthly_celsius\n\n\n\n\nGráfico temporal de LST para la ciudad de Córdoba, Argentina\n\n# LST time series plot for Cba city center\ng.gui.tplot strds=LST_Day_monthly_celsius \\\n  coordinates=4323478.531282977,6541664.09350761 \\\n  title=\"Monthly LST. City center of Cordoba\" \\\n  xlabel=\"Time\" ylabel=\"LST\"\n\nPara un único punto, ver g.gui.tplot. Para un vector de puntos, ver t.rast.what.\n\nLas coordenadas del punto pueden ser escritas directamente, copiadas desde el mapa o seleccionadas interactivamente."
  },
  {
    "objectID": "unidad_4/intro_temporal.html#listas-y-selecciones",
    "href": "unidad_4/intro_temporal.html#listas-y-selecciones",
    "title": "Intro a series de tiempo",
    "section": "Listas y selecciones",
    "text": "Listas y selecciones\n\nt.list para listar las STDS y los mapas registrados en la base de datos temporal,\nt.rast.list para mapas en series temporales de rasters, y\nt.vect.list para mapas en series temporales de vectores.\n\n\nVariables usadas para hacer las listas y selecciones\nSTRDS:id, name, creator, mapset, temporal_type, creation_time, start_time, end_time, north, south, west, east, nsres, ewres, cols, rows, number_of_cells, min, max\nSTVDS:id, name, layer, creator, mapset, temporal_type, creation_time, start_time, end_time, north, south, west, east, points, lines, boundaries, centroids, faces, kernels, primitives, nodes, areas, islands, holes, volumes\n\nEjemplos de listas y selecciones\nMapas cuyo valor mínimo es menor o igual a 10\n\n# Maps with minimum value lower than or equal to 10\nt.rast.list input=LST_Day_monthly_celsius order=min \\\n columns=name,start_time,min where=\"min &lt;= '10.0'\"\n\nMapas cuyo valor máximo es mayor a 30\n\n# Maps with maximum value higher than 30\nt.rast.list input=LST_Day_monthly_celsius order=max \\\n columns=name,start_time,max where=\"max &gt; '30.0'\"\n\nMapas contenidos entre dos fechas\n\n# Maps between two given dates\nt.rast.list input=LST_Day_monthly_celsius columns=name,start_time \\\n where=\"start_time &gt;= '2015-05' and start_time &lt;= '2015-08-01 00:00:00'\"\n\nTodos los mapas correspondientes al mes de Enero\n\n# Maps from January\nt.rast.list input=LST_Day_monthly_celsius columns=name,start_time \\\n where=\"strftime('%m', start_time)='01'\"\n\n\n\n\nEstadística descriptiva de STRDS\nImprimir estadísticas descriptivas univariadas para cada mapa dentro de la STRDS\n\n# Print univariate stats for maps within STRDS\nt.rast.univar input=LST_Day_monthly_celsius\n\nObtener estadísticas extendidas con la opción -e\n\n# Get extended statistics\nt.rast.univar -e input=LST_Day_monthly_celsius\n\nEscribir la salida a un archivo de texto\n\n# Write the univariate stats output to a csv file\nt.rast.univar input=LST_Day_monthly_celsius separator=comma \\\n  output=stats_LST_Day_monthly_celsius.csv\n\n\n\nAgregación temporal 1: Serie completa\nt.rast.series\n\nAgrega STRDS completas o partes de ellas usando la opción where.\nDiferentes métodos disponibles: promedio, mínimo, máximo, mediana, moda, etc.\n\nLST máxima y mínima del período 2015-2019\nObtener el mapa de la máxima LST del período\n\n# Get maximum LST in the STRDS\nt.rast.series input=LST_Day_monthly_celsius \\\n  output=LST_Day_max method=maximum\n\nObtener el mapa de la mínima LST del período\n\n# Get minimum LST in the STRDS\nt.rast.series input=LST_Day_monthly_celsius \\\n  output=LST_Day_min method=minimum\n\nCambiar la paleta de colores a celsius\n\n# Change color pallete to celsius\nr.colors map=LST_Day_min,LST_Day_max color=celsius\n\n\nComparar mapas con la herramienta Mapswipe\n\n\n\n\nOperaciones usando variables temporales\nt.rast.mapcalc\n\nEjecuta expresiones espacio-temporales tipo r.mapcalc\nPermite operadores espaciales y temporales, así como variables internas en la expresión\nLas variables temporales incluyen: start_time(), end_time(), start_month(), start_doy(), etc.\n\nCuál es el mes de máxima LST?\nObtener el mes en que ocurre el máximo de LST en cada pixel\n\n# Get month of maximum LST\nt.rast.mapcalc -n inputs=LST_Day_monthly_celsius \\\n  output=month_max_lst \\\n  expression=\"if(LST_Day_monthly_celsius == LST_Day_max, start_month(), null())\" \\\n  basename=month_max_lst\n\nObtener información del mapa resultante\n\n# Get basic info\nt.info month_max_lst\n\nObtener el primer mes en que aparece el máximo de LST\n\n# Get the earliest month in which the maximum appeared (method minimum)\nt.rast.series input=month_max_lst \\\n  method=minimum \\\n  output=max_lst_date\n\nRemover la STRDS intermedia y los mapas que contiene: month_max_lst\n\n# Remove month_max_lst strds \n# we were only interested in the resulting aggregated map\nt.remove -rf inputs=month_max_lst\n\nMostrar el mapa resultante desde la terminal\nAbrir un monitor wx\n\n# Open a monitor\nd.mon wx0\n\nMostrar el mapa raster\n\n# Display the raster map\nd.rast map=max_lst_date\n\nMostrar sólo los bordes del mapa vectorial de NC\n\n# Display boundary vector map\nd.vect map=provincia_cba type=boundary color=#4D4D4D width=2\n\nAgregar leyenda\n\n# Add raster legend\nd.legend -t raster=max_lst_date title=\"Month\" \\\n  labelnum=6 title_fontsize=20 font=sans fontsize=16\n\nAgregar barra de escala\n\n# Add scale bar\nd.barscale length=100 units=kilometers segment=4 fontsize=14\n\nAgregar Norte\n\n# Add North arrow\nd.northarrow style=1b text_color=black\n\nAgregar título\n\n# Add text\nd.text text=\"Month of maximum LST\" \\\n  color=black align=cc font=sans size=12\n\n\n\nPodríamos haber hecho lo mismo pero anualmente para conocer en qué mes ocurre el máximo en cada año y así evaluar la ocurrencia de tendencias. Cómo lo harían?\n\n\n\nAgregación temporal 2: granularidad\nt.rast.aggregate\n\nAgrega mapas raster dentro de STRDS con diferentes granularidades\nLa opción where permite establecer fechas específicas para la agregación\nDiferentes métodos disponibles: promedio, mínimo, máximo, mediana, moda, etc.\n\nDe LST mensual a estacional\nLST media estacional\n\n# 3-month mean LST\nt.rast.aggregate input=LST_Day_monthly_celsius \\\n  output=LST_Day_mean_3month \\\n  basename=LST_Day_mean_3month suffix=gran \\\n  method=average granularity=\"3 months\"\n\nChequear info\n\n# Check info\nt.info input=LST_Day_mean_3month\n\nChequear lista de mapas\n\n# Check map list\nt.rast.list input=LST_Day_mean_3month\n\n\nTarea\nComparar las líneas de tiempo mensual y estacional con g.gui.timeline\n\ng.gui.timeline inputs=LST_Day_monthly_celsius,LST_Day_mean_3month\nGraficar LST estacional con monitores wx\nEstablecer la paleta de colores celsius para la STRDS estacional\n\n# Set STRDS color table to celsius degrees\nt.rast.colors input=LST_Day_mean_3month color=celsius\n\nIniciar un monitor Cairo\n\n# Start a new graphics monitor\nd.mon cairo out=frames.png width=1400 height=500 resolution=4 --o\n\nCrear el primer frame\n\n# create a first frame\nd.frame -c frame=first at=0,100,0,25\nd.rast map=LST_Day_mean_3month_2015_01\nd.vect map=provincia_cba type=boundary color=#4D4D4D width=2\nd.text text='Ene-Mar 2015' color=black font=sans size=6 bgcolor=white\n\nCrear el segundo frame\n\n# create a second frame\nd.frame -c frame=second at=0,100,25,50\nd.rast map=LST_Day_mean_3month_2015_04\nd.vect map=provincia_cba type=boundary color=#4D4D4D width=2\nd.text text='Abr-Jun 2015' color=black font=sans size=6 bgcolor=white\n\nCrear el tercer frame\n\n# create a third frame\nd.frame -c frame=third at=0,100,50,75\nd.rast map=LST_Day_mean_3month_2015_07\nd.vect map=provincia_cba type=boundary color=#4D4D4D width=2\nd.text text='Jul-Sep 2015' color=black font=sans size=6 bgcolor=white\n\nCrear el cuarto frame\n\n# create a fourth frame\nd.frame -c frame=fourth at=0,100,75,100\nd.rast map=LST_Day_mean_3month_2015_10\nd.vect map=provincia_cba type=boundary color=#4D4D4D width=2\nd.text text='Oct-Dic 2015' color=black font=sans size=6 bgcolor=white\n\nLiberar el monitor\n\n# release monitor\nd.mon -r\n\n\nLST estacional en 2015\n\nTarea\nAhora que ya conocen t.rast.aggregate, extraigan el mes de máximo LST por año y luego vean si hay alguna tendencia positiva o negativa, es decir, si los valores máximos de LST se observan más tarde o más temprano con el tiempo (años)\n\nUna solución podría ser…\nt.rast.aggregate \\\n  input=LST_Day_monthly_celsius \\\n  output=month_max_LST_per_year \\\n  basename=month_max_LST suffix=gran \\\n  method=max_raster \\\n  granularity=\"1 year\" \n\nt.rast.series \\\n  input=month_max_LST_per_year \\\n  output=slope_month_max_LST \\\n  method=slope\n\n\nAnimaciones\nAnimación de la serie estacional de LST\n\n# Animation of seasonal LST\ng.gui.animation strds=LST_Day_mean_3month\n\nVer el manual de g.gui.animation para más opciones y ajustes.\n\n\nAgregación vs Climatología\n\nAgregación por granularidad\n\nAgregación tipo climatología\n\n\nClimatologías mensuales\nLST promedio de Enero\n\n# January average LST\nt.rast.series input=LST_Day_monthly_celsius \\\n  method=average \\\n  where=\"strftime('%m', start_time)='01'\" \\\n  output=LST_average_jan\n\nClimatología para todos los meses\n\n# for all months - *nix\nfor MONTH in `seq -w 1 12` ; do \n t.rast.series input=LST_Day_monthly_celsius method=average \\\n  where=\"strftime('%m', start_time)='${MONTH}'\" \\\n  output=LST_average_${MONTH}\ndone\n\n\nTarea\n\nComparar las medias mensuales con las climatologías mensuales\nLas climatologías que creamos forman una STRDS?\n\n\n\n\nAnomalías anuales\n\\[AnomaliaStd_i = \\frac{Media_i - Media}{SD}\\]\nSe necesitan:\n\npromedio y desviación estándar general de la serie\npromedios anuales\n\nObtener el promedio general de la serie\n\n# Get general average\nt.rast.series input=LST_Day_monthly_celsius \\\n method=average output=LST_average\n\nObtener el desvío estándar general de la serie\n\n# Get general SD\nt.rast.series input=LST_Day_monthly_celsius \\\n method=stddev output=LST_sd\n\nObtener los promedios anuales\n\n# Get annual averages\nt.rast.aggregate input=LST_Day_monthly_celsius \\\n method=average granularity=\"1 years\" \\\n output=LST_yearly_average basename=LST_yearly_average\n\nEstimar las anomalías anuales\n\n# Estimate annual anomalies\nt.rast.algebra basename=LST_year_anomaly \\\n expression=\"LST_year_anomaly = (LST_yearly_average - map(LST_average)) / map(LST_sd)\"\n\nEstablecer la paleta de colores differences\n\n# Set difference color table\nt.rast.colors input=LST_year_anomaly color=difference\n\nAnimación\n\n# Animation of annual anomalies\ng.gui.animation strds=LST_year_anomaly\n\n\n\nIsla de calor superficial urbana (Surface Urban Heat Island - SUHI)\n\nLa temperatura del aire de una zona urbana es más alta que la de las zonas cercanas\nLa UHI tiene efectos negativos en la calidad del agua y el aire, la biodiversidad, la salud humana y el clima.\nLa SUHI también está muy relacionada con la salud, ya que influye en la UHI\n\n\nSUHI y área rural en Buenos Aires. Fuente: Wu et al, 2019.\n\n\nEstadística zonal en series de tiempo de datos raster\nv.strds.stats - Permite obtener datos de series de tiempo agregados espacialmente para polígonos de un mapa vectorial\nSUHI estival para Córdoba y alrededores\nInstalar la extensión v.strds.stats\n\n# Install v.strds.stats add-on\ng.extension extension=v.strds.stats\n\nListar mapas\n\n# List maps in seasonal time series\nt.rast.list input=LST_Day_mean_3month\n\nExtraer LST promedio de verano para el Gran Córdoba\n\n# Extract summer average LST for Cba urban area\nv.strds.stats input=area_edificada_cba \\\n  strds=LST_Day_mean_3month \\\n  where=\"fna == 'Gran Córdoba'\" \\\n  t_where=\"strftime('%m', start_time)='01'\" \\\n  output=cba_summer_lst \\\n  method=average\n\nCrear buffer externo - 30 km\n\n# Create outside buffer - 30 km\nv.buffer input=cba_summer_lst \\\n  distance=30000 \\\n  output=cba_summer_lst_buf30\n\nCrear buffer interno - 15 km\n\n# Create inside buffer - 15 km\nv.buffer input=cba_summer_lst \\\n  distance=15000 \\\n  output=cba_summer_lst_buf15\n\nRemover el área del buffer 15 km del buffer de 30 km\n\n# Remove 15km buffer area from the 30km buffer area\nv.overlay ainput=cba_summer_lst_buf15 \\\n  binput=cba_summer_lst_buf30 \\\n  operator=xor \\\n  output=cba_surr\n\n\nLímites del Gran Córdoba y el área rural circundante\nExtraer estadísticas para los alrededores del Gran Córdoba\n\n# Extract zonal stats for Cba surroundings\nv.strds.stats input=cba_surr \\\n  strds=LST_Day_mean_3month \\\n  t_where=\"strftime('%m', start_time)='01'\" \\\n  method=average \\\n  output=cba_surr_summer_lst\n\nChequear la LST estival promedio para el Gran Córdoba y alrededores\n\n# Take a look at mean summer LST in Cba and surroundings\nv.db.select cba_summer_lst\nv.db.select cba_surr_summer_lst"
  },
  {
    "objectID": "unidad_4/intro_temporal.html#recursos-muy-útiles",
    "href": "unidad_4/intro_temporal.html#recursos-muy-útiles",
    "title": "Intro a series de tiempo",
    "section": "Recursos (muy) útiles",
    "text": "Recursos (muy) útiles\n\nTemporal data processing wiki\nGRASS GIS and R for time series processing wiki\nGRASS GIS temporal workshop at NCSU\nGRASS GIS course IRSAE 2018\nGRASS GIS workshop held in Jena 2023"
  },
  {
    "objectID": "unidad_4/intro_temporal.html#referencias",
    "href": "unidad_4/intro_temporal.html#referencias",
    "title": "Intro a series de tiempo",
    "section": "Referencias",
    "text": "Referencias\n\n\nGebbert, S., Leppelt, T., y Pebesma, E. (2019), «A Topology Based Spatio-Temporal Map Algebra for Big Data Analysis», Data, 4, 86. https://doi.org/10.3390/data4020086.\n\n\nGebbert, S., y Pebesma, E. (2014), «A temporal GIS for field based environmental modeling», Environmental Modelling & Software, 53, 1-12. https://doi.org/10.1016/j.envsoft.2013.11.001.\n\n\nGebbert, S., y Pebesma, E. (2017), «The GRASS GIS temporal framework», International Journal of Geographical Information Science, 31, 1273-1292. https://doi.org/10.1080/13658816.2017.1306862."
  },
  {
    "objectID": "unidad_2/python_and_grass.html#otras-librerías-python-en-grass-gis",
    "href": "unidad_2/python_and_grass.html#otras-librerías-python-en-grass-gis",
    "title": "Python y GRASS GIS",
    "section": "Otras librerías Python en GRASS GIS",
    "text": "Otras librerías Python en GRASS GIS\n\nTemporal framework\nEl GRASS GIS Temporal Framework implementa la funcionalidad SIG temporal de GRASS GIS y proporciona una API para implementar módulos de procesamiento espacio-temporal. El framework introduce conjuntos de datos espacio-temporales que representan series temporales de mapas raster, raster 3D o vectoriales. Este marco proporciona las siguientes funcionalidades:\n\nAsignación de marcas de tiempo a mapas y registro de mapas en la base de datos temporal\nModificación de marcas de tiempo\nCreación, cambio de nombre y supresión de conjuntos de datos espacio-temporales\nRegistro y anulación del registro de mapas en conjuntos de datos espacio-temporales\nConsulta de mapas registrados en conjuntos de datos espacio-temporales mediante SQL\nAnálisis de la topología espacio-temporal de los conjuntos de datos espacio-temporales\nMuestreo de conjuntos de datos espacio-temporales\nCálculo de las relaciones temporales y espaciales entre los mapas registrados\nFunciones de nivel superior compartidas entre módulos\n\n\n\n\n\n\n\nNota\n\n\n\nPara más detalles, ver la documentación de la librería en: https://grass.osgeo.org/grass-stable/manuals/libpython/temporal_framework.html\n\n\n\n\nTesting framework\nEl GRASS GIS Testing framework está basado en el paquete unittest de Python con un gran número de mejoras, extensiones y cambios específicos ajustados a GRASS. Estos cambios incluyen la creación de reportes de pruebas HTML compatibles con GRASS, o la ejecución de pruebas de manera que las terminaciones de procesos potencialmente causadas por funciones de la librería C no influyan en el proceso principal de pruebas.\nAlgunas pruebas se ejecutarán sin ningún dato, pero muchas pruebas requieren la versión básica de los datos de muestra para Carolina del Norte.\n\n\n\n\n\n\nNota\n\n\n\nPara más detalles, ver la documentación de la librería en: https://grass.osgeo.org/grass-stable/manuals/libpython/gunittest_testing.html"
  },
  {
    "objectID": "unidad_3/intro_obia.html#references",
    "href": "unidad_3/intro_obia.html#references",
    "title": "Intro a OBIA",
    "section": "Referencias",
    "text": "Referencias\n\n\nBlaschke, T. (2010), «Object based image analysis for remote sensing», ISPRS Journal of Photogrammetry and Remote Sensing, 65, 2-16. https://doi.org/10.1016/j.isprsjprs.2009.06.004.\n\n\nGeorganos, S., Grippa, T., Lennert, M., Vanhuysse, S., y Johnson, B. A. (2018), «Scale Matters: Spatially Partitioned Unsupervised Segmentation Parameter Optimization for Large and Heterogeneous Satellite Images», 23.\n\n\nGrippa, T., Lennert, M., Beaumont, B., Vanhuysse, S., Stephenne, N., Wolff, E., Grippa, T., Lennert, M., Beaumont, B., Vanhuysse, S., Stephenne, N., y Wolff, E. (2017), «An Open-Source Semi-Automated Processing Chain for Urban Object-Based Classification», Remote Sensing, 9, 358. https://doi.org/10.3390/rs9040358."
  },
  {
    "objectID": "unidad_4/exercise_temporal.html",
    "href": "unidad_4/exercise_temporal.html",
    "title": "Ejercicio: Series temporales en GRASS GIS",
    "section": "",
    "text": "En esta notebook vamos a recorrer algunas de las funcionalidades de TGRASS que ya vimos y otras nuevas, pero ahora con una serie de datos de NDVI."
  },
  {
    "objectID": "unidad_4/exercise_temporal.html#ejercicio-manos-a-la-obra-con-series-temporales-de-ndvi",
    "href": "unidad_4/exercise_temporal.html#ejercicio-manos-a-la-obra-con-series-temporales-de-ndvi",
    "title": "Ejercicio: Series temporales en GRASS GIS",
    "section": "",
    "text": "Datos para el ejercicio\nUso de bandas de confiabilidad\nCreación de serie de NDVI\nHANTS como método de reconstrucción\nAgregación temporal\nÍndices de fenología\nNDWI y frecuencia de inundación\nRegresión entre NDVI y NDWI\n\n\n\n\n\nProducto MODIS: MOD13C2 Collection 6\nComposiciones globales mensuales\nResolución espacial: 5600 m\nMapset modis_ndvi\n\n\n\n\n\nIniciar GRASS GIS en el mapset modis_ndvi\n\n# paths\ngrassdata='/home/veroandreo/grassdata/'\nlocation='posgar2007_4_cba'\nmapset='modis_ndvi'\n\n\nimport os\nimport subprocess\nimport sys\n\n# Ask GRASS GIS where its Python packages are to be able to start it from the notebook\nsys.path.append(\n    subprocess.check_output([\"grass\", \"--config\", \"python_path\"], text=True).strip()\n)\n\n# Importar los paquetes python de GRASS\nimport grass.script as gs\nimport grass.jupyter as gj\n\n# Iniciar GRASS\nsession = gj.init(grassdata, location, mapset)\n\nAgregar modis_lst a la lista de mapsets accesibles\n\n# add `modis_lst` to accessible mapsets path\ng.mapsets -p\ng.mapsets mapset=modis_lst operation=add\n\nListar los mapas y obtener información de alguno de ellos\n\n# list files and get info and stats\ng.list type=raster mapset=.\n\nr.info map=MOD13C2.A2015001.006.single_Monthly_NDVI\nr.univar map=MOD13C2.A2015001.006.single_Monthly_NDVI\n\n\nTarea\n\nMostrar los mapas de NDVI, NIR y pixel reliability.\nObtener información sobre los valores mínimos y máximos\n¿Qué se puede decir sobre los valores de cada banda?\n¿Hay valores nulos?\n\n\n\n\n\n\nTarea\n\nLeer acerca de la banda de confiabilidad en la Guía de usuario de MOD13 (pag 27).\nPara una misma fecha mostrar la banda de confiabilidad y el NDVI.\nSeleccionar sólo los pixeles con valor 0 (Buena calidad) en la banda de confiabilidad. ¿Qué se observa?\n\n\n\n\n\nDefinir la región computacional\n\n# set computational region\ng.region -p vector=provincia_cba \\\n  align=MOD13C2.A2015001.006.single_Monthly_NDVI\n\nEstablecer los límites provinciales como máscara\n\n# set mask\nr.mask vector=provincia_cba\n\nMantener sólo los pixeles de la mejor calidad\n\n# keep only NDVI most reliable pixels (one map) - *nix\nPR=MOD13C2.A2015274.006.single_Monthly_pixel_reliability\nNDVI=MOD13C2.A2015274.006.single_Monthly_NDVI\n\nr.mapcalc \\\n  expression=\"${NDVI}_filt = if(${PR} != 0, null(), ${NDVI})\"\n\nMantener sólo los pixeles de la mejor calidad - para todos los mapas\n\n# list of maps\nPR=`g.list type=raster pattern=\"*_pixel_reliability\" separator=\" \"`\nNDVI=`g.list type=raster pattern=\"*_Monthly_NDVI\" separator=\" \"`\n# convert list to array\nPR=($PR)\nNDVI=($NDVI)\n\n# iterate over the 2 arrays\nfor ((i=0;i&lt;${#PR[@]};i++)) ; do\n r.mapcalc --o \\\n  expression=\"${NDVI[$i]}_filt = if(${PR[$i]} != 0, null(), ${NDVI[$i]})\"\ndone\n\n\nTarea\nCómo podrían hacer lo mismo pero con módulos temporales?\n\nQué les parece t.rast.algebra?\n\n# apply pixel reliability band\nt.rast.algebra \\\n  expression=\"NDVI_monthly_filt = if(pixel_rel_monthly != 0, null(), ndvi_monthly)\"\n  basename=ndvi_monthly \\\n  suffix=gran\n\n\nTarea\nComparar las estadísticas entre los mapas de NDVI originales y filtrados para la misma fecha\n\n\n\n\nCrear STRDS de NDVI\n\n# create STRDS\nt.create output=ndvi_monthly \\\n  type=strds temporaltype=absolute \\\n  title=\"Filtered monthly NDVI\" \\\n  description=\"Filtered monthly NDVI - MOD13C2 - Cordoba, 2015-2019\"\n\nCorroborar que la STRDS fue creada\n\n# check if it was created\nt.list type=strds\n\nCrear archivo con lista de mapas\n\n# list NDVI filtered files\ng.list type=raster pattern=\"*filt\" output=ndvi_list.txt\n\nAsignar fecha a los mapas, i.e., registrar\n\n# register maps\nt.register -i input=ndvi_monthly \\\n  type=raster file=ndvi_list.txt \\\n  start=\"2015-01-01\" \\\n  increment=\"1 months\"\n\nImprimir info básica de la STRDS\n\n# print time series info\nt.info input=ndvi_monthly\n\nImprimir la lista de mapas en la STRDS\n\n# print list of maps in time series\nt.rast.list input=ndvi_monthly\n\n\nTarea\nExplorar visualmente los valores de las series temporales en diferentes puntos. Usar g.gui.tplot y seleccionar diferentes puntos interactivamente.\n\n\n\n\nObtener las estadísticas de la serie de tiempo\n\n# How much missing data we have after filtering for pixel reliability?\nt.rast.univar input=ndvi_monthly\n\nContar los datos válidos\n\n# count valid data\nt.rast.series input=ndvi_monthly \\\n  method=count \\\n  output=ndvi_count_valid\n\nEstimar el porcentaje de datos faltantes\n\n# estimate percentage of missing data\nr.mapcalc \\\n expression=\"ndvi_missing = ((60 - ndvi_count_valid) * 100.0)/60\"\n\nCómo guardar en una variable el numero de mapas de una serie de tiempo?\n\nt.info -g ndvi_monthly\n`eval t.info ndvi_monthly`\necho $number_of_maps\n\nr.mapcalc \\\n  expression=\"ndvi_missing = (($number_of_maps - ndvi_count_valid) * 100.0)/$number_of_maps\"\n\n\nTarea\n\nMostrar el mapa que representa el porcentaje de datos faltantes y explorar los valores.\nObtener estadísticas univariadas de este mapa.\nDónde estan los mayores porcentajes de datos faltantes? Por qué creen que puede ser?\n\n\n\n\n\n\nHarmonic Analysis of Time Series (HANTS)\nImplementado en la extensión r.hants\n\n\n\n\n\nInstalar la extensión r.hants\n\n# install extension\ng.extension extension=r.hants\n\nListar los mapas y aplicar r.hants\n\n# list maps\nmaplist=`t.rast.list input=ndvi_monthly method=comma`\n\n# gapfill: r.hants\nr.hants input=$maplist range=-2000,10000 \\\n  nf=5 fet=500 base_period=12\n\n\nTarea\nProbar diferentes ajustes de parámetros en r.hants y comparar los resultados\n\n\n\n\nParcheo de serie original y reconstruída\n\n# patch original with filled (one map)\nNDVI_ORIG=MOD13C2.A2015001.006.single_Monthly_NDVI_filt\nNDVI_HANTS=MOD13C2.A2015001.006.single_Monthly_NDVI_filt_hants\n\nr.patch input=${NDVI_ORIG},${NDVI_HANTS} \\\n  output=${NDVI_HANTS}_patch\n\nParcheo de serie original y reconstruída\n\n# list of maps\nORIG=`g.list type=raster pattern=\"*_filt\" separator=\" \"`\nFILL=`g.list type=raster pattern=\"*_hants\" separator=\" \"`\n# convert list to array\nORIG=($ORIG)\nFILL=($FILL)\n\n# iterate over the 2 arrays\nfor ((i=0;i&lt;${#ORIG[@]};i++)) ; do\n  r.patch input=${ORIG[$i]},${FILL[$i]} output=${FILL[$i]}_patch --o\ndone\n\nCrear serie de tiempo con los datos parcheados\n\n# create new time series \nt.create output=ndvi_monthly_patch \\\n  type=strds temporaltype=absolute \\\n  title=\"Patched monthly NDVI\" \\\n  description=\"Filtered, gap-filled and patched monthly NDVI - MOD13C2 - Cordoba, 2015-2019\"\n\nRegistrar los mapas en la serie de tiempo\n\n# list NDVI patched files\ng.list type=raster pattern=\"*patch\" \\\n  output=list_ndvi_patched.txt\n\n# register maps\nt.register -i input=ndvi_monthly_patch \\\n  type=raster file=list_ndvi_patched.txt \\\n  start=\"2015-01-01\" \\\n  increment=\"1 months\"\n\nImprimir información de la serie de tiempo\n\n# print time series info\nt.info input=ndvi_monthly_patch\n\n\nTarea\n\nEvaluar gráficamente los resultados de la reconstrucción de HANTS en pixeles con mayor porcentaje de datos faltantes\nObtener estadísticas univariadas para las nuevas series temporales\n\n\n\nTarea\n\nVer la sección de métodos en Metz el al. 2017\nQué otros algoritmos existen o qué otra aproximación podría seguirse?\n\n\n\n\n\n\n\nTarea\n\nObtener el promedio de NDVI cada dos meses\nVisualizar la serie de tiempo resultante con g.gui.animation\n\n\n\n\n\nMes de máximo y mes de mínimo\n\n# get month of maximum and month of minimum\nt.rast.series input=ndvi_monthly_patch \\\n  method=minimum output=ndvi_min\nt.rast.series input=ndvi_monthly_patch \\\n  method=maximum output=ndvi_max\n\nReemplazar con start_month() los valores en la STRDS si coinciden con el mínimo o máximo global\n\n# get month of maximum and minimum\nt.rast.mapcalc -n inputs=ndvi_monthly_patch \\\n  output=month_max_ndvi \\\n  expression=\"if(ndvi_monthly_patch == ndvi_max, start_month(), null())\" \\\n  basename=month_max_ndvi\n\nt.rast.mapcalc -n inputs=ndvi_monthly_patch \\\n  output=month_min_ndvi \\\n  expression=\"if(ndvi_monthly_patch == ndvi_min, start_month(), null())\" \\\n  basename=month_min_ndvi\n\nObtener el primer mes en el que aparecieron el máximo y el mínimo\n\n# get the earliest month in which the maximum and minimum appeared\nt.rast.series input=month_max_ndvi \\\n  method=maximum output=max_ndvi_date\nt.rast.series input=month_min_ndvi \\\n  method=minimum output=min_ndvi_date\n\nEliminar la serie temporal intermedia\n\n# remove month_max_lst strds \nt.remove -rf inputs=month_max_ndvi,month_min_ndvi\n\n\nTarea\n\nMostrar los mapas resultantes con g.gui.mapswipe\nCuándo se observan los mínimos y máximos? Hay algun patrón? A qué se podría deber?\n\n\n\nTarea\nAsociar el máximo de LST con el máximo de NDVI y, la fecha de la máxima LST con la fecha del máximo NDVI\n\n Ver el módulo r.covar\n\n\n\nObtener series temporales de pendientes entre mapas consecutivos\n\n# time series of slopes\nt.rast.algebra \\\n expression=\"slope_ndvi = (ndvi_monthly_patch[1] - ndvi_monthly_patch[0]) / td(ndvi_monthly_patch)\" \\\n basename=slope_ndvi suffix=gran\n\nObtener la máxima pendiente por año\n\n# get max slope per year\nt.rast.aggregate input=slope_ndvi output=ndvi_slope_yearly \\\n  basename=NDVI_max_slope_year suffix=gran \\\n  method=maximum \\\n  granularity=\"1 years\"\n\n\nTarea\n\nObtener un mapa con la mayor tasa de crecimiento por píxel en el período 2015-2019\nQué modulo usarían?\n\n\n\n\n\nInstalar la extensión r.seasons\n\n# install extension\ng.extension extension=r.seasons\n\nDeterminar el comienzo, el final y la duración del período de crecimiento\n\n# start, end and length of growing season\nr.seasons input=`t.rast.list -u input=ndvi_monthly_patch method=comma` \\\n  prefix=ndvi_season n=3 \\\n  nout=ndvi_season \\\n  threshold_value=3000 min_length=5\n\n\nTarea\n\nQué nos dice cada mapa? Dónde es más larga la estación de crecimiento?\nExportar los mapas resultantes como .png\n\n\n\n\n\nCrear un mapa de umbrales para usar en r.seasons\n\n# create a threshold map: min ndvi + 0.1*ndvi\nr.mapcalc expression=\"threshold_ndvi = ndvi_min * 1.1\"\n\n\nTarea\nUtilizar el mapa de umbrales en r.seasons y comparar los mapas de salida con los resultados de utilizar sólo un valor de umbral\n\n\n\n\nCrear series temporales de NIR y MIR\n\n# create time series of NIR and MIR\nt.create output=NIR \\\n  type=strds temporaltype=absolute \\\n  title=\"NIR monthly\" \\\n  description=\"NIR monthly - MOD13C2 - 2015-2019\"\n\nt.create output=MIR \\\n  type=strds temporaltype=absolute \\\n  title=\"MIR monthly\" \\\n  description=\"MIR monthly - MOD13C2 - 2015-2019\"\n\nListar archivos NIR y MIR\n\n# list NIR and MIR files\ng.list type=raster pattern=\"*NIR*\" output=list_nir.txt\ng.list type=raster pattern=\"*MIR*\" output=list_mir.txt\n\nRegistrar mapas\n\n# register maps\nt.register -i input=NIR \\\n  type=raster file=list_nir.txt \\\n  start=\"2015-01-01\" increment=\"1 months\"\n\nt.register -i input=MIR \\\n  type=raster file=list_mir.txt \\\n  start=\"2015-01-01\" increment=\"1 months\"\n\nImprimir información de la serie de tiempo\n\n# print time series info\nt.info input=NIR\nt.info input=MIR\n\nEstimación de la serie temporal de NDWI\n\n# estimate NDWI time series\nt.rast.algebra basename=ndwi_monthly \\\n  expression=\"ndwi_monthly = if(NIR &gt; 0 && MIR &gt; 0, (float(NIR - MIR) / float(NIR + MIR)), null())\" \\\n  suffix=gran\n\n\nTarea\nObtener valores máximos y mínimos para cada mapa de NDWI y explorar el trazado de la serie de tiempo en diferentes puntos de forma interactiva\n\n Ver el manual de t.rast.univar\n\n\n\nReclasificar los mapas según un umbral\n\n# reclassify\nt.rast.mapcalc -n input=ndwi_monthly \\\n  output=flood basename=flood \\\n  expression=\"if(ndwi_monthly &gt; 0.8, 1, null())\"\n\nObtener frecuencia de inundación\n\n# flooding frequency\nt.rast.series input=flood output=flood_freq method=sum\n\n\nTarea\nCuáles son las áreas que se han inundado con más frecuencia?\n\n\n\n\nInstalar la extensión r.regression.series\n\n# install extension\ng.extension extension=r.regression.series\n\nRealizar una regresión entre las series temporales de NDVI y NDWI - *nix\n\nxseries=`t.rast.list input=ndvi_monthly_patch method=comma`\nyseries=`t.rast.list input=ndwi_monthly method=comma`\n\nr.regression.series xseries=$xseries \\\n  yseries=$yseries \\\n  output=ndvi_ndwi_rsq \\\n  method=rsq\n\n\nTarea\nDeterminar dónde está la mayor correlación entre NDVI y NDWI\n\n\nGracias por su atención!!\n\n\n\nGRASS GIS logo"
  },
  {
    "objectID": "unidad_4/exercise_temporal.html#datos-para-el-ejercicio",
    "href": "unidad_4/exercise_temporal.html#datos-para-el-ejercicio",
    "title": "Ejercicio: Series temporales en GRASS GIS",
    "section": "Datos para el ejercicio",
    "text": "Datos para el ejercicio\n\nProducto MODIS: MOD13C2 Collection 6\nComposiciones globales mensuales\nResolución espacial: 5600 m\nMapset modis_ndvi"
  },
  {
    "objectID": "unidad_4/exercise_temporal.html#iniciamos-grass",
    "href": "unidad_4/exercise_temporal.html#iniciamos-grass",
    "title": "Ejercicio: Series temporales en GRASS GIS",
    "section": "Iniciamos GRASS",
    "text": "Iniciamos GRASS\nDefinimos las rutas y el mapset modis_ndvi\n\nimport os\n\n# data directory\nhomedir = os.path.expanduser('~')\n\n# GRASS GIS database variables\ngrassdata = os.path.join(homedir, \"grassdata\")\nproject = \"posgar2007_4_cba\"\nmapset = \"modis_ndvi\"\n\n\n# import standard Python packages we need\nimport sys\nimport subprocess\n\n# ask GRASS GIS where its Python packages are to be able to run it from the notebook\nsys.path.append(\n    subprocess.check_output([\"grass\", \"--config\", \"python_path\"], text=True).strip()\n)\n\nImportamos los paquetes de GRASS e iniciamos una sesión:\n\n# import the GRASS GIS packages we need\nimport grass.script as gs\nimport grass.jupyter as gj\n\n# Start the GRASS GIS Session\nsession = gj.init(grassdata, project, mapset)\n\n\n# show current GRASS GIS settings, this also checks if the session works\ngs.gisenv()"
  },
  {
    "objectID": "unidad_4/exercise_temporal.html#exploramos-los-datos-de-ndvi",
    "href": "unidad_4/exercise_temporal.html#exploramos-los-datos-de-ndvi",
    "title": "Ejercicio: Series temporales en GRASS GIS",
    "section": "Exploramos los datos de NDVI",
    "text": "Exploramos los datos de NDVI\nListar los mapas y obtener información de alguno de ellos\n\n# list raster files\nlista_mapas = gs.list_grouped(type=\"raster\")[\"modis_ndvi\"]\nlista_mapas[:10]\n\n\n#  get info and stats\ngs.raster_info(map=\"MOD13C2.A2015001.006.single_Monthly_NDVI\")\n\n\nprint(gs.read_command(\"r.univar\",\n                      map=\"MOD13C2.A2015001.006.single_Monthly_NDVI\"))\n\n\n\n\n\n\n\nTarea\n\n\n\n\nMostrar los mapas de NDVI, NIR y pixel reliability.\nObtener información sobre los valores mínimos y máximos\n¿Qué se puede decir sobre los valores de cada banda?\n¿Hay valores nulos?"
  },
  {
    "objectID": "unidad_4/exercise_temporal.html#referencias",
    "href": "unidad_4/exercise_temporal.html#referencias",
    "title": "Ejercicio: Series temporales en GRASS GIS",
    "section": "Referencias",
    "text": "Referencias\n\n\nMetz, M., Andreo, V., y Neteler, M. (2017), «A New Fully Gap-Free Time Series of Land Surface Temperature from MODIS LST Data», Remote Sensing, 9, 1333. https://doi.org/10.3390/rs9121333."
  },
  {
    "objectID": "unidad_4/exercise_temporal.html#uso-de-la-banda-de-confiabilidad",
    "href": "unidad_4/exercise_temporal.html#uso-de-la-banda-de-confiabilidad",
    "title": "Ejercicio: Series temporales en GRASS GIS",
    "section": "Uso de la banda de confiabilidad",
    "text": "Uso de la banda de confiabilidad\nDefinir la región computacional\n\n# set computational region\ngs.region_env(vector=\"provincia_cba\",\n              align=\"MOD13C2.A2015001.006.single_Monthly_NDVI\",\n              flags=\"p\")\n\nEstablecer los límites provinciales como máscara\n\n# set a MASK to Cba boundary\ngs.run_command(\"r.mask\",\n               vector=\"provincia_cba\")\n\n\n\n\n\n\n\nTarea\n\n\n\n\nLeer acerca de la banda de confiabilidad en la Guía de usuario de MOD13 (pag 27).\nPara una misma fecha mapear la banda de confiabilidad y el NDVI.\nSeleccionar sólo los pixeles con valor 0 (Buena calidad) en la banda de confiabilidad. ¿Qué se observa?\n\n\n\nMantener sólo los pixeles de la mejor calidad\n\n# keep only NDVI most reliable pixels (one map)\nPR=\"MOD13C2.A2015274.006.single_Monthly_pixel_reliability\"\nNDVI=\"MOD13C2.A2015274.006.single_Monthly_NDVI\"\n\ngs.mapcalc(exp=f\"{NDVI}_filt = if({PR} != 0, null(), {NDVI})\")\n\n\n# plot result\nndvi_filt = gj.InteractiveMap(width = 500, tiles=\"OpenStreetMap\")\nndvi_filt.add_raster(\"MOD13C2.A2015274.006.single_Monthly_NDVI_filt\")\nndvi_filt.show()\n\nMantener sólo los pixeles de la mejor calidad para todos los mapas\n\n# list of maps\nPR = gs.list_grouped(type=\"raster\", \n                     pattern=\"*_pixel_reliability\")[\"modis_ndvi\"]\nNDVI = gs.list_grouped(type=\"raster\", \n                       pattern=\"*_Monthly_NDVI\")[\"modis_ndvi\"]\n\n# iterate over the 2 arrays\nfor i,j in zip(PR,NDVI):\n    print(i, j)\n    gs.mapcalc(exp=f\"{j}_filt = if({i} != 0, null(), {j})\")\n\n\n\n\n\n\n\nNota\n\n\n\nCómo podrían hacer lo mismo pero usando módulos temporales? Qué les parece t.rast.algebra? OJO! Esto requiere primero crear las series de tiempo y registrar los mapas para que funcione!\n\n# apply pixel reliability band with t.rast.algebra\nexpression=\"NDVI_monthly_filt = if(pixel_rel_monthly != 0, null(), ndvi_monthly)\"\n\ngs.run_command(\"t.rast.algebra\",\n               expression=expression,\n               basename=\"ndvi_monthly\",\n               suffix=\"gran\",\n               nproc=4)\n\n\n\n\n\n\n\n\n\nTarea\n\n\n\nComparar las estadísticas entre los mapas de NDVI originales y filtrados para la misma fecha"
  },
  {
    "objectID": "unidad_4/exercise_temporal.html#creación-de-la-serie-de-tiempo",
    "href": "unidad_4/exercise_temporal.html#creación-de-la-serie-de-tiempo",
    "title": "Ejercicio: Series temporales en GRASS GIS",
    "section": "Creación de la serie de tiempo",
    "text": "Creación de la serie de tiempo\nCrear STRDS de NDVI\n\n# create STRDS\ngs.run_command(\"t.create\",\n               type=\"strds\",\n               temporaltype=\"absolute\",\n               output=\"ndvi_monthly\",\n               title=\"Filtered monthly NDVI\",\n               description=\"Filtered monthly NDVI - MOD13C2 - Cordoba, 2015-2019\")\n\nCorroborar que la STRDS fue creada\n\n# check if it was created\ngs.read_command(\"t.list\",\n                type=\"strds\")\n\nCrear archivo con lista de mapas\n\n# list NDVI filtered files\nNDVI_filt = gs.list_grouped(type=\"raster\", \n                            pattern=\"*_filt\")[\"modis_ndvi\"]\nNDVI_filt[:10]\n\nAsignar fecha a los mapas, i.e., registrar\n\n# register maps\ngs.run_command(\"t.register\",\n               input=\"ndvi_monthly\",\n               maps=NDVI_filt,\n               start=\"2015-01-01\",\n               increment=\"1 months\",\n               flags=\"i\")\n\nImprimir info básica de la STRDS\n\n# print time series info\nprint(gs.read_command(\"t.info\", \n                      input=\"ndvi_monthly\"))\n\nImprimir la lista de mapas en la STRDS\n\n# print list of maps in time series\nprint(gs.read_command(\"t.rast.list\", \n                      input=\"ndvi_monthly\"))\n\nTambién podemos obtener los valores para un único pixel\n\n# Get region center coordinates for query \ngs.region(complete=True)\n\n\n# Query map at center coordinates\nprint(gs.read_command(\"t.rast.what\", \n                      strds=\"s2_ndvi\", \n                      coordinates=\"637500,221750\", \n                      layout=\"col\", \n                      flags=\"n\"))\n\n\n\n\n\n\n\nTarea\n\n\n\nExplorar visualmente los valores de las series temporales en diferentes puntos. Usar g.gui.tplot y seleccionar diferentes puntos interactivamente."
  },
  {
    "objectID": "unidad_4/exercise_temporal.html#datos-faltantes",
    "href": "unidad_4/exercise_temporal.html#datos-faltantes",
    "title": "Ejercicio: Series temporales en GRASS GIS",
    "section": "Datos faltantes",
    "text": "Datos faltantes\nObtener las estadísticas de la serie de tiempo\n\n# How much missing data we have after filtering for pixel reliability?\nprint(gs.read_command(\"t.rast.univar\",\n                      input=\"ndvi_monthly\"))\n\nContar los datos válidos\n\n# count valid data\ngs.run_command(\"t.rast.series\",\n               input=\"ndvi_monthly\",\n               method=\"count\",\n               output=\"ndvi_count_valid\")\n\nEstimar el porcentaje de datos faltantes\n\n# estimate percentage of missing data\ngs.mapcalc(exp=\"ndvi_missing = ((60 - ndvi_count_valid) * 100.0)/60\")\n\nCómo guardar en una variable el numero de mapas de una serie de tiempo?\n\nn = gs.parse_command(\"t.info\", \n                     input=\"ndvi_monthly\", \n                     flags=\"g\")[\"number_of_maps\"]\nn\n\n\ngs.mapcalc(exp=f\"ndvi_missing = (({n} - ndvi_count_valid) * 100.0)/{n}\")\n\n\n\n\n\n\n\nTarea\n\n\n\n\nMostrar el mapa que representa el porcentaje de datos faltantes y explorar los valores.\nObtener estadísticas univariadas de este mapa.\nDónde estan los mayores porcentajes de datos faltantes? Por qué creen que puede ser?"
  },
  {
    "objectID": "unidad_4/exercise_temporal.html#reconstrucción-temporal-hants",
    "href": "unidad_4/exercise_temporal.html#reconstrucción-temporal-hants",
    "title": "Ejercicio: Series temporales en GRASS GIS",
    "section": "Reconstrucción temporal: HANTS",
    "text": "Reconstrucción temporal: HANTS\n\nHarmonic Analysis of Time Series (HANTS)\nImplementado en la extensión r.hants\n\n\nInstalar la extensión r.hants\n\n# install extension\ngs.run_command(\"g.extension\",\n               extension=\"r.hants\")\n\nListar los mapas y aplicar r.hants\n\n# list maps\nmaplist = gs.parse_command(\"t.rast.list\",\n                          input=\"ndvi_monthly\",\n                          columns=\"name\",\n                          method=\"comma\",\n                          flags=\"u\")\nmaplist = list(maplist.keys())\n\n\n# gapfill: r.hants\ngs.run_command(\"r.hants\",\n               input=maplist,\n               range=[-2000,10000],\n               nf=5,\n               fet=500,\n               base_period=12)\n\n\n# list filled maps\ngs.list_grouped(type=\"raster\",\n                pattern=\"*hants\")[\"modis_ndvi\"]\n\n\n\n\n\n\n\nTarea\n\n\n\nProbar diferentes ajustes de parámetros en r.hants y comparar los resultados\n\n\nParcheo de serie original y reconstruída\n\n# patch original with filled (one map)\nNDVI_ORIG = \"MOD13C2.A2015001.006.single_Monthly_NDVI_filt\"\nNDVI_HANTS = \"MOD13C2.A2015001.006.single_Monthly_NDVI_filt_hants\"\n\ngs.run_command(\"r.patch\",\n               input=[NDVI_ORIG, NDVI_HANTS],\n               output=f\"{NDVI_HANTS}_patch\")\n\nParcheo de serie original y reconstruída\n\n# list of maps\nORIG = gs.list_grouped(type=\"raster\",\n                     pattern=\"*_filt\")[\"modis_ndvi\"]\nFILL = gs.list_grouped(type=\"raster\",\n                       pattern=\"*_hants\")[\"modis_ndvi\"]\n\n\n# patching\nfor i,j in zip(ORIG,FILL):\n    print(i, j)\n    out=f\"{j}_patch\"\n    gs.run_command(\"r.patch\",\n                   input=[i, j],\n                   output=out)\n\nCrear serie de tiempo con los datos parcheados\n\n# create new time series \ngs.run_command(\"t.create\",\n               output=\"ndvi_monthly_patch\",\n               type=\"strds\",\n               temporaltype=\"absolute\",\n               title=\"Patched monthly NDVI\",\n               description=\"Filtered, gap-filled and patched monthly NDVI - MOD13C2 - Cordoba, 2015-2019\")\n\nRegistrar los mapas en la serie de tiempo\n\n# list NDVI patched files\npatched_maps = gs.list_grouped(type=\"raster\",\n                               pattern=\"*patch\")[\"modis_ndvi\"]\npatched_maps[:5]\n\n\n# register maps\ngs.run_command(\"t.register\",\n               flags=\"i\",\n               input=\"ndvi_monthly_patch\",\n               type=\"raster\",\n               maps=patched_maps,\n               start=\"2015-01-01\",\n               increment=\"1 months\")\n\nImprimir información de la serie de tiempo\n\n# print time series info\nprint(gs.read_command(\"t.info\", \n                      input=\"ndvi_monthly_patch\"))\n\n\n\n\n\n\n\nTarea\n\n\n\n\nEvaluar gráficamente los resultados de la reconstrucción de HANTS en pixeles con mayor porcentaje de datos faltantes\nObtener estadísticas univariadas para las nuevas series temporales\n\n\n\n\n\n\n\n\n\n\nTarea\n\n\n\n\nVer la sección de métodos en Metz et al. (2017)\nQué otros algoritmos existen o qué otra aproximación podría seguirse?"
  },
  {
    "objectID": "unidad_4/exercise_temporal.html#agregación-con-granularidad",
    "href": "unidad_4/exercise_temporal.html#agregación-con-granularidad",
    "title": "Ejercicio: Series temporales en GRASS GIS",
    "section": "Agregación con granularidad",
    "text": "Agregación con granularidad\n\n\n\n\n\n\nTarea\n\n\n\n\nObtener el promedio de NDVI cada dos meses\nVisualizar la serie de tiempo resultante con TimeSeriesMap"
  },
  {
    "objectID": "unidad_4/exercise_temporal.html#indicadores-de-fenología",
    "href": "unidad_4/exercise_temporal.html#indicadores-de-fenología",
    "title": "Ejercicio: Series temporales en GRASS GIS",
    "section": "Indicadores de fenología",
    "text": "Indicadores de fenología\n\nFecha de ocurrencia de máximos y mínimos\nIdentificamos primero los máximos y mínimos de la serie, luego reemplazamos con start_month() los valores en la STRDS si coinciden con el mínimo o máximo global y finalmente obtenemos el primer mes en el que aparecieron el máximo y el mínimo.\n\nmethods = [\"maximum\",\"minimum\"]\n\nfor me in methods:\n    # get maximum and minimum\n    gs.run_command(\"t.rast.series\",\n                   input=\"ndvi_monthly_patch\",\n                   method=me,\n                   output=f\"ndvi_{me}\")\n    # get month of maximum and minimum\n    gs.run_command(\"t.rast.mapcalc\",\n                   inputs=\"ndvi_monthly_patch\",\n                   output=f\"month_{me}_ndvi\",\n                   expression=f\"if(ndvi_monthly_patch == ndvi_{me}, start_month(), null())\",\n                   basename=f\"month_{me}_ndvi\")\n    # get the earliest month in which the maximum and minimum appeared\n    gs.run_command(\"t.rast.series\",\n                   input=f\"month_{me}_ndvi\",\n                   method=\"minimum\",\n                   output=f\"earliest_month_{me}_ndvi\")\n    # remove intermediate strds \n    gs.run_command(\"t.remove\",\n                   flags=\"rfd\",\n                   inputs=f\"month_{me}_ndvi\")\n\n\n\n\n\n\n\nTarea\n\n\n\n\nMostrar los mapas resultantes con InteractiveMap\nCuándo se observan los mínimos y máximos? Hay algun patrón? A qué se podría deber?\n\n\n\n\n\n\n\n\n\nTarea\n\n\n\n\nAsociar el máximo de LST con el máximo de NDVI y, la fecha de la máxima LST con la fecha del máximo NDVI\nAgregar el mapset modis_lst a los mapsets accesibles.\nVer el módulo r.covar\n\n\n\n\n\nTasa de crecimiento\nObtener series temporales de pendientes entre mapas consecutivos\n\n# time series of slopes\nexpression = \"slope_ndvi = (ndvi_monthly_patch[1] - ndvi_monthly_patch[0]) / td(ndvi_monthly_patch)\"\n\ngs.run_command(\"t.rast.algebra\", \n               expression=expression,\n               basename=\"slope_ndvi\",\n               suffix=\"gran\")\n\nObtener la máxima pendiente por año\n\n# get max slope per year\ngs.run_command(\"t.rast.aggregate\",\n               input=\"slope_ndvi\",\n               output=\"ndvi_slope_yearly\",\n               basename=\"NDVI_max_slope_year\",\n               suffix=\"gran\",\n               method=\"maximum\",\n               granularity=\"1 years\")\n\n\n\n\n\n\n\nTarea\n\n\n\n\nObtener un mapa con la mayor tasa de crecimiento por píxel en el período 2015-2019\nQué modulo usarían?\n\n\n\n\n\nPeríodo de crecimiento\nInstalar la extensión r.seasons\n\n# install extension\ngs.run_command(\"g.extension\",\n               extension=\"r.seasons\")\n\nDeterminar el comienzo, el final y la duración del período de crecimiento\n\n# start, end and length of growing season\ngs.run_command(\"r.seasons\",\n               input=patched_maps,\n               prefix=\"ndvi_season\",\n               n=3,\n               nout=\"ndvi_season\",\n               threshold_value=3000,\n               min_length=5)\n\n\n\n\n\n\n\nTarea\n\n\n\n\nQué nos dice cada mapa? Dónde es más larga la estación de crecimiento?\nExportar los mapas resultantes como .png\n\n\n\nCrear un mapa de umbrales para usar en r.seasons\n\n# create a threshold map: min ndvi + 0.1*ndvi\ngs.mapcalc(exp=\"threshold_ndvi = ndvi_min * 1.1\")\n\n\n\n\n\n\n\nTarea\n\n\n\nUtilizar el mapa de umbrales en r.seasons y comparar los mapas de salida con los resultados de utilizar sólo un valor de umbral"
  },
  {
    "objectID": "unidad_4/exercise_temporal.html#serie-de-tiempo-de-ndwi",
    "href": "unidad_4/exercise_temporal.html#serie-de-tiempo-de-ndwi",
    "title": "Ejercicio: Series temporales en GRASS GIS",
    "section": "Serie de tiempo de NDWI",
    "text": "Serie de tiempo de NDWI\nListas de mapas de reflectancia\n\nlist_nir = gs.list_grouped(type=\"raster\", \n                           pattern=\"*NIR*\")[\"modis_ndvi\"]\nlist_mir = gs.list_grouped(type=\"raster\", \n                           pattern=\"*MIR*\")[\"modis_ndvi\"]\n\nlen(list_nir,list_mir)\n\nAsignamos semantic labels correspondientes a las bandas\n\n# asign semantic labels to NIR and MIR maps\nfor i in list_nir:\n    gs.run_command(\"r.support\",\n                   map=i,\n                   semantic_label=\"nir\")\n\nfor i in list_mir:\n    gs.run_command(\"r.support\",\n                   map=i,\n                   semantic_label=\"mir\")\n\n\n# check\ngs.raster_info(\"MOD13C2.A2015001.006.single_Monthly_MIR_reflectance\")[\"semantic_label\"]\n\nCrear series temporales de NIR y MIR\n\n# create time series of NIR and MIR altogether\ngs.run_command(\"t.create\",\n               output=\"modis_surf\",\n               type=\"strds\",\n               temporaltype=\"absolute\",\n               title=\"Monthly surface reflectance, NIR and MIR\",\n               description=\"NIR and MIR monthly - MOD13C2 - 2015-2019\")\n\nRegistrar mapas\n\n# register maps\ngs.run_command(\"t.register\",\n               input=\"modis_surf\",\n               maps=list_nir,\n               start=\"2015-01-01\",\n               increment=\"1 months\",\n               flags=\"i\")\n\ngs.run_command(\"t.register\",\n               input=\"modis_surf\",\n               maps=list_mir,\n               start=\"2015-01-01\",\n               increment=\"1 months\",\n               flags=\"i\")\n\nImprimir información de la serie de tiempo\n\n# print time series info\nprint(gs.read_command(\"t.info\", \n                      input=\"modis_surf\"))\n\n\n# List only NIR maps\nprint(gs.read_command(\"t.rast.list\", \n                      input=\"modis_surf.nir\", \n                      columns=\"name,semantic_label\"))\n\nEstimación de la serie temporal de NDWI\n\n# extract nir and mir strds\nsls = [\"nir\", \"mir\"]\n\nfor sl in sls:\n    gs.run_command(\"t.rast.extract\",\n                   input=\"modis_surf\",\n                   where=f\"semantic_label == '{sl}'\",\n                   output=sl)\n\n\n# estimate NDWI time series\nexpression=\"ndwi_monthly = if(nir &gt; 0 && mir &gt; 0, (float(nir - mir) / float(nir + mir)), null())\"\n\ngs.run_command(\"t.rast.algebra\",\n               basename=\"ndwi_monthly\",\n               expression=expression,\n               suffix=\"gran\",\n               flags=\"n\")\n\n\n# estimate NDWI time series\n#gs.run_command(\"t.rast.mapcalc\", \n#               inputs=\"modis_surf.mir,modis_surf.nir\", \n#               output=\"ndwi_monthly\", \n#               basename=\"ndwi\",\n#               expression=\"float(modis_surf.nir - modis_surf.mir) / (modis_surf.nir + modis_surf.mir)\")\n\n\ngs.run_command(\"t.rast.colors\", \n               input=\"ndwi_monthly\", \n               color=\"ndwi\")\n\n\nprint(gs.read_command(\"t.info\", \n                      input=\"ndwi_monthly\"))\n\n\n\n\n\n\n\nTarea\n\n\n\nObtener valores máximos y mínimos para cada mapa de NDWI y explorar el trazado de la serie de tiempo en diferentes puntos de forma interactiva\nVer el manual de t.rast.univar\n\n\n\nFrecuencia de inundación\nReclasificar los mapas según un umbral\n\n# reclassify\ngs.run_command(\"t.rast.mapcalc\",\n               input=\"ndwi_monthly\",\n               output=\"flood\",\n               basename=\"flood\",\n               expression=\"if(ndwi_monthly &gt; 0.8, 1, null())\",\n               flags=\"n\")\n\nObtener frecuencia de inundación\n\n# flooding frequency\ngs.run_command(\"t.rast.series\",\n               input=\"flood\",\n               output=\"flood_freq\",\n               method=\"sum\")\n\n\n\n\n\n\n\nTarea\n\n\n\nCuáles son las áreas que se han inundado con más frecuencia?"
  },
  {
    "objectID": "unidad_4/exercise_temporal.html#regresión-ndvi-ndwi",
    "href": "unidad_4/exercise_temporal.html#regresión-ndvi-ndwi",
    "title": "Ejercicio: Series temporales en GRASS GIS",
    "section": "Regresión NDVI-NDWI",
    "text": "Regresión NDVI-NDWI\nInstalar la extensión r.regression.series\n\n# install extension\ngs.run_command(\"g.extension\",\n               extension=\"r.regression.series\")\n\nRealizar una regresión entre las series temporales de NDVI y NDWI\n\nxseries = patched_maps[1:]\nyseries = gs.list_grouped(type=\"raster\",\n                          pattern=\"ndwi_monthly*\")[\"modis_ndvi\"]\n\ngs.run_command(\"r.regression.series\",\n               xseries=xseries,\n               yseries=yseries,\n               output=\"ndvi_ndwi_rsq\",\n               method=\"rsq\")\n\n\nrsq = gj.InteractiveMap(width = 400, use_region=True)\nrsq.add_raster(\"ndvi_ndwi_rsq\", opacity=0.8)\nrsq.add_layer_control(position = \"bottomright\")\nrsq.show()\n\n\n\n\n\n\n\nTarea\n\n\n\nDeterminar dónde está la mayor correlación entre NDVI y NDWI"
  },
  {
    "objectID": "unidad_4/exercise_temporal.html#recursos-muy-útiles",
    "href": "unidad_4/exercise_temporal.html#recursos-muy-útiles",
    "title": "Ejercicio: Series temporales en GRASS GIS",
    "section": "Recursos (muy) útiles",
    "text": "Recursos (muy) útiles\n\nTemporal data processing wiki\nGRASS GIS and R for time series processing wiki\nGRASS GIS temporal workshop at NCSU\nGRASS GIS course IRSAE 2018\nGRASS GIS workshop held in Jena 2023"
  },
  {
    "objectID": "unidad_5/grass_and_r_sdm.html#uso",
    "href": "unidad_5/grass_and_r_sdm.html#uso",
    "title": "R y GRASS: Modelado de nicho",
    "section": "Uso",
    "text": "Uso\nGRASS GIS y R se pueden utilizar juntos de dos maneras:\nA. Usar R dentro de una sesión de GRASS GIS, es decir, iniciar R (o RStudio) desde la terminal de GRASS \n\nescribimos R o rstudio & en la terminal GRASS GIS\ncargar el paquete rgrass (previo haberlo instalado)\nusar read_VECT(), read_RAST() para leer datos de GRASS en R\nacceder a los módulos y la base de datos de GRASS GIS a través de execGRASS() (notar que este comando es equivalente a run_command de grass.script)\nvolver a escribir datos en la base de datos de GRASS con write_VECT() y write_RAST()\n\n\n\n\n\n\nB. Usar GRASS GIS dentro de una sesión de R, es decir, nos conectamos a la base de datos de GRASS GIS desde R (o RStudio). \n\nNecesitamos iniciar GRASS GIS con initGRASS() desde R\nAccedemos a los módulos GRASS GIS a través de execGRASS()\n\nusamos read_VECT(), read_RAST(), write_VECT() y write_RAST() para leer datos desde y hacia la base de datos GRASS.\n\n\n\n\n\n\n\nNota\n\n\n\nOriginalmente, rgrass estaba destinado a aplicar funciones de GRASS en datos fuera de la base de datos de GRASS; de ahí que algunos prefieran crear proyectos (i.e., locations) desechables o temporarios."
  },
  {
    "objectID": "unidad_5/grass_and_r_sdm.html#iniciamos-grass",
    "href": "unidad_5/grass_and_r_sdm.html#iniciamos-grass",
    "title": "R y GRASS: Modelado de nicho",
    "section": "Iniciamos GRASS",
    "text": "Iniciamos GRASS\nUsaremos la opción B, es decir, iniciamos GRASS GIS desde R en un proyecto y mapset existentes. Notar las similitudes con gj.init() de grass.jupyter y gs.setup.init() de grass.script.\n\n# path to GRASS binaries (run `grass --config path`)\ngrassbin &lt;- system(\"grass --config path\", intern = TRUE)\n# path to GRASS database\ngrassdata &lt;- path.expand(\"~/grassdata/\")\n# path to project\nproject &lt;- \"posgar2007_4_cba\"\n# path to mapset\nmapset &lt;- \"PERMANENT\"\n\n# start GRASS GIS from R\ninitGRASS(gisBase = grassbin, \n          gisDbase = grassdata, \n          location = project, \n          mapset = mapset, \n          override = TRUE,\n          remove_GISRC= TRUE)\n\nExploramos los mapas raster y vectoriales disponibles en el mapset PERMANENT:\n\nr &lt;- execGRASS(\"g.list\", \n               parameters = list(type = \"raster\",\n                                 mapset = \".\"))\nv &lt;- execGRASS(\"g.list\", \n               parameters = list(type = \"vector\",\n                                 mapset = \".\"))"
  },
  {
    "objectID": "unidad_5/grass_and_r_sdm.html#disclaimer",
    "href": "unidad_5/grass_and_r_sdm.html#disclaimer",
    "title": "R y GRASS: Modelado de nicho",
    "section": "Disclaimer",
    "text": "Disclaimer\nThis is only a simple example for doing SDM and only the beginning… There are:\n\nother models to test\nhyper-parameter tuning\nensemble modeling\nuncertainty assessment: where we can predict with confidence\nmany other relevant packages:\n\n\ndismo, sdm, kuenm, caret, CAST, etc."
  },
  {
    "objectID": "unidad_5/grass_and_r_sdm.html#lectura-de-datos-vectoriales",
    "href": "unidad_5/grass_and_r_sdm.html#lectura-de-datos-vectoriales",
    "title": "R y GRASS: Modelado de nicho",
    "section": "Lectura de datos vectoriales",
    "text": "Lectura de datos vectoriales\nAhora leemos desde GRASS los datos de ocurrencia y los puntos de background, los convertimos en objetos sf y los mostramos con mapview.\n\n# Read vector layers\npresence &lt;- st_as_sf(read_VECT(\"aedes_aegypti\"))\nbackground &lt;- st_as_sf(read_VECT(\"background_points\"))"
  },
  {
    "objectID": "unidad_5/grass_and_r_sdm.html#lectura-de-datos-ráster",
    "href": "unidad_5/grass_and_r_sdm.html#lectura-de-datos-ráster",
    "title": "R y GRASS: Modelado de nicho",
    "section": "Lectura de datos ráster",
    "text": "Lectura de datos ráster\nLeemos ahora algunas de las variables que derivamos de las series temporales de LST y NDVI.\n\n# List rasters by pattern\nworldclim &lt;- execGRASS(\"g.list\", \n                       parameters = list(type = \"raster\", \n                                         pattern = \"worldclim*\"))\navg &lt;- execGRASS(\"g.list\", \n                 parameters = list(type = \"raster\", \n                                   pattern = \"avg*\"))\nmedian &lt;- execGRASS(\"g.list\", \n                    parameters = list(type = \"raster\", \n                                      pattern = \"median*\", \n                                      exclude = \"*[1-5]\"))\n\n# Concatenate map lists\nto_import &lt;- c(attributes(worldclim)$resOut, \n               attributes(avg)$resOut, \n               attributes(median)$resOut)\n\n# Read raster layers\npredictors &lt;- list()\nfor (i in to_import){ \n  predictors[i] &lt;- read_RAST(i) }\n\n# Stack rasters\npredictors_r &lt;- rast(predictors)\n\nVisualicemos los mapas importados. Convertimos el objeto terra en raster porque mapview aún no es compatible con terra.\n\n# Quick visualization in mapview\nmapview(raster::raster(predictors_r[['worldclim_bio01']])) + presence"
  },
  {
    "objectID": "unidad_5/grass_and_r_sdm.html#preparación-de-los-datos",
    "href": "unidad_5/grass_and_r_sdm.html#preparación-de-los-datos",
    "title": "R y GRASS: Modelado de nicho",
    "section": "Preparación de los datos",
    "text": "Preparación de los datos\nAhora que hemos creado y/o importado los registros de presencia, los puntos de background y las variables predictivas, necesitamos preparar los datos en un formato llamado samples with data (SWD). Éste es básicamente una tabla con coordenadas de presencia y background más los valores correspondientes a las variables predictoras para cada punto.\n\n# Variables for models\nsp &lt;- \"Aedes aegypti\"\npresence_coords &lt;- st_coordinates(presence)\nbackground_coords &lt;- background\nenv &lt;- predictors_r\n\n# Prepare data: SWD\ndata_sp &lt;- prepareSWD(species = sp, \n                      p = presence_coords, \n                      a = background_coords, \n                      env = env)\n\ndata_sp"
  },
  {
    "objectID": "unidad_5/grass_and_r_sdm.html#definición-de-parámetros",
    "href": "unidad_5/grass_and_r_sdm.html#definición-de-parámetros",
    "title": "R y GRASS: Modelado de nicho",
    "section": "Definición de parámetros",
    "text": "Definición de parámetros\nAquí definimos algunos de los valores de entrada necesarios para el flujo de trabajo:\n\nseed=123\nperc_test = 0.2\nk = 4\nmethod=\"Maxent\"\ncor_th=0.7\nperm=10\nimp_th=10"
  },
  {
    "objectID": "unidad_5/grass_and_r_sdm.html#datos-de-entrenamiento-y-evaluación",
    "href": "unidad_5/grass_and_r_sdm.html#datos-de-entrenamiento-y-evaluación",
    "title": "R y GRASS: Modelado de nicho",
    "section": "Datos de entrenamiento y evaluación",
    "text": "Datos de entrenamiento y evaluación\nEntrenaremos el modelo con un 80% de muestras de presencia, y dejaremos el 20% restante para la evaluación al final.\n\n# Create training and test sets\nc(train_sp, test_sp) %&lt;-% \n  trainValTest(data_sp, \n               test = perc_test,\n               only_presence = TRUE, \n               seed = seed)\n\n\ntrain_sp\n\n\ntest_sp"
  },
  {
    "objectID": "unidad_5/grass_and_r_sdm.html#creación-de-folds-para-validación-cruzada",
    "href": "unidad_5/grass_and_r_sdm.html#creación-de-folds-para-validación-cruzada",
    "title": "R y GRASS: Modelado de nicho",
    "section": "Creación de folds para validación cruzada",
    "text": "Creación de folds para validación cruzada\nComo usaremos validación cruzada durante el entrenamiento del modelo, creamos los folds con anticipación. En este caso utilizamos folds aleatorios, pero existen otros métodos de determinarlos. Como estamos limitados por la cantidad de registros de presencia, crearemos solo 4 folds o subconjuntos. El algoritmo utilizará iterativamente 3 subconjuntos para entrenar y 1 para validar, pero siempre dentro del entrenamiento.\n\n# Create folds \nran_folds &lt;- randomFolds(train_sp, \n                         k = k,\n                         only_presence = TRUE, \n                         seed = seed)"
  },
  {
    "objectID": "unidad_5/grass_and_r_sdm.html#entrenamiento-con-validación-cruzada",
    "href": "unidad_5/grass_and_r_sdm.html#entrenamiento-con-validación-cruzada",
    "title": "R y GRASS: Modelado de nicho",
    "section": "Entrenamiento con validación cruzada",
    "text": "Entrenamiento con validación cruzada\nPrimero entrenaremos un llamado modelo completo, es decir, un modelo con todos los predictores, y de allí eliminaremos aquellos que estén altamente correlacionados y cuya contribución a la predicción no sea importante.\n\n# Train a full model\nfull_model_sp &lt;- train(method = method,\n                       data = train_sp, \n                       folds = ran_folds)\n\nfull_model_sp\n\nVeamos las predicciones geográficas del modelo completo o full model\n\npred_full_model &lt;- predict(full_model_sp,\n                           data = env,\n                           type = \"cloglog\")\n\nmapview(raster::raster(pred_full_model))"
  },
  {
    "objectID": "unidad_5/grass_and_r_sdm.html#selección-de-variables",
    "href": "unidad_5/grass_and_r_sdm.html#selección-de-variables",
    "title": "R y GRASS: Modelado de nicho",
    "section": "Selección de variables",
    "text": "Selección de variables\nRemover variables altamente correlacionadas\nLuego procedemos a eliminar los predictores correlacionados ya que proporcionan información altamente redundante y pueden afectar el rendimiento de los modelos, es decir, como con todos los modelos, queremos que sea simple y del mayor rendimiento posible. Usaremos el área bajo la curva ROC (AUC) como métrica de rendimiento y eliminaremos las variables correlacionadas solo si el AUC disminuye si las mantenemos.\n\n# Prepare background locations to test correlation\nbg_sp &lt;- prepareSWD(species = sp, \n                    a = background_coords,\n                    env = env)\n\n# Remove variables with correlation higher than 0.7 \n# while accounting for the AUC\nvs_sp &lt;- varSel(full_model_sp,\n                metric = \"auc\", \n                bg4cor = bg_sp, \n                cor_th = cor_th,\n                permut = perm,\n                interactive = FALSE)\n\nExploremos el objeto de salida\n\nvs_sp@data\n\nRemover variables de menor importancia\nDespués de descartar las variables correlacionadas, también eliminaremos las variables que tengan una contribución porcentual o una importancia inferior al 10%, considerando como su mantenimiento o remoción afecta al AUC.\n\n# remove less important variables only if auc does not decrease\nreduc_var_sp &lt;- reduceVar(vs_sp,\n                          th = imp_th, \n                          metric = \"auc\", \n                          test = TRUE, \n                          permut = perm, \n                          use_jk = TRUE,\n                          interactive = FALSE)\n\nExploremos el objeto resultante\n\nreduc_var_sp\n\nAhora necesitamos recrear el objeto SWD y los conjuntos de datos de entrenamiento y evaluación, pero solo con las variables seleccionadas, para poder ejecutar el modelo final y hacer predicciones.\n\n# Get only relevant variables from the reduced model\nretained_varnames &lt;- names(reduc_var_sp@models[[1]]@data@data)\n\n# Subset stack\nenv &lt;- terra::subset(env, retained_varnames)\n\n# SWD with the selected vars\nsubset_train_sp &lt;- prepareSWD(species = sp, \n                              p = presence_coords,\n                              a = background_coords,\n                              env = env)\n\nc(train_sp, test_sp) %&lt;-% \n  trainValTest(subset_train_sp, \n               test = perc_test, \n               only_presence = TRUE, \n               seed = seed)"
  },
  {
    "objectID": "unidad_5/grass_and_r_sdm.html#predicciones-con-el-modelo-seleccionado",
    "href": "unidad_5/grass_and_r_sdm.html#predicciones-con-el-modelo-seleccionado",
    "title": "R y GRASS: Modelado de nicho",
    "section": "Predicciones con el modelo seleccionado",
    "text": "Predicciones con el modelo seleccionado\nAhora entrenamos el modelo final con el conjunto de entrenamiento completo, ya no necesitamos los folds en este punto. Tengan en cuenta que también utilizamos las feature classes (fc) y la regularización (reg) del mejor modelo obtenido anteriormente. En este caso, son solo valores predeterminados, pero si también realizamos una optimización de hiperparámetros, pueden diferir.\n\nfinal_model_sp &lt;- train(method = method, \n                        data = train_sp,\n                        fc = reduc_var_sp@models[[1]]@model@fc,\n                        reg = reduc_var_sp@models[[1]]@model@reg)\n\n\n\n\n\n\n\nNota\n\n\n\nSi les interesa conocer opciones de optimización de hiperparámetros en el contexto de los SDM, puedes chequear el siguiente artículo: https://consbiol-unibern.github.io/SDMtune/articles/tune-hyperparameters.html\n\n\nHagamos las predicciones en el espacio geográfico y exploremos el resultado\n\nmap_sp_maxent &lt;- predict(final_model_sp,\n                         data = env, \n                         type = \"cloglog\")\n\nmapview(raster::raster(map_sp_maxent))"
  },
  {
    "objectID": "unidad_5/grass_and_r_sdm.html#write-result-back-to-grass",
    "href": "unidad_5/grass_and_r_sdm.html#write-result-back-to-grass",
    "title": "R y GRASS: Modelado de nicho",
    "section": "Write result back to GRASS",
    "text": "Write result back to GRASS\nWe can now write the raster with the final model’s predictions into the GRASS database.\n\nwrite_RAST(map_sp_maxent, \n           \"Aedes_albopictus_maxent\", \n           flags = c(\"o\",\"overwrite\"))\n\nCheck the map is there\n\nexecGRASS(\"g.list\", \n          parameters = list(type=\"raster\",\n                            pattern=\"Aedes*\"))"
  },
  {
    "objectID": "unidad_5/grass_and_r_sdm.html#model-evaluation",
    "href": "unidad_5/grass_and_r_sdm.html#model-evaluation",
    "title": "R y GRASS: Modelado de nicho",
    "section": "Model evaluation",
    "text": "Model evaluation\nWe want to know how good our model is, so in this step we use the test dataset that we separated in the beginning. An AUC of 0.5 would mean the model performs like flipping a coin. AUC is what we call a threshold independent evaluation metric.\n\n# AUC\nauc_maxent &lt;- auc(final_model_sp, test = test_sp)\nauc_maxent\n\nUsually, however, the result of SDM is converted into presence/absence maps. To determine which threshold to use we perform threshold dependent evaluations.\n\n# Threshold dependent evaluation\nth_maxent &lt;- thresholds(final_model_sp, \n                        type = \"cloglog\", \n                        test = test_sp)\n\nknitr::kable(th_maxent, format = 'html', digits = 2)\n\nLet’s choose one threshold and create a binary map\n\np = map_sp_maxent &gt;= 0.5\na = map_sp_maxent &lt; 0.5\nmap_sp_maxent[p] &lt;- 1\nmap_sp_maxent[a] &lt;- 0\n\nmapview(raster::raster(map_sp_maxent))"
  },
  {
    "objectID": "unidad_5/grass_and_r_sdm.html#variable-importance",
    "href": "unidad_5/grass_and_r_sdm.html#variable-importance",
    "title": "R y GRASS: Modelado de nicho",
    "section": "Variable importance",
    "text": "Variable importance\nVariable importance is an indicator of variable contribution to prediction.\n\nvi_model_sp &lt;- maxentVarImp(final_model_sp)\nvi_model_sp\n\n\nplotVarImp(vi_model_sp)"
  },
  {
    "objectID": "unidad_5/grass_and_r_sdm.html#response-curves",
    "href": "unidad_5/grass_and_r_sdm.html#response-curves",
    "title": "R y GRASS: Modelado de nicho",
    "section": "Response curves",
    "text": "Response curves\nResponse curves give us an idea of the relationship between predictor variables and probability of occurrence.\n\nmy_rp &lt;- function(i){\n  plotResponse(reduc_var_sp, i)\n}\n\nplotlist &lt;- lapply(retained_varnames, my_rp)\nlabels &lt;- LETTERS[1:length(retained_varnames)]\nggpubr::ggarrange(plotlist = plotlist, labels = labels)\n\nWe close the mapset and done\n\n# close the mapset\nunlink_.gislock()"
  },
  {
    "objectID": "unidad_5/grass_and_r_sdm.html#vamos-a-r",
    "href": "unidad_5/grass_and_r_sdm.html#vamos-a-r",
    "title": "R y GRASS: Modelado de nicho",
    "section": "Vamos a R",
    "text": "Vamos a R\nCargamos los paquetes necesarios\n\nlibrary(rgrass)\nlibrary(sf)\nlibrary(terra)\nlibrary(mapview)\nlibrary(biomod2)\nlibrary(dismo)\nlibrary(usdm)\nlibrary(SDMtune)\nlibrary(zeallot)\nlibrary(tmap)\nlibrary(tmaptools)"
  },
  {
    "objectID": "unidad_5/grass_and_r_sdm.html#guardamos-la-predicción-en-grass",
    "href": "unidad_5/grass_and_r_sdm.html#guardamos-la-predicción-en-grass",
    "title": "R y GRASS: Modelado de nicho",
    "section": "Guardamos la predicción en GRASS",
    "text": "Guardamos la predicción en GRASS\nAhora podemos escribir el ráster con las predicciones del modelo final en la base de datos de GRASS.\n\nwrite_RAST(map_sp_maxent, \n           \"Aedes_aegypti_maxent\", \n           flags = c(\"o\",\"overwrite\"))\n\nCorroboramos que el mapa creado esté allí\n\nexecGRASS(\"g.list\", \n          parameters = list(type=\"raster\",\n                            pattern=\"Aedes*\"))"
  },
  {
    "objectID": "unidad_5/grass_and_r_sdm.html#evaluación-del-modelo",
    "href": "unidad_5/grass_and_r_sdm.html#evaluación-del-modelo",
    "title": "R y GRASS: Modelado de nicho",
    "section": "Evaluación del modelo",
    "text": "Evaluación del modelo\nQueremos saber qué tan bueno es nuestro modelo, por eso en este paso usamos el conjunto de datos de evaluación que separamos al principio. Un AUC de 0,5 significaría que el modelo funciona equivalentemente a lanzar una moneda al aire. AUC es lo que llamamos una métrica de evaluación independiente de umbral.\n\n# AUC\nauc_maxent &lt;- auc(final_model_sp, test = test_sp)\nauc_maxent\n\nNormalmente el resultado del SDM se convierte en mapas de presencia/ausencia. Para determinar qué umbral utilizar, realizamos evaluaciones dependientes del umbral.\n\n# Threshold dependent evaluation\nth_maxent &lt;- thresholds(final_model_sp, \n                        type = \"cloglog\", \n                        test = test_sp)\n\nknitr::kable(th_maxent, format = 'html', digits = 2)\n\nElegimos un umbral y creamos un mapa binario, i.e., de presencia y ausencia\n\np = map_sp_maxent &gt;= 0.5\na = map_sp_maxent &lt; 0.5\nmap_sp_maxent[p] &lt;- 1\nmap_sp_maxent[a] &lt;- 0\n\nmapview(raster::raster(map_sp_maxent))"
  },
  {
    "objectID": "unidad_5/grass_and_r_sdm.html#importancia-de-las-variables",
    "href": "unidad_5/grass_and_r_sdm.html#importancia-de-las-variables",
    "title": "R y GRASS: Modelado de nicho",
    "section": "Importancia de las variables",
    "text": "Importancia de las variables\nLa importancia de las variables es un indicador de la contribución variable a la predicción.\n\nvi_model_sp &lt;- maxentVarImp(final_model_sp)\nvi_model_sp\n\n\nplotVarImp(vi_model_sp)"
  },
  {
    "objectID": "unidad_5/grass_and_r_sdm.html#cuervas-de-respuesta",
    "href": "unidad_5/grass_and_r_sdm.html#cuervas-de-respuesta",
    "title": "R y GRASS: Modelado de nicho",
    "section": "Cuervas de respuesta",
    "text": "Cuervas de respuesta\nLas curvas de respuesta nos dan una idea de la relación entre las variables predictoras y la probabilidad de ocurrencia del evento de interés.\n\nmy_rp &lt;- function(i){\n  plotResponse(reduc_var_sp, i)\n}\n\nplotlist &lt;- lapply(retained_varnames, my_rp)\nlabels &lt;- LETTERS[1:length(retained_varnames)]\nggpubr::ggarrange(plotlist = plotlist, labels = labels)\n\nCerramos el mapset y terminamos :)\n\n# close the mapset\nunlink_.gislock()"
  },
  {
    "objectID": "index.html#dia-1-localmente",
    "href": "index.html#dia-1-localmente",
    "title": "Procesamiento y análisis de series temporales con GRASS GIS",
    "section": "Dia 1: localmente",
    "text": "Dia 1: localmente\nPara el primer día del curso, necesitamos ejecutar GRASS GIS de manera local. Si bien la mayor parte del material del taller se puede ejecutar teóricamente en todas las plataformas, algunas partes requieren herramientas que suelen ser más difíciles de configurar en Windows. Por lo tanto, para quien desee ejecutar todo el curso de manera local recomendamos usar entornos Linux/Unix.\n\nSoftware necesario\n\nGRASS GIS &gt;= v8.2.0\nPython &gt;= 3.7 con los siguientes paquetes:\n\njupyterlab, numpy, matplotlib, seaborn, scikit-learn, scipy, pandas, folium\n\nR &gt;= 4.2 con los siguientes paquetes:\n\nrgrass, sf, terra, raster, mapview, SDMtune, biomod2, dismo, usdm, zeallot, ggpubr, rJava\n\nQGIS\n\n\nNota para usuarios Ubuntu\nUsar el PPA inestable de ubuntugis para obtener la última versión de GRASS GIS:\nsudo add-apt-repository ppa:ubuntugis/ubuntugis-unstable\nsudo apt update\nsudo apt install grass grass-gui grass-dev\n\n\n\nDatos necesarios\n\nDatos de muestra:\n\nhttps://grass.osgeo.org/sampledata/north_carolina/nc_spm_08_grass7.zip"
  },
  {
    "objectID": "index.html#día-2-al-5-online",
    "href": "index.html#día-2-al-5-online",
    "title": "Procesamiento y análisis de series temporales con GRASS GIS",
    "section": "Día 2 al 5: online",
    "text": "Día 2 al 5: online\nEl resto del curso se ejecutará en línea ya sea dentro de la plataforma Whole Tale o en Google Colab.\nWhole Tale es una iniciativa de la Data Infrastructure Building Block (DIBBS) financiada por NSF para construir una plataforma escalable y multiusuario de código abierto, basada en la web para investigaciones reproducibles. Permite la creación, publicación y ejecución de tales: objetos de investigación ejecutables que capturan datos, código y el entorno de software completo utilizado para producir los resultados de la investigación. También es fantástico para enseñar, ya que los participantes no necesitan instalar todos los paquetes de software necesarios. ¡Solo necesitan registrarse con un correo electrónico institucional o personal y ya están listos para comenzar!\nWhole Tale:\n\nIr a Curso GRASS GIS 2023\nLog in (hay diferentes opciones)\nEjecutar la Tale (botón azul arriba a la derecha)\nConfirmar Copy y Run Tale\nSi sigue mostrando “Importing…”, recargar\nRun Tale\n\nGoogle Colab:\n\nFile -&gt; Open notebook\nSeleccionar Github\nPegar https://github.com/veroandreo/curso-grass-gis/blob/main/install_colab.ipynb\n\nEn Google Colab no tenemos preinstalado el software necesario, así que necesitarás ejecutar la notebook para instalarlo."
  },
  {
    "objectID": "unidad_5/grass_and_r_sdm.html#datos-de-presenciaocurrencia",
    "href": "unidad_5/grass_and_r_sdm.html#datos-de-presenciaocurrencia",
    "title": "R y GRASS: Modelado de nicho",
    "section": "Datos de presencia/ocurrencia",
    "text": "Datos de presencia/ocurrencia\nPara este ejercicio vamos a generar los puntos de ocurrencia del mosquito Aedes aegypti como un sub-conjunto al azar de las localidades (áreas edificadas) de la provincia de Córdoba que estén a una altura de menos de 850 m. Notar que estamos trabajando en la base de datos de GRASS GIS, pero desde R.\n\n# Extract centroids from built-up area polygons\nexecGRASS(\"v.extract\", \n          parameters = list(input=\"area_edificada_cba\", \n                            type=\"centroid\", \n                            output=\"area_edificada_cba_centroides\", \n                            random=250))\n\n# convert centroids to points\nexecGRASS(\"v.type\", \n          parameters = list(input=\"area_edificada_cba_centroides\", \n                            output=\"area_edificada_cba_puntos\", \n                            from_type=\"centroid\", \n                            to_type=\"point\"))\n\n# extract elevation data for points\nexecGRASS(\"v.what.rast\", \n          parameters = list(map=\"area_edificada_cba_puntos\", \n                            raster=\"elevation\", \n                            column=\"elevation\"))\n\n# filter points by elevation, keep those &lt;= 850m\nexecGRASS(\"v.extract\",\n          parameters = list(input=\"area_edificada_cba_puntos\",\n                            where=\"elevation &lt;= 850\",\n                            output=\"aedes_aegypti\"))\n\nAhora leemos desde GRASS los datos de ocurrencia que generamos, los convertimos en un objeto sf, y mostramos el mapa con mapview.\n\n# Read vector layers\npresence &lt;- st_as_sf(read_VECT(\"aedes_aegypti\"))\n\nTambién podemos usar la función plot() para visualizar la geometría o la geometría y los atributos (o una selección de los mismos) de los objetos sf.\n\n# Plot only the geometry \nplot(st_geometry(presence))\n\n# Plot geometry + attr\nplot(presence[\"elevation\"])"
  },
  {
    "objectID": "unidad_5/grass_and_r_sdm.html#datos-de-background",
    "href": "unidad_5/grass_and_r_sdm.html#datos-de-background",
    "title": "R y GRASS: Modelado de nicho",
    "section": "Datos de background",
    "text": "Datos de background\nEl algoritmo MaxEnt que vamos a usar en este ejercicio, requiere contrastar las variables ambientales en los sitios de ocurrencia con el resto del ambiente disponible para la especie, el background. Entonces, necesitamos generar puntos de background para caracterizar este ambiente disponible.\nUna opción es generar puntos al azar sobre nuestra área de estudio. No obstante, no es cierto que toda la extensión del área de estudio está disponible para Aedes aegypti. Esta especie de mosquito no cría en aguas abiertas y tampoco sobre las salinas. Entonces, vamos a enmascarar primero esas áreas del ambiente disponible.\n\n# Check region\ngmeta()\n\n\n# Generar máscara a partir del raster de LULC\nexpression &lt;- \n  \"no_water = if(landcover_2018 == 7 || landcover_2018 == 8, null(), landcover_2018)\"\n\nexecGRASS(\"r.mapcalc\",\n          parameters = list(expression=expression))\n\nLuego, leemos a R la máscara creada para visualizarla\n\n# Import mask\nno_water &lt;- raster(read_RAST(\"no_water\"))\nmapview(no_water)\n\nComo la región tiene una resolución de 30 m, vamos a llevarla a 1 km, para asegurarnos una mejor separación de los puntos de background, y volvemos a leer la máscara dentro de R.\n\n# Change resolution\nexecGRASS(\"g.region\",\n          parameters = list(res=\"1000\"),\n          flags = c(\"a\",\"p\"))\n\n# Upscale\nexecGRASS(\"r.resamp.stats\",\n          parameters = list(input=\"no_water\",\n                            output=\"MASK\",\n                            method=\"mode\"))\n\n# Leer en R la mascara_spp que vive en GRASS\nmask &lt;- raster(read_RAST(\"MASK\"))\n\nAhora sí, generamos los puntos de background utilizando una función del paquete dismo(Hijmans et al. 2023) y los convertimos a sf para luego visualizarlos.\n\n# Generate random points within mask\nset.seed(123)\nbackground &lt;- randomPoints(mask = mask, \n                           n = 500)\n\n# Convert to sf to plot\nbackground_sf &lt;- st_as_sf(as.data.frame(background), \n                          coords = c(1,2), \n                          crs = st_crs(mask))\n\n:::{callout-caution title=“Pregunta”} Con qué funcion de GRASS podríamos haber hecho algo similar? :::\nVisualizamos interactivamente el mapa que usamos como máscara junto con los vectores de presencia y background.\nY también demostramos cómo obtener mapas con calidad para publicaciones usando la librería tmap (Tennekes 2018)\n\n# Aux data\nbbox &lt;- st_bbox(mask)\n\nfig_puntos &lt;- \n  tm_shape(mask, \n           bbox = bbox) +\n  tm_raster(title = \"Classes\") +\n  tm_shape(presence) +\n  tm_dots(size = 0.02) +\n  tm_layout(main.title = \"Aedes aegypti\",\n            main.title.fontface = \"italic\",\n            main.title.size = 0.7,\n            main.title.position = \"left\",\n            legend.show = TRUE,\n            legend.outside = TRUE)\n\ntmap_save(fig_puntos, \n          filename = \"fig_puntos_y_mascara.png\", \n          width = 1000, height = 1300)\n\n\n\nMapa generado con tmap"
  },
  {
    "objectID": "unidad_5/grass_and_r_sdm.html#variables-ambientales",
    "href": "unidad_5/grass_and_r_sdm.html#variables-ambientales",
    "title": "R y GRASS: Modelado de nicho",
    "section": "Variables ambientales",
    "text": "Variables ambientales\nAntes de leer las variables ambientales que obtuvimos a partir de las series de tiempo de LST y NDVI, vamos a generar dos mapas ráster que representan la distancia a fuentes de agua y rutas y caminos, respectivamente. Para eso, vamos a usar mapas ya disponibles en el mapset PERMANENT.\n\n# Patch water lines + water bodies\nexecGRASS(\"v.patch\",\n          parameters = list(input=\"lineas_aguas_continentales_perennes_cba,\n                            areas_aguas_continentales_perennes_cba,\n                            embalses\",\n                            output=\"lineas_y_cuerpos_de_agua_cba\"))\n\n# Convert to raster\nexecGRASS(\"v.to.rast\",\n          parameters = list(input=\"lineas_y_cuerpos_de_agua_cba\",\n                            output=\"lineas_y_cuerpos_de_agua_cba\",\n                            use=\"val\"))\n\n# Distance to water and roads\nexecGRASS(\"r.grow.distance\",\n          parameters = list(input=\"lineas_y_cuerpos_de_agua_cba\",\n                            distance=\"distancia_agua\"))\n\n\n# Patch primary + secondary roads\nexecGRASS(\"v.patch\",\n          parameters = list(input=\"vial_primaria_cba,vial_secundaria_cba\",\n                            output=\"red_vial_cba\"))\n# Convert to raster\nexecGRASS(\"v.to.rast\",\n          parameters = list(input=\"red_vial_cba\",\n                            output=\"red_vial_cba\",\n                            use=\"val\"))\n\n# Distance to roads\nexecGRASS(\"r.grow.distance\",\n          parameters = list(input=\"red_vial_cba\",\n                            distance=\"distancia_caminos\"))\n\nLeemos los mapas generados y los visualizamos con plot(), que en este caso reconoce los objetos SpatRast.\n\ndistancia_agua &lt;- read_RAST(\"distancia_agua\")\ndistancia_caminos &lt;- read_RAST(\"distancia_caminos\")\n\nplot(c(distancia_agua,distancia_caminos), \n     main=c(\"Distancia agua\", \"Distancia rutas\"))\n\nTambién podemos usar tmap y su función tm_facets()\n\ndistancia &lt;- read_RAST(c(\"distancia_agua\",\"distancia_caminos\"))\n\nfig_raster_facet &lt;- \n  tm_shape(distancia, \n           bbox = bbox) +\n  tm_raster(style = \"cont\",\n            palette = \"magma\",\n            legend.show = FALSE) +\n  tm_facets()\n\nfig_raster_facet\n\nLectura de datos ráster de otros mapsets\nPara leer mapas de otros mapsets, necesitamos agregar esos mapsets a la lista de mapsets accesibles en el mapset donde estamos ahora.\n\nexecGRASS(\"g.mapsets\",\n          parameters = list(mapset=\"modis_lst\",\n                            operation=\"add\"))\nexecGRASS(\"g.mapsets\",\n          parameters = list(mapset=\"modis_ndvi\",\n                            operation=\"add\"))\nexecGRASS(\"g.mapsets\",\n          flags = \"p\")\n\nLeemos ahora algunas de las variables que derivamos de las series temporales de LST y NDVI. Primero, necesitamos aplicar la máscara de los límites de la provincia.\n\nexecGRASS(\"r.mask\", \n          parameters = list(vector=\"provincia_cba\"))\n\n\n# List rasters to import\nto_import &lt;- c(\"MOD11B3.A2018060.h12v12.single_LST_Day_6km\", \"MOD13C2.A2019335.006.single_Monthly_NDVI\")\n\n# Read raster layers\npredictors &lt;- list()\nfor (i in to_import){ \n  predictors[i] &lt;- read_RAST(i) }\n\nAgrupamos todos los rasters de variables ambientales.\n\n# Stack rasters\npredictors_r &lt;- rast(c(predictors,distancia))\ncapas &lt;- c(\"lst\", \"ndvi\", \"distancia_agua\", \"distancia_caminos\")\nnames(predictors_r) &lt;- capas\n\nVisualicemos los mapas importados. Convertimos el objeto terra en raster porque mapview aún no es compatible con terra.\n\n# Quick visualization in mapview\nmapview(raster(predictors_r$distancia_caminos)) + presence"
  },
  {
    "objectID": "bla.html",
    "href": "bla.html",
    "title": "how_to_run_this_course",
    "section": "",
    "text": "Hay múltiples opciones para ejecutar este curso: * Instalación local (preparar antes del taller) * Máquina Virtual OSGeoLive (preparación antes del taller) * Entorno en la nube (WholeTale o Google Colab)\n\n\nSi bien la mayor parte del material del taller se puede ejecutar teóricamente en todas las plataformas, algunas partes requieren herramientas que suelen ser más difíciles de configurar en Windows. Por lo tanto, recomendamos ejecutar este curso localmente en entornos Linux/Unix.\n\n\n\nGRASS GIS &gt;= v8.2.0\n\naddons\n\nPython &gt;= 3.7 con los siguientes paquetes:\n\njupyterlab, scipy, pandas, tqdm, folium\n\nR &gt;= 4.2 con los siguientes paquetes:\n\nrgrass, sf, terra, raster, mapview, SDMtune\n\n\nUna vez instalado el software, ejecutar:\ngit clone https://github.com/veroandreo/curso-grass-gis\ncd curso-grass-gis\njupyter lab\n\n\n\nUsuarios de Ubuntu: usar el PPA inestable de ubuntugis para obtener la última versión de GRASS GIS:\nsudo add-apt-repository ppa:ubuntugis/ubuntugis-unstable\nsudo apt update\nsudo apt install grass grass-dev\nDependiendo de la versión de GRASS, la instalación de complementos puede requerir el paquete subversion. Los complementos se pueden instalar con:\ngrass --tmp-location XY --exec g.extension r.futures\ngrass --tmp-location XY --exec g.extension r.mapcalc.tiled\n\n\n\n\nOSGeoLive nos permite probar una amplia variedad de otros programas geoespaciales de código abierto que pueden resultar útiles. Para configurar la VM, seguir estas instrucciones. Tener en cuenta que para configurar OSGeoLive es necesario descargar un archivo grande, lo que puede tardar un poco dependiendo de la conexión disponible, así que se recomienda planificar de antemano. No habrá sesión de instalación del software dentro del curso. Al configurar la VM, se deben especificar los recursos que la VM puede usar. Se recomienda usar al menos 4 cpus y, en general, más recursos darán como resultado una mejor experiencia.\nUna vez que OSGeoLive esté configurado, seguir estos pasos adicionales para prepararse para el curso:\n# install additional packages\nsudo apt -y install subversion parallel python-is-python3\n# install addons\ngrass --tmp-location XY --exec g.extension r.futures\ngrass --tmp-location XY --exec g.extension r.mapcalc.tiled\n# download course material\ngit clone https://github.com/veroandreo/curso-grass-gis\ncd curso-grass-gis\njupyter lab\n\n\n\nEl taller se puede realizar en línea en WholeTale y Google Colab. Esta es una forma conveniente, ya que no se necesita instalación; sin embargo, existen limitaciones de recursos; por ejemplo, Colab nos proporcionará solo 2 cpus.\n\n\nWholeTale es una plataforma web escalable, de código abierto para investigaciones reproducibles.\n\nGo to https://dashboard.wholetale.org/run/64c96871e6fabc2991d17f94\nLog in (there are different options)\nRun Tale (blue button at the top right)\nConfirm Copy and Run Tale\nIf it keeps showing Importing… try to reload\nRun Tale\n\n\n\n\nIn Colab: 1. File-&gt; Open notebook 2. Select Github 3. Paste https://github.com/ncsu-geoforall-lab/opengeohub-2023/blob/main/colab_notebook.ipynb\nEn Google Colab no tenemos preinstalado el software necesario, así que continúa y ejecuta la primera parte para instalarlo."
  },
  {
    "objectID": "bla.html#cómo-ejecutar-este-curso",
    "href": "bla.html#cómo-ejecutar-este-curso",
    "title": "how_to_run_this_course",
    "section": "",
    "text": "Hay múltiples opciones para ejecutar este curso: * Instalación local (preparar antes del taller) * Máquina Virtual OSGeoLive (preparación antes del taller) * Entorno en la nube (WholeTale o Google Colab)\n\n\nSi bien la mayor parte del material del taller se puede ejecutar teóricamente en todas las plataformas, algunas partes requieren herramientas que suelen ser más difíciles de configurar en Windows. Por lo tanto, recomendamos ejecutar este curso localmente en entornos Linux/Unix.\n\n\n\nGRASS GIS &gt;= v8.2.0\n\naddons\n\nPython &gt;= 3.7 con los siguientes paquetes:\n\njupyterlab, scipy, pandas, tqdm, folium\n\nR &gt;= 4.2 con los siguientes paquetes:\n\nrgrass, sf, terra, raster, mapview, SDMtune\n\n\nUna vez instalado el software, ejecutar:\ngit clone https://github.com/veroandreo/curso-grass-gis\ncd curso-grass-gis\njupyter lab\n\n\n\nUsuarios de Ubuntu: usar el PPA inestable de ubuntugis para obtener la última versión de GRASS GIS:\nsudo add-apt-repository ppa:ubuntugis/ubuntugis-unstable\nsudo apt update\nsudo apt install grass grass-dev\nDependiendo de la versión de GRASS, la instalación de complementos puede requerir el paquete subversion. Los complementos se pueden instalar con:\ngrass --tmp-location XY --exec g.extension r.futures\ngrass --tmp-location XY --exec g.extension r.mapcalc.tiled\n\n\n\n\nOSGeoLive nos permite probar una amplia variedad de otros programas geoespaciales de código abierto que pueden resultar útiles. Para configurar la VM, seguir estas instrucciones. Tener en cuenta que para configurar OSGeoLive es necesario descargar un archivo grande, lo que puede tardar un poco dependiendo de la conexión disponible, así que se recomienda planificar de antemano. No habrá sesión de instalación del software dentro del curso. Al configurar la VM, se deben especificar los recursos que la VM puede usar. Se recomienda usar al menos 4 cpus y, en general, más recursos darán como resultado una mejor experiencia.\nUna vez que OSGeoLive esté configurado, seguir estos pasos adicionales para prepararse para el curso:\n# install additional packages\nsudo apt -y install subversion parallel python-is-python3\n# install addons\ngrass --tmp-location XY --exec g.extension r.futures\ngrass --tmp-location XY --exec g.extension r.mapcalc.tiled\n# download course material\ngit clone https://github.com/veroandreo/curso-grass-gis\ncd curso-grass-gis\njupyter lab\n\n\n\nEl taller se puede realizar en línea en WholeTale y Google Colab. Esta es una forma conveniente, ya que no se necesita instalación; sin embargo, existen limitaciones de recursos; por ejemplo, Colab nos proporcionará solo 2 cpus.\n\n\nWholeTale es una plataforma web escalable, de código abierto para investigaciones reproducibles.\n\nGo to https://dashboard.wholetale.org/run/64c96871e6fabc2991d17f94\nLog in (there are different options)\nRun Tale (blue button at the top right)\nConfirm Copy and Run Tale\nIf it keeps showing Importing… try to reload\nRun Tale\n\n\n\n\nIn Colab: 1. File-&gt; Open notebook 2. Select Github 3. Paste https://github.com/ncsu-geoforall-lab/opengeohub-2023/blob/main/colab_notebook.ipynb\nEn Google Colab no tenemos preinstalado el software necesario, así que continúa y ejecuta la primera parte para instalarlo."
  },
  {
    "objectID": "unidad_5/grass_and_r_sdm.html#cómo-usamos-rgrass",
    "href": "unidad_5/grass_and_r_sdm.html#cómo-usamos-rgrass",
    "title": "R y GRASS: Modelado de nicho",
    "section": "Cómo usamos rgrass?",
    "text": "Cómo usamos rgrass?\nGRASS GIS y R se pueden utilizar juntos de dos maneras:\nA. Usar R dentro de una sesión de GRASS GIS, es decir, iniciar R (o RStudio) desde una sesión de GRASS\n\nescribimos R o rstudio & en la terminal GRASS GIS o en la pestaña Consola de la interfaz gráfica\nuna vez en R (o RStudio) cargamos el paquete rgrass (previo haberlo instalado)\nusamos read_VECT(), read_RAST() para leer datos de GRASS en R\naccedemos a los módulos y la base de datos de GRASS GIS a través de execGRASS()\n\nescribimos datos resultantes en la base de datos de GRASS con write_VECT() y write_RAST()\n\n\n\n\n\n\n\n\n\n\n\n\n\nB. Iniciar y usar GRASS GIS dentro de una sesión de R, es decir, nos conectamos a la base de datos de GRASS GIS desde R (o RStudio).\n\nPrimero cargamos el paquete rgrass\n\nNecesitamos iniciar GRASS GIS con initGRASS() desde R y para ello, necesitamos especificar el ejecutable de GRASS y las ubicaciones de la base de datos, el proyecto (location) y mapset\nAccedemos a los módulos GRASS GIS a través de execGRASS()\n\nusamos read_VECT(), read_RAST(), write_VECT() y write_RAST() para leer datos desde y hacia la base de datos GRASS.\n\n\n\n\n\n\n\n\n\n\n\nNota\n\n\n\nOriginalmente, rgrass estaba destinado a aplicar funciones de GRASS en datos fuera de la base de datos de GRASS; de ahí que algunos prefieran crear proyectos (i.e., locations) desechables o temporarios. Por ejemplo:\n\nlibrary(terra)\n\nf &lt;- system.file(\"ex/elev.tif\", package=\"terra\")\nr &lt;- rast(f)\n\nlibrary(rgrass)\ninitGRASS(home=tempdir(), SG=r, override=TRUE)"
  },
  {
    "objectID": "unidad_5/grass_and_r_sdm.html#curvas-de-respuesta",
    "href": "unidad_5/grass_and_r_sdm.html#curvas-de-respuesta",
    "title": "R y GRASS: Modelado de nicho",
    "section": "Curvas de respuesta",
    "text": "Curvas de respuesta\nLas curvas de respuesta nos dan una idea de la relación entre las variables predictoras y la probabilidad de ocurrencia del evento de interés.\n\nmy_rp &lt;- function(i){\n  plotResponse(reduc_var_sp, i)\n}\n\nplotlist &lt;- lapply(retained_varnames, my_rp)\nlabels &lt;- LETTERS[1:length(retained_varnames)]\nggpubr::ggarrange(plotlist = plotlist, labels = labels)\n\nCerramos el mapset y terminamos :)\n\n# close the mapset\nunlink_.gislock()"
  }
]