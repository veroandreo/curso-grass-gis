[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Procesamiento y análisis de series temporales con GRASS GIS",
    "section": "",
    "text": "Gran parte de la investigación en ecología y problemas asociados al ambiente en la actualidad requiere de conocimientos técnicos en el procesamiento avanzado de grandes conjuntos de datos espacio-temporales. En las dos últimas décadas se ha producido un cambio notable en la forma en que los datos se difunden de manera abierta y a través de Internet. Con esta libre disponibilidad de petabytes de datos de sensado remoto, modelos climáticos globales, redes de sensores y otros datos geoespaciales existe una urgente necesidad de formar usuarios en lo que respecta a su manejo eficiente y procesamiento. Las herramientas libres y de código abierto también han ganado gran popularidad y estabilidad, simultáneamente con la creciente cantidad de datos libres. Este curso abordará el procesamiento y análisis de datos espacio-temporales con GRASS GIS (https://grass.osgeo.org/).\nGRASS GIS es un software que nació hace 40 años y sigue siendo hoy en día uno de los SIG libre y de código abierto más potentes y versátiles. Sus prestaciones de alto nivel y sus capacidades analíticas tanto en el trabajo con datos vectoriales como en el trabajo con datos raster, hacen de GRASS una excelente herramienta para desempẽnar trabajos de análisis espacial o geográfico en muchos campos de aplicacíon, desde el análisis ambiental hasta el análisis de redes, pasando por la teledetección o la simulación de modelos. GRASS GIS consta de más de 500 módulos base a los que se adicionan cientos de complementos que permiten extender su potencialidad para el procesamiento de datos raster, vectoriales, ráster 3D y temporales. Por otra parte, GRASS GIS puede ser un potente SIG de escritorio o la columna vertebral de una infraestructura SIG dadas sus diferentes APIs. Proporciona interfaces a muchos otros programas en geoestadística, bases de datos, servicios de mapas web y otros SIG como por ejemplo QGIS. Más aún, GRASS GIS se utiliza en el ámbito académico, en el escenario comercial y también en instituciones públicas de todo el mundo para una amplia gama de aplicaciones."
  },
  {
    "objectID": "index.html#resumen",
    "href": "index.html#resumen",
    "title": "Procesamiento y análisis de series temporales con GRASS GIS",
    "section": "",
    "text": "TBD"
  },
  {
    "objectID": "index.html#contenidos",
    "href": "index.html#contenidos",
    "title": "Procesamiento y análisis de series temporales con GRASS GIS",
    "section": "Contenidos",
    "text": "Contenidos\n\nUnidad 1: Introducción a GRASS GIS\nUnidad 2: Análisis de datos raster y satelitales\n\nbla\nbla\n\nUnidad 3: OBIA\nUnidad 4: Series de tiempo\nUnidad 5: Modelado de nicho"
  },
  {
    "objectID": "index.html#software",
    "href": "index.html#software",
    "title": "Procesamiento y análisis de series temporales con GRASS GIS",
    "section": "Software",
    "text": "Software\nIf you still want to run the workshop locally, you’ll find instructions and requirements below.\n\nGRASS GIS\nWe will use GRASS GIS 8.2+. It can be installed either through standalone installers/binaries or through OSGeo-Live (a linux based virtual machine which includes all OSGeo software and packages).\n\nMS Windows\nThere are two different options to install GRASS GIS in MS Windows:\n\nStandalone installer 64-bit\nOSGeo4W 64-bit\n\nFor Windows users, we strongly recommend installing GRASS GIS through the OSGeo4W package (second option), since it allows to install all OSGeo software and resolves dependencies.\n\n\nUbuntu Linux\nInstall GRASS GIS 8.2+ from the “unstable” package repository:\n  sudo add-apt-repository ppa:ubuntugis/ubuntugis-unstable\n  sudo apt-get update\n  sudo apt-get install grass grass-gui grass-dev\n\n\nFedora, openSuSe Linux\nFor other Linux distributions including Fedora and openSuSe, simply install GRASS GIS with the respective package manager. See also here\n\n\nMac OS\nFind GRASS GIS binaries on http://grassmac.wikidot.com/ or install the latest available version from MacPorts.\n\n\nGRASS GIS Add-ons\n\nr.bioclim: Calculates bioclimatic indices as those in WorldClim.\n\nInstall with g.extension extension=name_of_addon\n\n\n\nR packages\nThe following R packages should be installed beforehand:\n  install.packages(c(\"rgrass\",\"terra\",\"sf\",\"raster\",\"mapview\",\"biomod2\",\"dismo\",\"usdm\",\"SDMtune\",\"zeallot\",\"rJava\",\"ggpubr\"))\n\n\nPython libraries\nThe following Python libraries should be installed beforehand:\n  pip install folium"
  },
  {
    "objectID": "index.html#data",
    "href": "index.html#data",
    "title": "Procesamiento y análisis de series temporales con GRASS GIS",
    "section": "Data",
    "text": "Data\nDownload the following ready to use location with reconstructed daily LST averages (Metz et al. (2017)) for Northern Italy. This dataset is courtesy of mundialis GmbH & Co. KG.\n\nNorthern Italy (1.7 Gb)\n\nWe will also use a points vector map representing Aedes albopictus presence data:\n\nMosquito occurrence data"
  },
  {
    "objectID": "index.html#references",
    "href": "index.html#references",
    "title": "Procesamiento y análisis de series temporales con GRASS GIS",
    "section": "References",
    "text": "References"
  },
  {
    "objectID": "unidad_1/unit1_index.html",
    "href": "unidad_1/unit1_index.html",
    "title": "GRASS GIS 2023",
    "section": "",
    "text": "En esta unidad vamos a ver dos presentaciones introductorias y otras dos con ejercicios para familiarizarnos principalmente con la interfaz gŕafica de GRASS GIS. Comencemos!\n\n\n\nVer en otra pestaña\n\n\nVer en otra pestaña\n\n\n\n\n\nVer en otra pestaña\n\n\nVer en otra pestaña"
  },
  {
    "objectID": "unidad_1/unit1_index.html#presentaciones-unidad-1",
    "href": "unidad_1/unit1_index.html#presentaciones-unidad-1",
    "title": "GRASS GIS 2023",
    "section": "",
    "text": "En esta unidad vamos a ver dos presentaciones introductorias y otras dos con ejercicios para familiarizarnos principalmente con la interfaz gŕafica de GRASS GIS. Comencemos!\n\n\n\nVer en otra pestaña\n\n\nVer en otra pestaña\n\n\n\n\n\nVer en otra pestaña\n\n\nVer en otra pestaña"
  },
  {
    "objectID": "unidad_1/intro_to_grass.html#references",
    "href": "unidad_1/intro_to_grass.html#references",
    "title": "Intro a GRASS GIS",
    "section": "Referencias",
    "text": "Referencias\n\n\nHaedrich, C., Petras, V., Petrasova, A., Blumentrath, S., y Mitasova, H. (2023), «Integrating GRASS GIS and Jupyter Notebooks to facilitate advanced geospatial modeling education», Transactions in GIS, 27, 686-702. https://doi.org/10.1111/tgis.13031.\n\n\nNeteler, M., Bowman, M. H., Landa, M., y Metz, M. (2012), «GRASS GIS: A multi-purpose open source GIS», Environmental Modelling & Software, 31, 124-130. https://doi.org/10.1016/j.envsoft.2011.11.014.\n\n\nNeteler, M., y Mitasova, H. (2013), Open source GIS: a GRASS GIS approach, Springer Science & Business Media.\n\n\nWhite, C. T., Petrasova, A., Petras, V., Tateosian, L. G., Vukomanovic, J., Mitasova, H., y Meentemeyer, R. K. (2023), «An open-source platform for geospatial participatory modeling in the cloud», Environmental Modelling & Software, 167, 105767. https://doi.org/10.1016/j.envsoft.2023.105767."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Verónica Andreo",
    "section": "",
    "text": "Verónica Andreo es Licenciada y Doctora en Ciencias Biológicas segresada de la Universidad Nacional de Río Cuarto (UNRC). Además, cuenta con una maestría en Aplicaciones de la Información Espacial de la Universidad Nacional de Córdoba (UNC). Desde 2018, se desempeña como investigadora de CONICET y docente de postgrado en el Instituto Gulich dependiente de la (CONAE) y la UNC.\nSu investigación esta enfocada en las aplicaciones del sensado remoto y los sistemas de información geográfica (SIG) a problemas relacionados con la Salud Pública y los reservorios y vectores de enfermedades. Su principal interés son los determinantes ambientales de la distribución y riesgo de las enfermedades vectoriales y zoonóticas, especialmente aquellos determinantes que pueden derivarse del análisis de imágenes satelitales, series de tiempo de productos satelitales y aprendizaje automático.\nVero forma parte del GRASS GIS Development team y desempeña el rol de chair del proyecto desde Febrero 2021. Además, es Charter member de OSGeo y promotora del software libre y de código abierto en general, y de FOSS4G en especial. Fue coordinadora del Comité de Programa de la FOSS4G 2021 que se realizó en Argentina. Entre otras cosas, ha sido voluntaria como mentora para GRASS GIS en el concurso Google Code-In introduciendo a estudiantes de secundaria en el mundo del software de código abierto. También dicta cursos y talleres introductorios y avanzados sobre los módulos temporales de GRASS GIS y sus aplicaciones.\n\n\n\n\nRemote sensing time series\nImage analysis\nGIS\nSDM\nVector-borne diseases\nFree and Open Source Software\n\n\n\n\n\nPhD in Biological Sciences. National University of Río Cuarto. 2012.\nMSc in Spatial Applications for Early Warning and Response to Emergencies. National University of Córdoba. 2015.\nBiologist. National University of Río Cuarto. 2005."
  },
  {
    "objectID": "about.html#fa-solid-dna-about",
    "href": "about.html#fa-solid-dna-about",
    "title": "Verónica Andreo",
    "section": "",
    "text": "Verónica Andreo es Licenciada y Doctora en Ciencias Biológicas segresada de la Universidad Nacional de Río Cuarto (UNRC). Además, cuenta con un una maestría en Aplicaciones de la Información Espacial de la Universidad Nacional de Córdoba (UNC).\nDesde 2018, se desempeña como investigadora de CONICET y docente de postgrado en el Instituto Gulich dependiente de la (CONAE) y la UNC.\nSu investigación esta enfocada en las aplicaciones del sensado remoto y los sistemas de información geográfica (SIG) a problemas relacionados con la Salud Pública y los reservorios y vectores de enfermedades. Su principal interés son los determinantes ambientales de la distribución y riesgo de las enfermedades vectoriales y zoonóticas, especialmente aquellos determinantes que pueden derivarse del análisis de imágenes satelitales, series de tiempo de productos satelitales y aprendizaje automático.\nVero forma parte del GRASS GIS Development team, desempeña el rol de chair del proyecto desde Febrero 2021. Además, es Charter member de OSGeo y promotora del software libre y de código abierto en general, y de\nFOSS4G en especial. Fue coordinadora del Comité de Programa de la FOSS4G 2021 que se realizó en Argentina. Entre otras cosas, ha sido voluntaria como mentora de GRASS GIS en el concurso Google Code-In introduciendo a estudiantes de secundaria en el mundo del software de código abierto. También dicta cursos y talleres introductorios y avanzados sobre los módulos temporales de GRASS GIS y sus aplicaciones. Para más detalles, visitar: https://veroandreo.gitlab.io/."
  },
  {
    "objectID": "about.html#fa-solid-heart-interests",
    "href": "about.html#fa-solid-heart-interests",
    "title": "Verónica Andreo",
    "section": "",
    "text": "Remote sensing time series\nImage analysis\nGIS\nSDM\nVector-borne diseases\nFree and Open Source Software"
  },
  {
    "objectID": "about.html#fa-solid-graduation-cap-education",
    "href": "about.html#fa-solid-graduation-cap-education",
    "title": "Verónica Andreo",
    "section": "",
    "text": "PhD in Biological Sciences. National University of Río Cuarto. 2012.\nMSc in Spatial Applications for Early Warning and Response to Emergencies. National University of Córdoba. 2015.\nBiologist. National University of Río Cuarto. 2005."
  },
  {
    "objectID": "unidad_2/imagery_data_in_grass.html",
    "href": "unidad_2/imagery_data_in_grass.html",
    "title": "Datos satelitales en GRASS GIS",
    "section": "",
    "text": "Los datos satelitales en general vienen en formato raster, por lo tanto aplican las mismas reglas que vimos anteriormente. Los comandos i.* se orientan explícitamente al procesamiento de datos satelitales aunque algunos puedan usarse para otros datos raster.\nPara ejemplificar el flujo de trabajo para procesamiento de datos satelitales en GRASS GIS, en esta primer sesión vamos a trabajar con datos del satélite Landsat 8.\nAntes de empezar y para ganar tiempo, conectamos nuestro drive e instalamos GRASS en Google Colab.\n# import drive from google colab\nfrom google.colab import drive\n# mount drive\ndrive.mount(\"/content/drive\")\n%%bash\nDEBIAN_FRONTEND=noninteractive \nsudo add-apt-repository ppa:ubuntugis/ubuntugis-unstable \napt update \napt install grass subversion grass-dev\napt remove libproj22\nChequeamos el path de instalación de GRASS\n!grass --config path\ne instalamos otras librerías de python que nos serán útiles.\n!pip install pygdal\n!pip install landsatxplore"
  },
  {
    "objectID": "unidad_2/imagery_data_in_grass.html#procesamiento-de-datos-satelitales-en-grass-gis",
    "href": "unidad_2/imagery_data_in_grass.html#procesamiento-de-datos-satelitales-en-grass-gis",
    "title": "Datos satelitales en GRASS GIS",
    "section": "",
    "text": "Nociones básicas sobre datos satelitales en GRASS GIS\nBúsqueda y descarga de datos Landsat\nCalibración y corrección atmosférica: de número digital a reflectancia\nAjuste de colores y composiciones RGB\nMáscara de nubes a partir de banda de calidad\nFusión de datos/Pansharpening\nÍndices espectrales de agua y vegetación\nClasificación no supervisada\n\n\n\n\nLos datos satelitales en general vienen en formato raster (fa?, arrow-right text-green) aplican las mismas reglas \n\nLos comandos *i.** se orientan explícitamente al procesamiento de datos satelitales (aunque algunos puedan usarse para otros datos raster)\n\nPara más detalles ver el manual Imagery Intro y la wiki Image Processing\n\n\n\nEscenas Landsat 8 (OLI)\n\nFechas: 14/01/2020 y 02/03/2020\nPath/Row: 229/082\nCRS: UTM zona 20 N (EPSG:32620)\n\n\n\n\nL8\n\n\nDescargar las escenas L8 14/01/2020 (979Mb) y L8 02/03/2020 (880Mb) y moverlas a $HOME/gisdata/landsat_data. No descomprimir!\n\n\n\n\n\n\n\nL8 vs L7 bands\n\n\nComparación entre las bandas de Landsat 7 ETM+ y Landsat 8 OLI. Fuente: https://landsat.gsfc.nasa.gov/landsat-data-continuity-mission/ y detalle de las bandas Landsat\n\n\n\nIniciar GRASS GIS, crear un nuevo mapset y establecer la región computacional\nIniciar GRASS GIS en posgar2007_4_cba/PERMANENT\n\n# paths\ngrassdata='/home/veroandreo/grassdata/'\nlocation='sa_latlong_wgs84'\nmapset='hansen_gfc_south_america'\n\n\nimport os\nimport subprocess\nimport sys\n\n# Ask GRASS GIS where its Python packages are to be able to start it from the notebook\nsys.path.append(\n    subprocess.check_output([\"grass\", \"--config\", \"python_path\"], text=True).strip()\n)\n\n# Importar los paquetes python de GRASS\nimport grass.script as gs\nimport grass.jupyter as gj\n\n# Iniciar GRASS\nsession = gj.init(grassdata, location, mapset)\n\nCorroborar la proyección\n\n# check the projection of the location\ng.proj -p\n\nCrear un nuevo mapset llamado landsat8\n\n# Create a new mapset\ng.mapset -c mapset=landsat8\n\nListar los mapsets accesibles\n\n# list all the mapsets in the search path\ng.mapsets -p\n\nListar los mapas vectoriales disponibles\n\n# list vector maps in all mapsets in the search path\ng.list type=vector\n\nExtraer el radio urbano de Córdoba\n\n# extract Cordoba urban area from `radios_urbanos`\nv.extract input=radios_urbanos \\\n  where=\"nombre == 'CORDOBA'\" \\\n  output=radio_urbano_cba\n\nEstablecer la región computacional al radio urbano de Córdoba\n\n# set the computational region to the extent of Cordoba urban area\ng.region -p vector=radio_urbano_cba\n\n\n\n\nInstalar la extensión i.landsat\n\n# install i.landsat toolset\ng.extension extension=i.landsat\n\nBuscar escenas de Landsat 8 disponibles\n\n# search for Landsat 8 scenes\ni.landsat.download -l settings=$HOME/gisdata/USGS_SETTING.txt \\\n  dataset=landsat_8_c1 clouds=35 \\\n  start='2019-10-27' end='2020-03-15'\n\nNO EJECUTAR! Descargar las escenas seleccionadas\n\n# download selected scenes\ni.landsat.download settings=$HOME/gisdata/USGS_SETTING.txt \\\n  id=LC82290822020062LGN00,LC82290822020014LGN00 \\\n  output=$HOME/gisdata/landsat_data\n\nImprimir las bandas dentro de la carpeta\n\n# print all landsat bands within landsat_data folder\ni.landsat.import -p input=$HOME/gisdata/landsat_data\n\nImprimir sólo las bandas seleccionadas con un patrón\n\n# print a selection of bands - might be sloooow\ni.landsat.import -p \\\n  input=$HOME/gisdata/landsat_data \\\n  pattern='B(2|3|4|5|6|8)'\n\nImportar bandas, recortar y reproyectar al vuelo\n\n# import all bands, subset to region and reproject\ni.landsat.import -r \\\n  input=$HOME/gisdata/landsat_data \\\n  extent=region\n\nListar bandas importadas y revisar metadatos\n\n# list raster maps\ng.list type=raster mapset=.\n\n# check metadata of some imported bands\nr.info map=LC08_L1TP_229082_20200114_20200127_01_T1_B4\nr.info map=LC08_L1TP_229082_20200114_20200127_01_T1_B8\n\n\n\n\n\n\n\n\n\n\n\n\nWorkflow\n\n\n\n\n\n\nLos datos L8 OLI vienen en 16-bit con rango de datos entre 0 y 65535.\ni.landsat.toar convierte ND en reflectancia TOA (y temperatura de brillo) para todos los sensores Landsat. Opcionalmente proporciona reflectancia de superficie (BOA) después de la corrección DOS.\ni.atcorr proporciona un método de corrección atmosférica más complejo para gran variedad de sensores (S6).\n\nDefinir region computacional a banda de 30m\n\n# set the region to a 30m band\ng.region -p raster=LC08_L1TP_229082_20200114_20200127_01_T1_B4\n\nConvertir DN a reflectancia superficial y temperatura - método DOS\n\n# convert from DN to surface reflectance and temperature - requires to uncompress data locally\ni.landsat.toar \\\n  input=LC08_L1TP_229082_20200114_20200127_01_T1_B \\\n  output=LC08_229082_20200114_toar_B \\\n  sensor=oli8 \\\n  metfile=$HOME/gisdata/landsat_data/LC08_L1TP_229082_20200114_20200127_01_T1_MTL.txt \\\n  method=dos1\n\nCorroborar info antes y después de la conversión para una banda\n\n# list output maps\ng.list type=raster mapset=. pattern=\"*toar*\"\n\n# check info before and after for one band\nr.info map=LC08_L1TP_229082_20200114_20200127_01_T1_B3\nr.info map=LC08_229082_20200114_toar_B3\n\n\nBanda 10 de L8 con la paleta de colores kelvin\n\nTarea:\nAhora, sigan los mismos pasos para la escena del 02/03/2020. Qué notan de diferente?\n\n\n\n\nAjuste de colores para una composición RGB color natural\n\n# enhance the colors\ni.colors.enhance \\\n  red=LC08_229082_20200114_toar_B4 \\\n  green=LC08_229082_20200114_toar_B3 \\\n  blue=LC08_229082_20200114_toar_B2 \\\n  strength=95\n\nMostrar la combinación RGB - d.rgb\n\n# display RGB\nd.mon wx0\nd.rgb \\\n  red=LC08_229082_20200114_toar_B4 \\\n  green=LC08_229082_20200114_toar_B3 \\\n  blue=LC08_229082_20200114_toar_B2\n\n\nTarea:\nSeguir los mismos pasos para una composición falso color 543. Sobre qué bandas debieran realizar el ajuste?\n\n \nComposiciones color natural 432 y falso color 543\n\n\n\n\nLandsat 8 proporciona una banda de calidad (QA) con valores enteros de 16 bits que representan las combinaciones de superficie, atmósfera y condiciones del sensor que pueden afectar la utilidad general de un determinado pixel.\nLa extensión i.landsat.qa reclasifica la banda QA de Landsat 8 de acuerdo a la calidad del pixel.\n\nMás información sobre la banda QA de L8:https://www.usgs.gov/core-science-systems/nli/landsat\nCrear las reglas para identificar las nubes y sombras de nubes\n\n# create a rule set\ni.landsat.qa \\\n  collection=1 \\\n  cloud_shadow_confidence=\"Medium,High\" \\\n  cloud_confidence=\"Medium,High\" \\\n  output=Cloud_Mask_rules.txt\n\nReclasificar la banda QA en función de las reglas\n\n# reclass the BQA band based on the rule set created\nr.reclass \\\n  input=LC08_L1TP_229082_20200114_20200127_01_T1_BQA \\\n  output=LC08_229082_20200114_Cloud_Mask \\\n  rules=Cloud_Mask_rules.txt\n\nReporte del porcentaje de nubes y sombras\n\n# report % of clouds and shadows\nr.report -e map=LC08_229082_20200114_Cloud_Mask units=p\n\nMostrar el mapa reclasificado\n\n# display reclassified map over RGB\nd.mon wx0\nd.rgb \\\n  red=LC08_229082_20200114_toar_B4 \\\n  green=LC08_229082_20200114_toar_B3 \\\n  blue=LC08_229082_20200114_toar_B2\nd.rast LC08_229082_20200114_Cloud_Mask\n\n\nTarea:\nComparar visualmente la cobertura de nubes con la composición RGB 543.\n\n \nComposición falso color y máscara de nubes\n\n\n\nVamos a usar la banda PAN (15 m) para mejorar la definición de las bandas espectrales de 30 m, por medio de:\n\ni.fusion.hpf, que aplica un método de adición basado en un filtro de paso alto\n\nOtros métodos están implementados en i.pansharpen\nInstalar la extensión i.fusion.hpf\n\n# Install the reqquired addon\ng.extension extension=i.fusion.hpf\n\nCambiar la región a la banda PAN\n\n# Set the region to PAN band (15m)\ng.region -p raster=LC08_229082_20200114_toar_B8\n\nEjecutar la fusión\n\n# Apply the fusion based on high pass filter\ni.fusion.hpf -l -c pan=LC08_229082_20200114_toar_B8 \\\n  msx=`g.list type=raster mapset=. pattern=*_toar_B[1-7] separator=,` \\\n  suffix=_hpf \\\n  center=high \\\n  modulation=max \\\n  trim=0.0\n\nListar los mapas resultantes usando un patrón de búsqueda\n\n# list the fused maps\ng.list type=raster mapset=. pattern=*_hpf\n\nVisualizar las diferencias con la herramienta mapswipe\n\n# display original and fused maps\ng.gui.mapswipe \\\n  first=LC08_229082_20200114_toar_B5 \\\n  second=LC08_229082_20200114_toar_B5_hpf\n\n\nDatos originales 30 m y datos fusionados 15 m\n\n\n\nEstablecer la máscara de nubes para evitar el cómputo sobre las nubes\n\n# Set the cloud mask to avoid computing over clouds\nr.mask raster=LC08_229082_20200114_Cloud_Mask\n\nCalcular el NDVI y establecer la paleta de colores\n\n# Compute NDVI\nr.mapcalc \\\n  expression=\"LC08_229082_20200114_NDVI = \\\n  (LC08_229082_20200114_toar_B5_hpf - LC08_229082_20200114_toar_B4_hpf) / \\\n  (LC08_229082_20200114_toar_B5_hpf + LC08_229082_20200114_toar_B4_hpf) * 1.0\"\n# Set the color palette\nr.colors map=LC08_229082_20200114_NDVI color=ndvi\n\nCalcular NDWI y establecer la paleta de colores\n\n# Compute NDWI\nr.mapcalc expression=\"LC08_229082_20200114_NDWI = \\\n  (LC08_229082_20200114_toar_B5_hpf - LC08_229082_20200114_toar_B6_hpf) / \\\n  (LC08_229082_20200114_toar_B5_hpf + LC08_229082_20200114_toar_B6_hpf) * 1.0\"\n# Set the color palette\nr.colors map=LC08_229082_20200114_NDWI color=ndwi\n\nMostrar los mapas\n\n# display maps in different monitors\nd.mon wx0\nd.rast map=LC08_229082_20200114_NDVI\n\nd.mon wx1\nd.rast map=LC08_229082_20200114_NDWI\n\n \nNDVI y NDWI a partir de datos Landsat 8\n\nTarea:\nEstimar NDVI y NDWI para la otra escena usando el módulo i.vi\n\n\n\n\n\nAgrupar las bandas (i.e., hacer un stack): i.group\nGenerar firmas para n número de clases: i.cluster\nClasificar: i.maxlik\n\nListar los mapas usando un patrón\n\n# list the bands needed for classification\ng.list type=raster mapset=. pattern=*_toar*_hpf\n\nCrear un grupo de imágenes o stack\n\n# add maps to an imagery group for easier management\ni.group group=l8 subgroup=l8 \\\n input=`g.list type=raster mapset=. pattern=*_toar*_hpf sep=\",\"`\n\nObtener estadísticos -firmas- para las n clases de interés con una muestra de pixeles\n\n# statistics for unsupervised classification\ni.cluster group=l8 subgroup=l8 \\\n sig=l8_hpf \\\n classes=7 \\\n separation=0.6\n\nRealizar la clasificación no supervisada de toda la imagen\n\n# Maximum Likelihood unsupervised classification\ni.maxlik group=l8 subgroup=l8 \\\n sig=l8_hpf \\\n output=l8_hpf_class \\\n rej=l8_hpf_rej\n\nMostrar el mapa clasificado\n\n# display results\nd.mon wx0\nd.rast map=l8_hpf_class\n\n\nInformación derivada adicional podría obtenerse con los siguientes módulos, entre otros:\n\nmedidas de textura: r.texture,\nmedidas de diversidad: r.diversity,\nestadísticas locales con información de contexto: r.neighbors,\ntransformación tasseled cap: i.tasscap,\netc.\n\n\n\n\n\nTopic classification en los manuales de GRASS GIS\nImage classification en la wiki\nEjemplos de clasificación en el curso dictado en Noruega en 2018\nClasificación con Random Forest en la presentación del OpenGeoHub Summer School 2018 en Praga\nDetección de cambios con Landsat\n\nGracias por su atención!!\n\n\n\nGRASS GIS logo"
  },
  {
    "objectID": "unidad_2/python_and_grass.html",
    "href": "unidad_2/python_and_grass.html",
    "title": "Python y GRASS GIS",
    "section": "",
    "text": "En esta notebook, nos vamos a introducir en el uso de GRASS GIS con Python, y no solo eso, sino que ejecutaremos GRASS con Python dentro de Google Colab conectado a una base de datos o grassdata dentro de nuestro Google Drive.\nAntes de empezar entonces y para ganar tiempo, conectemos nuestro drive e instalemos GRASS en Google Colab.\n# import drive from google colab\nfrom google.colab import drive\n# mount drive\ndrive.mount(\"/content/drive\")\n%%bash\nDEBIAN_FRONTEND=noninteractive \nsudo add-apt-repository ppa:ubuntugis/ubuntugis-unstable \napt update \napt install grass subversion grass-dev\napt remove libproj22\nChequeamos el path de instalación de GRASS.\n!grass --config path\nMientras, vamos a recorrer brevemente los principales paquetes/librerías de Python que son parte de GRASS y nos permiten ejcutar sus funciones, a la vez que podemos combinar las salidas con otras librerías más tradicionales de Python."
  },
  {
    "objectID": "unidad_2/python_and_grass.html#python-y-grass-gis",
    "href": "unidad_2/python_and_grass.html#python-y-grass-gis",
    "title": "Python y GRASS GIS",
    "section": "",
    "text": "Jupyter notebooks\nPaquetes Python dentro de GRASS\n\ngrass.script\ngrass.jupyter\ngrass.pygrass"
  },
  {
    "objectID": "unidad_2/python_and_grass.html#why-jupyter-notebooks-and-how-to-use-them",
    "href": "unidad_2/python_and_grass.html#why-jupyter-notebooks-and-how-to-use-them",
    "title": "Python y GRASS GIS",
    "section": "Why Jupyter Notebooks and how to use them?",
    "text": "Why Jupyter Notebooks and how to use them?\nJupyter Notebooks are server-client applications that allow code written in a notebook document to be edited and executed through a web browser. They can be run on a local computer (no internet access required) or used to control computations on a remote server accessed via the Internet (see the documentation).\nJupyter Notebooks can be interactive and they allow to combine live code, explanatory text, and computational results in a single document. In general, they are:\n\nconvenient for initial code development (prototyping)\nideal for code segmentation with the ability to re-run cells\nable to store values of variables from already executed cells\n\nThe notebook can be saved as an executable Python script in addition to the native .ipynb format, or exported to various documentation formats such as PDF or Sphinx RST with nice styling.\n\nEditing and interactive use\nEditing a Jupyter Notebook is very easy: in the web browser, you can navigate between text or code cells using the mouse or keyboard shortcuts (see Menu &gt; Help &gt; Keyboard Shortcuts). You can execute small code chunks cell by cell, save the notebook in its current state, or modify and recalculate cells or return them to their previous state. In addition to executable code cells, you can use Markdown in documentation cells to make them presentable to others."
  },
  {
    "objectID": "unidad_2/python_and_grass.html#grass-python",
    "href": "unidad_2/python_and_grass.html#grass-python",
    "title": "Python y GRASS GIS",
    "section": "GRASS & Python",
    "text": "GRASS & Python\n\nPython package grass.script\nEl grass.script o GRASS GIS Python Scripting Library provee funciones para llamar módulos de GRASS dentro de scripts Python. Las funciones más comúnmente usadas incluyen:\n\nrun_command: usada cuando la salida de los módulos es un raster o vector, no se espera una salida de tipo texto.\nread_command: se utiliza cuando la salida de los módulos es de tipo texto\nparse_command: se utiliza con módulos cuya salida puede convertirse en pares `key=value\nwrite_command: se utiliza con módulos que esperan una entrada de texto, ya sea en forma de archivo o desde stdin.\n\nTambién proporciona varias funciones de envoltura para módulos de uso frecuente, por ejemplo:\n\nPara obtener información de un raster, se utiliza script.raster.raster_info(): gs.raster_info('dsm')\nPara obtener información de un vector, se utiliza script.vector.vector_info(): gs.vector_info('roads')\nPara listar el raster en una ubicación, se utiliza script.core.list_grouped(): gs.list_grouped(type=['raster'])\nPara obtener la región de cálculo, se utiliza script.core.region(): gs.region()\n\n\nMore info: https://grass.osgeo.org/grass-stable/manuals/libpython/script_intro.html\n\n\nPython package grass.jupyter\nLa librería grass.jupyter mejora la integración de GRASS y Jupyter, y proporciona diferentes clases para facilitar la visualización de mapas de GRASS:\n\ninit: inicia una sesión de GRASS y configura todas las variables de entorno necesarias\nMap: renderizado 2D\nMap3D: renderizado 3D\nInteractiveMap`: visualización interactiva con folium\nTimeSeriesMap`: visualización de datos espacio-temporales\n\n\nMore info: https://grass.osgeo.org/grass-stable/manuals/libpython/grass.jupyter.html\n\n\nPython package grass.pygrass\nPyGRASS es una interfaz de programación de aplicaciones (API) de Python orientada a objetos para GRASS GIS. PyGRASS ofrece interfaces a los módulos y funcionalidades de GRASS, así como a datos vectoriales y ráster. PyGRASS mejora la integración entre GRASS GIS y Python, haciendo el uso de Python bajo GRASS más consistente con el lenguaje mismo. Además, simplifica el scripting y la programación de GRASS y lo hace más natural para el usuario.\nNosotros vamos a usar grass.pygrass.modules.shorcuts que nos permite llamar a los módulos o funciones de GRASS de forma muy parecida a cómo lo haríamos en la consola de GRASS."
  },
  {
    "objectID": "unidad_2/python_and_grass.html#ejemplos",
    "href": "unidad_2/python_and_grass.html#ejemplos",
    "title": "Python y GRASS GIS",
    "section": "Ejemplos",
    "text": "Ejemplos\n\n1+1"
  },
  {
    "objectID": "unidad_2/python_and_grass.html#otras-notebooks-tutoriales-y-links-útiles",
    "href": "unidad_2/python_and_grass.html#otras-notebooks-tutoriales-y-links-útiles",
    "title": "Python y GRASS GIS",
    "section": "Otras notebooks, tutoriales y links útiles",
    "text": "Otras notebooks, tutoriales y links útiles"
  },
  {
    "objectID": "unidad_2/python_and_grass.html#referencias",
    "href": "unidad_2/python_and_grass.html#referencias",
    "title": "Python y GRASS GIS",
    "section": "Referencias",
    "text": "Referencias"
  },
  {
    "objectID": "unidad_2/unit2_index.html",
    "href": "unidad_2/unit2_index.html",
    "title": "GRASS GIS 2023",
    "section": "",
    "text": "En esta unidad nos vamos a introducir en el uso de GRASS y Python, vamos a ver las nociones básicas del manejo y procesamiento de datos ráster en GRASS, y finalmente, vamos a ver cómo trabajamos con datos satelitales en GRASS, aplicando algunas de sus funciones específicas.\n\n\n\nVer en otra pestaña\n\n\nVer en otra pestaña\n\n\n\n\n\nVer en otra pestaña\n\n\nVer en otra pestaña"
  },
  {
    "objectID": "unidad_2/unit2_index.html#presentaciones-unidad-2",
    "href": "unidad_2/unit2_index.html#presentaciones-unidad-2",
    "title": "GRASS GIS 2023",
    "section": "",
    "text": "En esta unidad nos vamos a introducir en el uso de GRASS y Python, vamos a ver las nociones básicas del manejo y procesamiento de datos ráster en GRASS, y finalmente, vamos a ver cómo trabajamos con datos satelitales en GRASS, aplicando algunas de sus funciones específicas.\n\n\n\nVer en otra pestaña\n\n\nVer en otra pestaña\n\n\n\n\n\nVer en otra pestaña\n\n\nVer en otra pestaña"
  },
  {
    "objectID": "unidad_4/unit4_index.html",
    "href": "unidad_4/unit4_index.html",
    "title": "GRASS GIS 2023",
    "section": "",
    "text": "En esta unidad vamos a ver bla…\n\n\n\nVer en otra pestaña\n\n\nVer en otra pestaña"
  },
  {
    "objectID": "unidad_4/unit4_index.html#presentaciones-unidad-4",
    "href": "unidad_4/unit4_index.html#presentaciones-unidad-4",
    "title": "GRASS GIS 2023",
    "section": "",
    "text": "En esta unidad vamos a ver bla…\n\n\n\nVer en otra pestaña\n\n\nVer en otra pestaña"
  },
  {
    "objectID": "unidad_3/unit3_index.html",
    "href": "unidad_3/unit3_index.html",
    "title": "GRASS GIS 2023",
    "section": "",
    "text": "En esta unidad vamos a ver nociones básicas de análisis de imágenes basado en objetos (OBIA) y luego realizaremos un ejercicio recorriendo los módulos para OBIA en GRASS GIS.\n\n\n\nVer en otra pestaña\n\n\nVer en otra pestaña"
  },
  {
    "objectID": "unidad_3/unit3_index.html#presentaciones-unidad-3",
    "href": "unidad_3/unit3_index.html#presentaciones-unidad-3",
    "title": "GRASS GIS 2023",
    "section": "",
    "text": "En esta unidad vamos a ver nociones básicas de análisis de imágenes basado en objetos (OBIA) y luego realizaremos un ejercicio recorriendo los módulos para OBIA en GRASS GIS.\n\n\n\nVer en otra pestaña\n\n\nVer en otra pestaña"
  },
  {
    "objectID": "unidad_5/unit5_index.html",
    "href": "unidad_5/unit5_index.html",
    "title": "GRASS GIS 2023",
    "section": "",
    "text": "En esta unidad vamos a ver …\n\nVer en otra pestaña"
  },
  {
    "objectID": "unidad_5/unit5_index.html#presentaciones-unidad-5",
    "href": "unidad_5/unit5_index.html#presentaciones-unidad-5",
    "title": "GRASS GIS 2023",
    "section": "",
    "text": "En esta unidad vamos a ver …\n\nVer en otra pestaña"
  },
  {
    "objectID": "trabajo_final.html",
    "href": "trabajo_final.html",
    "title": "Trabajo Integrador",
    "section": "",
    "text": "El objetivo de este documento es brindar pautas generales para la realización de la práctica final, requisito necesario para la aprobación del curso y obtención del certificado correspondiente. En esta última instancia de aprendizaje se espera que las personas perticipantes incorporen y apliquen los conocimientos adquiridos durante el desarrollo del curso."
  },
  {
    "objectID": "trabajo_final.html#especificación-del-trabajo-integrador",
    "href": "trabajo_final.html#especificación-del-trabajo-integrador",
    "title": "Trabajo final",
    "section": "",
    "text": "El objetivo de este documento es poder brindar las pautas generales para la realización de la práctica final, requisito necesario para la conclusión del taller. En esta última instancia de aprendizaje se espera que los alumnos incorporen los conocimientos adquiridos durante el desarrollo del taller.\n\n\nSe proponen 2 modalidades diferentes:\n\nInforme y presentación de trabajo final abordando algún problema/pregunta de interés utilizando herramientas de GRASS GIS\nTutorial abordando algún problema/pregunta de interés utilizando herramientas de GRASS GIS o demostrando el uso/aplicación de algún conjunto de módulos de GRASS\n\nLa selección de los grupos se realizará en la reunión del día Martes 23/03, mediante una aplicación online.\n\n\nLa modalidad informe del trabajo integrador se realizará en grupos de 4 integrantes. El mismo debe abordar algún problema/pregunta de su interés utilizando herramientas que aprendimos durante el taller u otras de su interés disponibles en GRASS (ver modulos core y addons). Los trabajos deben incluir al menos los siguientes ítems: - Título - Integrantes del equipo - Introducción (descripción breve de problema, presentando la pregunta de investigación - máximo 2 párrafos) - Objetivo claro (i.e., orientado a los resultados que se desean obtener) - Descripción de datos empleados - Descripción de la metodología (incluyendo el código, se pueden incluir diagramas de flujo para ilustrar la metodología seguida) - Resultados (comentar los resultados más relevantes presentando mapas de salida, tablas y/o gráficos; los mapas deben contener como mínimo leyenda y escala) - Discusión y conclusiones\nSe entregará un informe de un máximo de 10 páginas en formato odt o pdf (letra tamaño 12). El trabajo deberá ser presentado mediante una exposición. Se valorará la calidad del trabajo técnico y la prolijidad y fluidez de la exposición. El tiempo de presentación de cada grupo será de 15 min + 5 min para preguntas.\nSe otorgará un reconocimiento al mejor trabajo seleccionado que consistirá en un espacio de exposición en directo en el canal de Youtube del Instituto Gulich.\nLos criterios de selección incluyen: - códigos reproducibles y documentados (legibilidad, estilo y escritura) - aplicabilidad de la propuesta - originalidad - resultados comprensibles\n\n\n\nEn grupos de 4 integrantes, escribir un tutorial del estilo de Working with i.landsat. Se puede optar por alguna temática o grupo de módulos de interés incluyendo cosas que no se hayan visto durante el taller pero se deseen aprender.\nEl tutorial debe estar escrito en Inglés y en formato markdown, incluir una breve introducción, descripción/link a datos, código explicado paso a paso, resultados parciales y finales en forma de mapas, tablas o gráficos, una mínima discusión y referencias.\nPara este trabajo requerirán crear una cuenta en GitHub, y un repositorio donde alojar el archivo markdown (.md). Se presentará directamente desde el archivo md (15 min de exposición + 5 min de preguntas) y se valorará con los mismos criterios descriptos anteriormente.\nCon los dos trabajos seleccionados, se realizará un pull request al repositorio donde de encuentra el sitio web de GRASS. Allí, será revisado por la comunidad y de ser aprobado, se publicará en las noticias y las redes sociales de GRASS GIS.\n\n\n\n\nEl plazo límite para la entrega de los trabajos en cualquiera de sus formatos es el día 20/04/2021 a las 13:00. Los mismos deberán subirse a la Moodle en la Unidad 5.\nLa exposición de los trabajos se realizará el día 23/04/2021 en horario a acordar."
  },
  {
    "objectID": "unidad_5/grass_and_r_sdm.html",
    "href": "unidad_5/grass_and_r_sdm.html",
    "title": "R y GRASS: Modelado de nicho",
    "section": "",
    "text": "En esta última sesión, vamos a demostrar y ejemplificar el uso combinado de GRASS y R para modelar la distribución de Aedes aegypti en la provincia de Córdoba en función de variables ambientales. Algunas de estas variables provienen de los ejercicios realizados en la unidad de series de tiempo y otras serán generadas durante este ejercicio.\nAntes de empezar y para ganar tiempo, conectemos nuestro drive e instalemos GRASS y los paquetes de R que vamos a usar en esta sesión.\n# import drive from google colab\nfrom google.colab import drive\n# define mounting point for drive\ndmp = \"/content/drive\"\n# mount drive\ndrive.mount(dmp)\n%%bash\nDEBIAN_FRONTEND=noninteractive \nsudo add-apt-repository ppa:ubuntugis/ubuntugis-unstable \napt update \napt install grass subversion grass-dev\napt remove libproj22\n!grass --config path\nInstalamos y cargamos al entorno el paquete de python que nos permite hacer interfaz con R dentro de una Jupyter notebook.\n!pip install rpy2==3.5.1\n%reload_ext rpy2.ipython\nChequeamos nuestra sesión de R.\n%R sessionInfo()\nInstalamos todos los paquetes necesarios para este ejercicio. This might take a while…\n%%R\ninstall.packages(\"rgrass\")\ninstall.packages(\"terra\")\ninstall.packages(\"raster\")\ninstall.packages(\"sf\")\ninstall.packages(\"biomod2\")\ninstall.packages(\"dismo\")\ninstall.packages(\"usdm\")\ninstall.packages(\"SDMtune\")\ninstall.packages(\"zeallot\")\ninstall.packages(\"rJava\")\ninstall.packages(\"ggpubr\")\ninstall.packages(\"tmap\")\ninstall.packages(\"tmaptools\")"
  },
  {
    "objectID": "unidad_5/grass_and_r_sdm.html#usage",
    "href": "unidad_5/grass_and_r_sdm.html#usage",
    "title": "R y GRASS: Modelado de nicho",
    "section": "Usage",
    "text": "Usage\nGRASS GIS and R can be used together in two ways:\nA. Using R within a GRASS GIS session, i.e. starting R (or RStudio) from GRASS terminal \n\ntype R or rstudio & in the GRASS GIS terminal\nload rgrass library\nuse read_VECT(), read_RAST() to read data from GRASS into R\naccess GRASS GIS modules and database through execGRASS()\n\nwrite data (back) to GRASS database with write_VECT() and write_RAST()\n\n\n\n\n\n\nB. Using GRASS GIS within an R session, i.e. we connect to GRASS GIS database from within R (or RStudio). \n\nwe need to start GRASS GIS with initGRASS() from R\nwe access GRASS GIS modules through execGRASS()\n\nuse read_VECT(), read_RAST(), write_VECT() and write_RAST() to read data from and to GRASS database\n\n\n\n\n\n\n\nNote\n\n\n\nrgrass was originally intended to apply GRASS functions on data outside GRASS database; hence some prefer to create throw away locations"
  },
  {
    "objectID": "unidad_5/grass_and_r_sdm.html#references",
    "href": "unidad_5/grass_and_r_sdm.html#references",
    "title": "R y GRASS: Modelado de nicho",
    "section": "References",
    "text": "References\n\n\nBivand, R. (2022), rgrass: Interface Between ’GRASS’ Geographical Information System and ’R’.\n\n\nHijmans, R. J. (2022), terra: Spatial Data Analysis.\n\n\nVignali, S., Barras, A. G., Arlettaz, R., y Braunisch, V. (2020), «SDMtune: An R package to tune and evaluate species distribution models», Ecology and Evolution, 00, 1-18. https://doi.org/10.1002/ece3.6786."
  },
  {
    "objectID": "unidad_1/functions_in_grass.html#references",
    "href": "unidad_1/functions_in_grass.html#references",
    "title": "Funciones de GRASS GIS",
    "section": "Referencias",
    "text": "Referencias\n\n\nJasiewicz, J., y Metz, M. (2011), «A new GRASS GIS toolkit for Hortonian analysis of drainage networks», Computers & Geosciences, 37, 1162-1173. https://doi.org/10.1016/j.cageo.2011.03.003.\n\n\nWegmann, M., Leutner, B. F., Metz, M., Neteler, M., Dech, S., y Rocchini, D. (2018), «r.pi: A grass gis package for semi-automatic spatial pattern analysis of remotely sensed land cover data», Methods in Ecology and Evolution, 9, 191-199. https://doi.org/10.1111/2041-210X.12827."
  },
  {
    "objectID": "unidad_2/python_and_grass.html#por-qué-jupyter-notebooks-y-cómo-usarlos",
    "href": "unidad_2/python_and_grass.html#por-qué-jupyter-notebooks-y-cómo-usarlos",
    "title": "Python y GRASS GIS",
    "section": "¿Por qué Jupyter Notebooks y cómo usarlos?",
    "text": "¿Por qué Jupyter Notebooks y cómo usarlos?\nLos Cuadernos Jupyter son aplicaciones servidor-cliente que permiten que el código escrito en un documento de cuaderno sea editado y ejecutado a través de un navegador web. Pueden ejecutarse en un ordenador local (sin necesidad de acceso a Internet) o utilizarse para controlar cálculos en un servidor remoto al que se accede a través de Internet (véase la documentación).\nLos Jupyter Notebooks pueden ser interactivos y permiten combinar código en vivo, texto explicativo y resultados computacionales en un único documento. En general, son:\n\nconvenientes para el desarrollo inicial de código (prototipado)\nideales para la segmentación de código, con la posibilidad de volver a ejecutar celdas\ncapaces de almacenar valores de variables de celdas ya ejecutadas\n\nEl cuaderno puede guardarse como un script ejecutable de Python además del formato nativo .ipynb, o exportado a varios formatos de documentación como PDF o Sphinx RST con un bonito estilo.\n\nEdición y uso interactivo\nEditar un Jupyter Notebook es muy fácil: en el navegador web, puedes navegar entre celdas de texto o código utilizando el ratón o atajos de teclado (ver Menú &gt; Ayuda &gt; Atajos de teclado). Puede ejecutar pequeños fragmentos de código celda por celda, guardar el cuaderno en su estado actual, o modificar y recalcular celdas o devolverlas a su estado anterior. Además de las celdas de código ejecutables, puede puede utilizar Markdown en las celdas de documentación para hacerlas presentables a los demás."
  },
  {
    "objectID": "unidad_2/python_and_grass.html#por-qué-jupyter-notebooks-y-cómo-usarlas",
    "href": "unidad_2/python_and_grass.html#por-qué-jupyter-notebooks-y-cómo-usarlas",
    "title": "Python y GRASS GIS",
    "section": "¿Por qué Jupyter Notebooks y cómo usarlas?",
    "text": "¿Por qué Jupyter Notebooks y cómo usarlas?\nLas Jupyter Notebook son aplicaciones servidor-cliente que permiten que el código escrito en un documento de cuaderno sea editado y ejecutado a través de un navegador web. Pueden ejecutarse en un ordenador local (sin necesidad de acceso a Internet) o utilizarse para controlar cálculos en un servidor remoto al que se accede a través de Internet (véase la documentación).\nLos Jupyter Notebooks pueden ser interactivos y permiten combinar código en vivo, texto explicativo y resultados computacionales en un único documento. En general, son:\n\nconvenientes para el desarrollo inicial de código (prototipado)\nideales para la segmentación de código, con la posibilidad de volver a ejecutar celdas\ncapaces de almacenar valores de variables de celdas ya ejecutadas\n\nEl cuaderno puede guardarse como un script ejecutable de Python además del formato nativo .ipynb, o exportado a varios formatos de documentación como PDF o Sphinx RST con un bonito estilo.\n\nEdición y uso interactivo\nEditar un Jupyter Notebook es muy fácil: en el navegador web, puedes navegar entre celdas de texto o código utilizando el ratón o atajos de teclado (ver Menú &gt; Ayuda &gt; Atajos de teclado). Puede ejecutar pequeños fragmentos de código celda por celda, guardar el cuaderno en su estado actual, o modificar y recalcular celdas o devolverlas a su estado anterior. Además de las celdas de código ejecutables, puede puede utilizar Markdown en las celdas de documentación para hacerlas presentables a los demás."
  },
  {
    "objectID": "unidad_2/python_and_grass.html#grass.script",
    "href": "unidad_2/python_and_grass.html#grass.script",
    "title": "Python y GRASS GIS",
    "section": "grass.script",
    "text": "grass.script\nEl paquete grass.script o GRASS GIS Python Scripting Library provee funciones para llamar módulos de GRASS dentro de scripts o rutinas Python. Las funciones más comúnmente usadas incluyen:\n\nrun_command: usada cuando la salida de los módulos es un raster o vector, no se espera una salida de tipo texto.\nread_command: se utiliza cuando la salida de los módulos es de tipo texto.\nparse_command: se utiliza con módulos cuya salida puede convertirse en pares key=value o diccionarios.\nwrite_command: se utiliza con módulos que esperan una entrada de texto, ya sea en forma de archivo o desde stdin.\n\nEste paquete también proporciona varias funciones de wrapping para módulos de uso muy frecuente en GRASS, por ejemplo:\n\nPara obtener información de un raster, se utiliza script.raster.raster_info(): gs.raster_info('elevation')\nPara obtener información de un vector, se utiliza script.vector.vector_info(): gs.vector_info('roadsmajor')\nPara listar mapas de diferente tipo en un mapset, se utiliza script.core.list_grouped(): gs.list_grouped(type=['raster'])\nPara obtener la región computacional, se utiliza script.core.region(): gs.region()\n\n\n\n\n\n\n\nNota\n\n\n\nPara más detalles, ver la documentación del paquete en: https://grass.osgeo.org/grass-stable/manuals/libpython/script_intro.html"
  },
  {
    "objectID": "unidad_2/python_and_grass.html#grass.jupyter",
    "href": "unidad_2/python_and_grass.html#grass.jupyter",
    "title": "Python y GRASS GIS",
    "section": "grass.jupyter",
    "text": "grass.jupyter\nLa librería grass.jupyter mejora la integración de GRASS y Jupyter, y proporciona diferentes clases para facilitar la visualización de mapas de GRASS en el entorno Jupyter. Este paquete fue desarrollado por Haedrich et al. (2023) como parte de su proyecto para Google Summer of Code y con una student grant de GRASS.\nLas classes más importantes son:\n\ninit: inicia una sesión de GRASS y configura todas las variables de entorno necesarias para ejecutar GRASS desde Python y dentro de una Notebook.\nMap: renderiza mapas 2D\nMap3D: renderiza mapas 3D\nInteractiveMap: permite la visualización interactiva utilizando la librería folium\nTimeSeriesMap: permite la visualización de datos espacio-temporales\n\n\n\n\n\n\n\nNota\n\n\n\nPara más detalles, ver la documentación del paquete en: https://grass.osgeo.org/grass-stable/manuals/libpython/grass.jupyter.html"
  },
  {
    "objectID": "unidad_2/python_and_grass.html#grass.pygrass",
    "href": "unidad_2/python_and_grass.html#grass.pygrass",
    "title": "Python y GRASS GIS",
    "section": "grass.pygrass",
    "text": "grass.pygrass\nPyGRASS es una interfaz de programación de aplicaciones (API) de Python orientada a objetos para GRASS GIS desarrollada por Zambelli et al. (2013). PyGRASS ofrece interfaces a los módulos y funcionalidades de GRASS, así como a los datos vectoriales y ráster, de modo que permite acceder a cada minima unidad y desarrollar nuevos módulos con funciones de más bajo nivel. PyGRASS mejora la integración entre GRASS GIS y Python, haciendo el uso de Python bajo GRASS más consistente con el lenguaje mismo. Además, simplifica el scripting y la programación de GRASS y lo hace más natural para el usuario.\nDentro de esta librería, vamos a usar especialmente grass.pygrass.modules.shorcuts que nos permite llamar a los módulos o funciones de GRASS de forma muy parecida a cómo lo haríamos en la consola de GRASS.\n\n\n\n\n\n\nNota\n\n\n\nPara más detalles, ver la documentación del paquete en: https://grass.osgeo.org/grass-stable/manuals/libpython/pygrass_index.html"
  },
  {
    "objectID": "unidad_2/python_and_grass.html#ejemplos-con-grass.script",
    "href": "unidad_2/python_and_grass.html#ejemplos-con-grass.script",
    "title": "Python y GRASS GIS",
    "section": "Ejemplos con grass.script",
    "text": "Ejemplos con grass.script\nListamos los mapas raster del mapset PERMANENT:\n\nlista = gs.list_grouped(type = \"raster\")[\"PERMANENT\"]\nlista\n\nObtenemos info de un mapa raster:\n\ngs.raster_info(\"elevation\")[\"cols\"]\n\n\n\n\n\n\n\nTarea\n\n\n\nAhora, hagamos lo mismo pero para los mapas de tipo vectorial.\n\n\n\n# gs.list_grouped(type = \"vector\")\n\nImprimimos la region computacional actual:\n\ngs.region()\n\nCambiamos la región computacional al vector area_edificada_cba:\n\ngs.run_command(\"g.region\", vector=\"area_edificada_cba\")\n\nVerificamos los atributos del vector seleccionado:\n\ngs.vector_db_select(\"area_edificada_cba\")\n\nExtraemos el área urbana de Río Cuarto:\n\ngs.run_command(\"v.extract\", \n               input=\"area_edificada_cba\", \n               where=\"fna == 'Gran Río Cuarto'\", \n               output=\"urban_area_rio_iv\")\n\nListamos los vectores por un patrón:\n\ngs.list_grouped(type=\"vector\", pattern=\"urban*\")\n\nVerificamos los atributos del nuevo vector creado:\n\ngs.vector_db_select(\"urban_area_rio_iv\")\n\ny obtenemos información sobre el mismo. Notar que podemos seleccionar qué información queremos extraer, i.e., la salida es un diccionario.\n\n# show attributes\ngs.vector_info(\"urban_area_rio_iv\")"
  },
  {
    "objectID": "unidad_2/python_and_grass.html#ejemplos-con-grass.jupyter",
    "href": "unidad_2/python_and_grass.html#ejemplos-con-grass.jupyter",
    "title": "Python y GRASS GIS",
    "section": "Ejemplos con grass.jupyter",
    "text": "Ejemplos con grass.jupyter\nAhora vamos a demostrar el uso de las dos clases más comunes del paquete grass.jupyter para graficar mapas. Usamos primeramente la clase interactiva que nos permite mostrar nuestras salidas sobre mapas base como el de OpenStreetMap, por ejemplo.\n\nraleigh_map = gj.InteractiveMap(width = 500, use_region=True, tiles=\"OpenStreetMap\")\nraleigh_map.add_raster(\"elevation\")\nraleigh_map.add_vector(\"urban_area_rio_iv\")\nraleigh_map.add_layer_control(position = \"bottomright\")\nraleigh_map.show()\n\nA continuación, creamos una salida estática, utilizando la clase Map. Esta salida es similar a utilizar el Map Display en la GUI y exportar el resultado.\n\nraleigh_map = gj.Map(width=500)\nraleigh_map.d_rast(map=\"elevation\")\nraleigh_map.d_vect(map=\"embalses\")\nraleigh_map.d_legend(raster=\"elevation\", \n                     title=\"Height (m)\", \n                     fontsize=10, \n                     at=(70, 90, 80, 90), \n                     flags=\"b\")\nraleigh_map.d_barscale()\nraleigh_map.show()"
  },
  {
    "objectID": "unidad_2/python_and_grass.html#ejemplos-con-grass.pygrass",
    "href": "unidad_2/python_and_grass.html#ejemplos-con-grass.pygrass",
    "title": "Python y GRASS GIS",
    "section": "Ejemplos con grass.pygrass",
    "text": "Ejemplos con grass.pygrass\nFinalmente, vamos a ejemplificar el uso de la interfaz modules dentro de grass.pygrass. Si bien esta interfaz nos permite ejecutar comandos de GRASS casi como si los ejecutásemos en la terminal, las salidas no están optimizadas para ser usadas como entrada para otros comandos. Para ello, es más conveniente usar grass.script o funciones de más bajo nivel de grass.pygrass que permiten acceder a los componentes básicos de los objetos dentro de GRASS.\n\nfrom grass.pygrass.modules.shortcuts import general as g\nfrom grass.pygrass.modules.shortcuts import raster as r\nfrom grass.pygrass.modules.shortcuts import vector as v\n\n\ng.region(flags=\"p\")\n\n\nv.info(map=\"cursos_agua\")\n\n\nr.report(map=\"elevation\", nsteps=\"10\", quiet=True)"
  },
  {
    "objectID": "unidad_2/raster_data_in_grass.html",
    "href": "unidad_2/raster_data_in_grass.html",
    "title": "Datos raster en GRASS GIS",
    "section": "",
    "text": "Un mapa raster es un arreglo de celdas en forma de grilla. Tiene filas y columnas y en cada celda hay un dato o un indicador de no-data (valor nulo). En GRASS, los mapas raster pueden ser arreglos 2D o 3D.\n\nLos límites se describen en los campos norte (n), sur (s), este (e) y oeste (w).\nLa extensión se calcula a partir de los límites externos de todas las celdas del mapa.\n\n\n\n\n\n\n\nNota\n\n\n\nPara más info ver la página raster intro"
  },
  {
    "objectID": "unidad_2/raster_data_in_grass.html#precisión-de-datos-raster",
    "href": "unidad_2/raster_data_in_grass.html#precisión-de-datos-raster",
    "title": "Datos raster en GRASS GIS",
    "section": "Precisión de datos raster",
    "text": "Precisión de datos raster\nLa precisión de los datos raster en GRASS, se clasifica en:\n\nCELL DATA TYPE: un mapa raster de tipo ENTERO (sólo números enteros)\nFCELL DATA TYPE: un mapa raster de tipo FLOTANTE (4 bytes, 7-9 dígitos de precisión)\nDCELL DATA TYPE: un mapa raster de tipo DOBLE (8 bytes, 15-17 dígitos de precisión)\n\n\n\n\n\n\n\nNota\n\n\n\nPara más info ver la wiki sobre semántica de rasters"
  },
  {
    "objectID": "unidad_2/raster_data_in_grass.html#reglas-generales-para-raster-en-grass",
    "href": "unidad_2/raster_data_in_grass.html#reglas-generales-para-raster-en-grass",
    "title": "Datos raster en GRASS GIS",
    "section": "Reglas generales para raster en GRASS",
    "text": "Reglas generales para raster en GRASS\n\nMapas raster de salida u output tienen sus límites y resolución iguales a los de la región computacional\nMapas raster de entrada o input son automáticamente cortados y reajustados a la región computacional\nMapas raster de entrada o input se enmascaran automáticamente si existe un mapa raster llamado MASK.\n\n\nExcepción: Todos los módulos r.in.* leen los datos celda por celda sin remuestreo (a menos que se especifique lo contrario"
  },
  {
    "objectID": "unidad_2/raster_data_in_grass.html#null-valores-nulos-en-grass-gis",
    "href": "unidad_2/raster_data_in_grass.html#null-valores-nulos-en-grass-gis",
    "title": "Datos raster en GRASS GIS",
    "section": "NULL: valores nulos en GRASS GIS",
    "text": "NULL: valores nulos en GRASS GIS\n\nNULL representa “sin dato” en los mapas raster\nOperaciones con celdas NULL producen celdas NULL\nLos valores NULL son gestionados con r.null\n\n# establecer el valor no-data\nr.null map=mapname setnull=-9999\n\n# reemplazar NULL por un número \nr.null map=mapname null=256"
  },
  {
    "objectID": "unidad_2/raster_data_in_grass.html#máscaras-en-grass-gis",
    "href": "unidad_2/raster_data_in_grass.html#máscaras-en-grass-gis",
    "title": "Datos raster en GRASS GIS",
    "section": "Máscaras en GRASS GIS",
    "text": "Máscaras en GRASS GIS\n\nSe puede crear un mapa raster llamado MASK para enmascarar ciertas áreas, como por ejemplo el mar, los lagos, o el área por fuera de un polígono de interés.\nTodas las celdas que sean NULL en el mapa MASK serán ignoradas, del mismo modo que son ignoradas todas las celdas por fuera de la región computacional.\nLas máscaras se gestionan con r.mask o creando un raster con el nombre MASK via álgebra de mapas.\nLos mapas vectoriales también pueden usarse como máscaras y se pueden establecer máscaras inversas.\n\n\n\n\na- Raster elevation y vector lakes. b- Sólo los datos raster dentro de la máscara son usados para análisis posteriores. c- Máscara inversa.\n\n\nVeamos algunos ejemplos de cómo aplicar máscaras\n# usar un vector como máscara\nr.mask vector=lakes\n\n# usar un vector como máscara inversa\nr.mask -i vector=lakes\n\n# enmascarar solo algunos valores de un mapa raster \nr.mask raster=landclass96 maskcats=\"5 thru 7\"\n\n# crear un raster MASK\nr.mapcalc expression=\"MASK = if(elevation &lt; 100, 1, null())\"\n\n# remover la máscara\nr.mask -r\nUna máscara sólo se aplica realmente cuando se lee un mapa raster, es decir, cuando se usa como entrada en un módulo.\nVeamos un ejemplo:\ng.region -p raster=elevation\nr.mask -i vector=lakes\nr.grow.distance -n input=elevation distance=distance\nr.mask -r\n\n\n\na- Máscara activa. b- Máscara desactivada.\n\n\nr.mask -i vector=lakes\nr.out.gdal input=distance output=distance.tif\nqgis distance.tif\n\n\n\nMáscara leída al exportar\n\n\n\nRegión computacional\n\nLa región computacional está definida en función de la extensión dada por los límites norte, sur, este y oeste y una resolución espacial. Aplica únicamente a las operaciones con datos raster.\nLa región de un mapa raster está definida por la extensión del mapa y la resolución del mapa. Cada mapa raster tiene su región, pero la región computacional tiene precedencia.\nLa región de visualizacion es la extensión del map display independiente de la región computacional y la región del mapa raster.\n\n\nLa región computacional puede definirse y modificarse mediante el módulo g.region a la extensión de un mapa vectorial, un raster o manualmente a alguna zona de interés. También puede establecerse a la extensión de un vector y alinear la resolución a un determinado mapa raster. Por ejemplo:\ng.region -p vector=lakes align=elevation\nPor otra, es posible establecer la región computacional a partir de la región de visualización y guardarla con un nombre para luego volver a aplicarla."
  },
  {
    "objectID": "unidad_2/raster_data_in_grass.html#importarexportar-máscara-y-región",
    "href": "unidad_2/raster_data_in_grass.html#importarexportar-máscara-y-región",
    "title": "Datos raster en GRASS GIS",
    "section": "Importar/exportar, máscara y región",
    "text": "Importar/exportar, máscara y región\n\nr.in.* y r.import importan siempre el mapa completo (a menos que se establezca el recorte a la región). Luego, es posible establecer la región a la resolución (y extensión) del mapa con g.región -p raster=mapname.\nr.out.* exportan mapas raster según la definición de la región computacional (extensión y resolución) y respetan la máscara si está presente. Se aplica interpolación por vecino más cercano por defecto.\n\n\n\n\n\n\n\nImportante\n\n\n\nEn la importación y la exportación, los mapas vectoriales se consideran siempre en toda su extensión."
  },
  {
    "objectID": "unidad_2/raster_data_in_grass.html#reportes-y-estadísticas",
    "href": "unidad_2/raster_data_in_grass.html#reportes-y-estadísticas",
    "title": "Datos raster en GRASS GIS",
    "section": "Reportes y estadísticas",
    "text": "Reportes y estadísticas\n\nr.report: reporta área y número de celdas\nr.coin: reporta la matriz o tabla de coincidencia entre dos mapas raster\n\n# Ejemplos\nr.report map=zipcodes,landclass96 units=h,p\nr.coin first=zipcodes second=landclass96 units=p\n\nr.univar: calcula estadísticas descriptivas a partir de las celdas no nulas de un mapa raster\nr.stats: calcula el área de cada una de las categorías o intervalos de un mapa raster\nr.statistics y r.stats.zonal: estadística zonal\nr.neighbors: estadística local basada en las celdas vecinas\n\n# estadísticas descriptivas\nr.univar map=elevation\n\n# estadística zonal: elevacion promedio por código postal\nr.stats.zonal base=zipcodes cover=elevation method=average output=zipcodes_elev_avg"
  },
  {
    "objectID": "unidad_2/raster_data_in_grass.html#álgebra-de-mapas-raster",
    "href": "unidad_2/raster_data_in_grass.html#álgebra-de-mapas-raster",
    "title": "Datos raster en GRASS GIS",
    "section": "Álgebra de mapas raster",
    "text": "Álgebra de mapas raster\nEl módulo r.mapcalc nos permite realizar múltiples operaciones entre mapas. Así, podemos crear nuevos mapas ráster que sean expresiones aritméticas en las que intervengan mapas ráster existentes, constantes enteras o de punto flotante y funciones.\n\n\n\n\n\n\nOperadores\nLos operadores se aplican de izquierda a derecha, aplicándose los de mayor precedencia antes que los de menor precedencia. La división por 0 y el módulo por 0 son aceptables y dan un resultado NULL. Los operadores lógicos dan un resultado 1 si la comparación es verdadera, 0 en caso contrario.\n\n\n\n\nOperator\nMeaning\nType\n\n\n\n\n-\nnegation\nArithmetic\n\n\n~\none’s complement\nBitwise\n\n\n!\nnot\nLogical\n\n\n^\nexponentiation\nArithmetic\n\n\n%\nmodulus\nArithmetic\n\n\n/\ndivision\nArithmetic\n\n\n*\nmultiplication\nArithmetic\n\n\n+\naddition\nArithmetic\n\n\n-\nsubtraction\nArithmetic\n\n\n&lt;&lt;\nleft shift\nBitwise\n\n\n&gt;&gt;\nright shift\nBitwise\n\n\n&gt;&gt;&gt;\nright shift (unsigned)\nBitwise\n\n\n&gt;\ngreater than\nLogical\n\n\n&gt;=\ngreater than or equal\nLogical\n\n\n&lt;\nless than\nLogical\n\n\n&lt;=\nless than or equal\nLogical\n\n\n==\nequal\nLogical\n\n\n!=\nnot equal\nLogical\n\n\n&\nbitwise and\nBitwise\n\n\n|\nbitwise or\nBitwise\n\n\n&&\nlogical and\nLogical\n\n\n&&&\nlogical and1\nLogical\n\n\n||\nlogical or\nLogical\n\n\n|||\nlogical or2\nLogical\n\n\n?:\nconditional\nLogical\n\n\n\n\n\n\nOperador vecinos o índices [row,col]\nLos mapas y las imágenes son matrices bidimensionales. En r.mapcalc, los mapas pueden ir seguidos de un modificador de vecindad que especifica un desplazamiento relativo desde la celda actual que se está evaluando. El formato es map[r,c], donde r es el desplazamiento de fila y c es el desplazamiento de columna. Por ejemplo, map[1,2] se refiere a la celda situada una fila por debajo y dos columnas a la derecha de la celda actual, map[-2,-1] se refiere a la celda situada dos filas por encima y una columna a la izquierda de la celda actual, y map[0,1] se refiere a la celda situada una columna a la derecha de la celda actual. Esta sintaxis permite desarrollar filtros de vecindad dentro de un mismo mapa o en varios mapas.\n# ejemplo filtro de paso bajo con operador de vecinos\nr.mapcalc \\\nexpression=\"lsat7_2002_10_smooth = (lsat7_2002_10[-1,-1] + \n                                    lsat7_2002_10[-1,0] + \n                                    lsat7_2002_10[1,1] + \n                                    lsat7_2002_10[0,-1] + \n                                    lsat7_2002_10[0,0] + \n                                    lsat7_2002_10[0,1] + \n                                    lsat7_2002_10[1,-1] + \n                                    lsat7_2002_10[1,0] + \n                                    lsat7_2002_10[1,1]) / 9\"\nPodemos comparar con la herramienta mapswipe, por ejemplo:\ng.gui.mapswipe first=lsat7_2002_10 second=lsat7_2002_10_smooth\n\n\n\n\n\n\n\nFunciones\nLas funciones actualmente admitidas se enumeran en la tabla siguiente. El tipo del resultado se indica en la última columna. F significa que las funciones siempre dan como resultado un valor de coma flotante, I significa que la función da un resultado entero, y * indica que el resultado es flotante si alguno de los argumentos de la función son valores de coma flotante y entero si todos los argumentos son enteros.\n\n\n\n\n\n\n\nCláusula if\n# Ejemplo: \n# Determinar las zonas forestales situadas por encima \n# de una cierta elevación\n\n# establecer la región computacional\ng.region rast=landclass96\n\n# reportar las clases de cobertura\nr.report map=landclass96 units=p\n\n# estadística univariada del mapa de elevacion\nr.univar map=elevation\n\n# seleccionar áreas &gt; 120m y con bosque\nr.mapcalc expression=\"forest_high = if(elevation &gt; 120 && landclass96 == 5, 1, null())\""
  },
  {
    "objectID": "unidad_2/raster_data_in_grass.html#regresión-simple-y-múltiple",
    "href": "unidad_2/raster_data_in_grass.html#regresión-simple-y-múltiple",
    "title": "Datos raster en GRASS GIS",
    "section": "Regresión simple y múltiple",
    "text": "Regresión simple y múltiple\n\nr.regression.line: regresión simple\nr.regression.multi: regresión múltiple\n\n# regresión simple\ng.region raster=elev_srtm_30m -p\nr.regression.line mapx=elev_ned_30m mapy=elev_srtm_30m \n\n# regresión múltiple\ng.region raster=soils_Kfactor -p\nr.regression.multi mapx=elevation,aspect,slope mapy=soils_Kfactor \\\n  residuals=soils_Kfactor.resid estimates=soils_Kfactor.estim"
  },
  {
    "objectID": "unidad_2/raster_data_in_grass.html#definición",
    "href": "unidad_2/raster_data_in_grass.html#definición",
    "title": "Datos raster en GRASS GIS",
    "section": "",
    "text": "Un mapa raster es un arreglo de celdas en forma de grilla. Tiene filas y columnas y en cada celda hay un dato o un indicador de no-data (valor nulo). En GRASS, los mapas raster pueden ser arreglos 2D o 3D.\n\nLos límites se describen en los campos norte (n), sur (s), este (e) y oeste (w).\nLa extensión se calcula a partir de los límites externos de todas las celdas del mapa.\n\n\n\n\n\n\n\nNota\n\n\n\nPara más info ver la página raster intro"
  },
  {
    "objectID": "unidad_2/raster_data_in_grass.html#reglas-generales-para-los-datos-raster-en-grass",
    "href": "unidad_2/raster_data_in_grass.html#reglas-generales-para-los-datos-raster-en-grass",
    "title": "Datos raster en GRASS GIS",
    "section": "Reglas generales para los datos raster en GRASS",
    "text": "Reglas generales para los datos raster en GRASS\n\nLos mapas raster de salida u output tienen sus límites y resolución iguales a los de la región computacional establecida.\nLos mapas raster de entrada o input son automáticamente cortados y reajustados a la región computacional.\nMapas raster de entrada o input se enmascaran automáticamente si existe un mapa raster llamado MASK en el mapset.\n\n\n\n\n\n\n\nExcepción\n\n\n\nTodos los módulos r.in.* leen los datos celda por celda sin remuestreo y con su resolución y extensión originales -a menos que se especifique lo contrario."
  },
  {
    "objectID": "unidad_2/raster_data_in_grass.html#reportes-y-estadísticas-de-mapas-raster",
    "href": "unidad_2/raster_data_in_grass.html#reportes-y-estadísticas-de-mapas-raster",
    "title": "Datos raster en GRASS GIS",
    "section": "Reportes y estadísticas de mapas raster",
    "text": "Reportes y estadísticas de mapas raster\nExisten diversos módulos que nos permiten generar reportes y estadísticas de los mapas raster. Algunos de los más usados son:\n\nr.report: reporta área y número de celdas de un mapa raster\nr.coin: reporta la matriz o tabla de coincidencia entre dos mapas raster\nr.univar: calcula estadísticas descriptivas a partir de las celdas no nulas de un mapa raster\nr.stats: calcula el área de cada una de las categorías o intervalos de un mapa raster\nr.statistics y r.stats.zonal: estadística zonal\nr.neighbors: estadística local basada en las celdas vecinas\n\nVeamos algunos ejemplos:\n# reportes\nr.report map=zipcodes,landclass96 units=h,p\nr.coin first=zipcodes second=landclass96 units=p\n\n# estadísticas descriptivas\nr.univar map=elevation\n\n# estadística zonal: elevacion promedio por código postal\nr.stats.zonal base=zipcodes cover=elevation method=average output=zipcodes_elev_avg"
  },
  {
    "objectID": "unidad_2/raster_data_in_grass.html#footnotes",
    "href": "unidad_2/raster_data_in_grass.html#footnotes",
    "title": "Datos raster en GRASS GIS",
    "section": "Notas",
    "text": "Notas\n\n\nThe &&& and ||| operators handle null values differently to other operators. See the section entitled NULL support in the manual for more details.↩︎\nThe &&& and ||| operators handle null values differently to other operators. See the section entitled NULL support in the manual for more details.↩︎"
  },
  {
    "objectID": "unidad_2/raster_data_in_grass.html#resampleo-e-interpolacion",
    "href": "unidad_2/raster_data_in_grass.html#resampleo-e-interpolacion",
    "title": "Datos raster en GRASS GIS",
    "section": "Resampleo e interpolacion",
    "text": "Resampleo e interpolacion\nEl procesamiento de mapas raster de GRASS se realiza siempre en la configuración actual de la región, es decir, se utiliza la extensión y resolución actual de la región. Si la resolución de la región difiere de la del mapa(s) raster de entrada, se realiza un remuestreo sobre la marcha (remuestreo del vecino más cercano). Si no se desea, los mapas de entrada deben remuestrearse previamente con uno de los módulos específicos.\nLos siguientes módulos están disponibles para la reinterpolación de mapas raster “rellenos” (datos continuos) a una resolución diferente:\n\nr.resample utiliza el remuestreo incorporado, por lo que debería producir resultados idénticos al remuestreo sobre la marcha realizado a través de los módulos de importación raster.\nr.resamp.interp remuestreo con el método del vecino más cercano, bilineal y bicúbico. Para r.resamp.interp method=bilinear y method=bicubic, los valores ráster se tratan como muestras en el centro de cada celda ráster, definiendo una superficie continua a trozos. Los valores raster resultantes se obtienen muestreando la superficie en el centro de cada celda de la región. Como el algoritmo sólo interpola, y no extrapola, se pierde un margen de 0,5 (para bilineal) o 1,5 (para bicúbica) celdas de la extensión de la trama original. Cualquier muestra tomada dentro de este margen será nula.\nr.resamp.rst (Regularized Spline with Tension - RST): Se comporta de forma similar, es decir, calcula una superficie asumiendo que los valores son muestras en el centro de cada celda del raster, y muestrea la superficie en el centro de cada celda de la región.\nr.resamp.bspline Interpolación spline bicúbica o bilineal con regularización Tykhonov.\nPara r.resamp.stats sin -w, el valor de cada celda de región es el agregado elegido de los valores de todas las celdas ráster cuyos centros caen dentro de los límites de la celda de región. Con -w, las muestras se ponderan de acuerdo con la proporción de la celda ráster que cae dentro de los límites de la celda de la región, por lo que el resultado normalmente no se ve afectado por el error de redondeo.\nr.fillnulls para el relleno de agujeros (por ejemplo, SRTM DEM).\n\nAdemás, hay módulos disponibles para la reinterpolación de mapas “dispersos” (puntos o líneas dispersos):\n\nInterpolación de la media ponderada de la distancia inversa (IDW) (r.surf.idw)\nInterpolación a partir de curvas de nivel (r.contour)\nVarios módulos vectoriales para la interpolación: v.surf.*\nPara datos Lidar y similares, r.in.pdal y r.in.xyz permiten cargar y agrupar datos ASCII x,y,z sin cuadricular en un nuevo mapa ráster. El usuario puede elegir entre diversos métodos estadísticos para crear el nuevo mapa de trama."
  },
  {
    "objectID": "unidad_2/raster_data_in_grass.html#parcheo-y-agregaciones-temporales",
    "href": "unidad_2/raster_data_in_grass.html#parcheo-y-agregaciones-temporales",
    "title": "Datos raster en GRASS GIS",
    "section": "Parcheo y agregaciones temporales",
    "text": "Parcheo y agregaciones temporales\n\nr.patch: Crea un mapa raster utilizando los valores de las categorías de uno (o más) mapa(s) para rellenar las áreas “sin datos” en otro mapa\n\n\n\n\nParcheo de mapas raster\n\n\n\nr.series: Permite agregar una lista de mapas con diferentes métodos como promedio, mínimo, máximo, etc.\n\n\n\n\nOperaciones con varios mapas raster"
  },
  {
    "objectID": "unidad_2/raster_data_in_grass.html#correlación-regresión-simple-y-múltiple",
    "href": "unidad_2/raster_data_in_grass.html#correlación-regresión-simple-y-múltiple",
    "title": "Datos raster en GRASS GIS",
    "section": "Correlación, regresión simple y múltiple",
    "text": "Correlación, regresión simple y múltiple\n\nr.covar: matriz de covarianza o correlación entre mapas raster\nr.regression.line: regresión lineal simple\nr.regression.multi: regresión lineal múltiple\n\n# correlación\ng.region raster=elevation\nr.covar -r map=elevation,aspect,slope\n\n# regresión simple\ng.region raster=elev_srtm_30m -p\nr.regression.line mapx=elev_ned_30m mapy=elev_srtm_30m \n\n# regresión múltiple\ng.region raster=soils_Kfactor -p\nr.regression.multi mapx=elevation,aspect,slope mapy=soils_Kfactor \\\n  residuals=soils_Kfactor.resid estimates=soils_Kfactor.estim"
  },
  {
    "objectID": "unidad_2/raster_data_in_grass.html#compresión-de-datos",
    "href": "unidad_2/raster_data_in_grass.html#compresión-de-datos",
    "title": "Datos raster en GRASS GIS",
    "section": "Compresión de datos",
    "text": "Compresión de datos\nTodos los tipos de mapas raster de GRASS GIS están por defecto comprimidos con ZSTD si la librería está disponible, de lo contrario se usa ZLIB. El método de compresión se establece a través de la variable de ambiente GRASS_COMPRESSOR. Los métodos disponibles son: RLE, ZLIB, LZ4, BZIP2, o ZSTD.\nImportante: la compresión de archivos NULL puede ser desactivada con export GRASS_COMPRESS_NULLS=0. La compresión de archivos NULL para un mapa raster en particular puede ser manejada con r.null -z.\nLos mapas raster de punto flotante (FCELL, DCELL) nunca usan compresión RLE; son comprimidos con ZLIB, LZ4, BZIP2, ZSTD o sin compresión.\nLa descompresión está controlada por el módulo r.compress, no por la variable de entorno."
  },
  {
    "objectID": "unidad_2/exercise_sentinel2.html",
    "href": "unidad_2/exercise_sentinel2.html",
    "title": "Ejercicio: Datos satelitales en GRASS GIS",
    "section": "",
    "text": "En este ejercicio, trabajaremos con imágenes del satélite Sentinel 2 en GRASS GIS. Vamos a recorrer algunos módulos específicos para la búsqueda, descarga e importación de datos Sentinel, abordar los diferentes pasos a seguir en función del nivel de procesamiento, enmascarar nubes y sombras de nubes, realizar segmentaciones y clasificaciones supervisadas.\nAntes de empezar y para ganar tiempo, conectamos nuestro drive e instalamos GRASS en Google Colab.\n# import drive from google colab\nfrom google.colab import drive\n# mount drive\ndrive.mount(\"/content/drive\")\n%%bash\nDEBIAN_FRONTEND=noninteractive \nsudo add-apt-repository ppa:ubuntugis/ubuntugis-unstable \napt update \napt install grass subversion grass-dev\napt remove libproj22\nChequeamos el path de instalación de GRASS\n!grass --config path\ne instalamos otras librerías de python que nos serán útiles.\n!pip install pygdal\n!pip install sentinelsat\n!pip install scikit-learn"
  },
  {
    "objectID": "unidad_2/exercise_sentinel2.html#datos-sentinel-2",
    "href": "unidad_2/exercise_sentinel2.html#datos-sentinel-2",
    "title": "Ejercicio: Datos satelitales en GRASS GIS",
    "section": "Datos Sentinel 2",
    "text": "Datos Sentinel 2\n\n\n\nLanzamiento: Sentinel-2A en 2015, Sentinel-2B en 2017\nTiempo de revisita: ~5 días\nCobertura sistemática de áreas terrestres y costeras entre los 84°N y 56°S\n13 bandas espectrales con resolución espacial de 10 m (VIS y NIR), 20 m (red-edge y SWIR) y 60 m (otras)\n\n\n\n\n\n\n\n\n\n\nESA - Satélites Copernicus Sentinel. Más información en: https://www.copernicus.eu/en/about-copernicus/infrastructure/discover-our-satellites\n\n\n\n\n\nDistribución de bandas de Sentinel 2 comparadas con Landsat\n\n\n\nNiveles de procesamiento Sentinel 2\n\nL1C: Reflectancia a tope de atmósfera o Top of Atmosphere (TOA). Disponibles desde el lanzamiento.\nL2A: Reflectancia Superficial o Bottom of Atmosphere (BOA), i.e., los datos han sido corregidos para remover los efectos de la atmósfera. Sólo desde 2019.\n\n\n\n\n\n\n\nImportante\n\n\n\nLong Term Archive (LTA)\nTodos los productos (1C o 2A) de más de un año son movidos fuera de línea y se requiere un tiempo de espera para ponerlos a disposición del usuario. Esto dificulta la automatización de tareas con productos de más de 12 meses de antigüedad."
  },
  {
    "objectID": "unidad_2/imagery_data_in_grass.html#manos-a-la-obra",
    "href": "unidad_2/imagery_data_in_grass.html#manos-a-la-obra",
    "title": "Datos satelitales en GRASS GIS",
    "section": "",
    "text": "Iniciamos GRASS GIS en posgar2007_4_cba/PERMANENT\n\nimport os\n\n# data directory\nhomedir = os.path.expanduser('~')\n\n# GRASS GIS database variables\ngrassdata = os.path.join(homedir, \"grassdata\")\nproject = \"posgar2007_4_cba\"\nmapset = \"PERMANENT\"\n\n\n# import standard Python packages we need\nimport sys\nimport subprocess\n\n# ask GRASS GIS where its Python packages are to be able to run it from the notebook\nsys.path.append(\n    subprocess.check_output([\"grass\", \"--config\", \"python_path\"], text=True).strip()\n)\n\nAhora sí, estamos listos para importar los paquetes de GRASS e iniciar una sesión:\n\n# import the GRASS GIS packages we need\nimport grass.script as gs\nimport grass.jupyter as gj\n\n# Start the GRASS GIS Session\nsession = gj.init(grassdata, project, mapset)\n\nCorroboramos la proyección\n\n# check the CRS\ngs.read_command(\"g.proj\", flags=\"p\")\n\nCreamos un nuevo mapset llamado landsat8:\n\n# Create a new mapset\ng.mapset -c mapset=landsat8\n\nListamos los mapsets accesibles\n\n# list all the mapsets in the search path\ng.mapsets -p\n\nListamos los mapas vectoriales disponibles\n\n# list vector maps in all mapsets in the search path\ng.list type=vector\n\nExtraemos el radio urbano de Córdoba\n\n# extract Cordoba urban area from `radios_urbanos`\nv.extract input=radios_urbanos \\\n  where=\"nombre == 'CORDOBA'\" \\\n  output=radio_urbano_cba\n\nEstablecemos la región computacional al radio urbano de Córdoba\n\n# set the computational region to the extent of Cordoba urban area\ng.region -p vector=radio_urbano_cba\n\n\n\n\nInstalar la extensión i.landsat:\n\n# install i.landsat toolset\ng.extension extension=i.landsat\n\nBuscar escenas de Landsat 8 disponibles\n\n# search for Landsat 8 scenes\ni.landsat.download -l settings=$HOME/gisdata/USGS_SETTING.txt \\\n  dataset=landsat_8_c1 clouds=35 \\\n  start='2019-10-27' end='2020-03-15'\n\nNO EJECUTAR! Descargar las escenas seleccionadas\n\n# download selected scenes\n# i.landsat.download settings=$HOME/gisdata/USGS_SETTING.txt \\\n#   id=LC82290822020062LGN00,LC82290822020014LGN00 \\\n#   output=$HOME/gisdata/landsat_data\n\nImprimir las bandas dentro de la carpeta\n\n# print all landsat bands within landsat_data folder\ni.landsat.import -p input=$HOME/gisdata/landsat_data\n\nImprimir sólo las bandas seleccionadas con un patrón\n\n# print a selection of bands - might be sloooow\ni.landsat.import -p \\\n  input=$HOME/gisdata/landsat_data \\\n  pattern='B(2|3|4|5|6|8)'\n\nImportar bandas, recortar y reproyectar al vuelo\n\n# import all bands, subset to region and reproject\ni.landsat.import -r \\\n  input=$HOME/gisdata/landsat_data \\\n  extent=region\n\nListar bandas importadas y revisar metadatos\n\n# list raster maps\ng.list type=raster mapset=.\n\n# check metadata of some imported bands\nr.info map=LC08_L1TP_229082_20200114_20200127_01_T1_B4\nr.info map=LC08_L1TP_229082_20200114_20200127_01_T1_B8\n\n\n\n\nSelect directoryImport settings\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWorkflow de pre-procesamiento de datos satelitales\n\n\n\n\n\n\nLos datos L8 OLI vienen en 16-bit con rango de datos entre 0 y 65535.\ni.landsat.toar convierte ND en reflectancia TOA (y temperatura de brillo) para todos los sensores Landsat. Opcionalmente proporciona reflectancia de superficie (BOA) después de la corrección DOS.\ni.atcorr proporciona un método de corrección atmosférica más complejo para gran variedad de sensores (S6).\n\nDefinir region computacional a banda de 30m\n\n# set the region to a 30m band\ng.region -p raster=LC08_L1TP_229082_20200114_20200127_01_T1_B4\n\nConvertir DN a reflectancia superficial y temperatura - método DOS\n\n# convert from DN to surface reflectance and temperature - requires to uncompress data locally\ni.landsat.toar \\\n  input=LC08_L1TP_229082_20200114_20200127_01_T1_B \\\n  output=LC08_229082_20200114_toar_B \\\n  sensor=oli8 \\\n  metfile=$HOME/gisdata/landsat_data/LC08_L1TP_229082_20200114_20200127_01_T1_MTL.txt \\\n  method=dos1\n\nCorroborar info antes y después de la conversión para una banda\n\n# list output maps\ng.list type=raster mapset=. pattern=\"*toar*\"\n\n# check info before and after for one band\nr.info map=LC08_L1TP_229082_20200114_20200127_01_T1_B3\nr.info map=LC08_229082_20200114_toar_B3\n\n\nBanda 10 de L8 con la paleta de colores kelvin\n\nTarea:\nAhora, sigan los mismos pasos para la escena del 02/03/2020. Qué notan de diferente?\n\n\n\n\nAjuste de colores para una composición RGB color natural\n\n# enhance the colors\ni.colors.enhance \\\n  red=LC08_229082_20200114_toar_B4 \\\n  green=LC08_229082_20200114_toar_B3 \\\n  blue=LC08_229082_20200114_toar_B2 \\\n  strength=95\n\nMostrar la combinación RGB - d.rgb\n\n# display RGB\nd.mon wx0\nd.rgb \\\n  red=LC08_229082_20200114_toar_B4 \\\n  green=LC08_229082_20200114_toar_B3 \\\n  blue=LC08_229082_20200114_toar_B2\n\n\nTarea:\nSeguir los mismos pasos para una composición falso color 543. Sobre qué bandas debieran realizar el ajuste?\n\n \nComposiciones color natural 432 y falso color 543\n\n\n\n\nLandsat 8 proporciona una banda de calidad (QA) con valores enteros de 16 bits que representan las combinaciones de superficie, atmósfera y condiciones del sensor que pueden afectar la utilidad general de un determinado pixel.\nLa extensión i.landsat.qa reclasifica la banda QA de Landsat 8 de acuerdo a la calidad del pixel.\n\nMás información sobre la banda QA de L8:https://www.usgs.gov/core-science-systems/nli/landsat\nCrear las reglas para identificar las nubes y sombras de nubes\n\n# create a rule set\ni.landsat.qa \\\n  collection=1 \\\n  cloud_shadow_confidence=\"Medium,High\" \\\n  cloud_confidence=\"Medium,High\" \\\n  output=Cloud_Mask_rules.txt\n\nReclasificar la banda QA en función de las reglas\n\n# reclass the BQA band based on the rule set created\nr.reclass \\\n  input=LC08_L1TP_229082_20200114_20200127_01_T1_BQA \\\n  output=LC08_229082_20200114_Cloud_Mask \\\n  rules=Cloud_Mask_rules.txt\n\nReporte del porcentaje de nubes y sombras\n\n# report % of clouds and shadows\nr.report -e map=LC08_229082_20200114_Cloud_Mask units=p\n\nMostrar el mapa reclasificado\n\n# display reclassified map over RGB\nd.mon wx0\nd.rgb \\\n  red=LC08_229082_20200114_toar_B4 \\\n  green=LC08_229082_20200114_toar_B3 \\\n  blue=LC08_229082_20200114_toar_B2\nd.rast LC08_229082_20200114_Cloud_Mask\n\n\nTarea:\nComparar visualmente la cobertura de nubes con la composición RGB 543.\n\n \nComposición falso color y máscara de nubes\n\n\n\nVamos a usar la banda PAN (15 m) para mejorar la definición de las bandas espectrales de 30 m, por medio de:\n\ni.fusion.hpf, que aplica un método de adición basado en un filtro de paso alto\n\nOtros métodos están implementados en i.pansharpen\nInstalar la extensión i.fusion.hpf\n\n# Install the reqquired addon\ng.extension extension=i.fusion.hpf\n\nCambiar la región a la banda PAN\n\n# Set the region to PAN band (15m)\ng.region -p raster=LC08_229082_20200114_toar_B8\n\nEjecutar la fusión\n\n# Apply the fusion based on high pass filter\ni.fusion.hpf -l -c pan=LC08_229082_20200114_toar_B8 \\\n  msx=`g.list type=raster mapset=. pattern=*_toar_B[1-7] separator=,` \\\n  suffix=_hpf \\\n  center=high \\\n  modulation=max \\\n  trim=0.0\n\nListar los mapas resultantes usando un patrón de búsqueda\n\n# list the fused maps\ng.list type=raster mapset=. pattern=*_hpf\n\nVisualizar las diferencias con la herramienta mapswipe\n\n# display original and fused maps\ng.gui.mapswipe \\\n  first=LC08_229082_20200114_toar_B5 \\\n  second=LC08_229082_20200114_toar_B5_hpf\n\n\nDatos originales 30 m y datos fusionados 15 m\n\n\n\nEstablecer la máscara de nubes para evitar el cómputo sobre las nubes\n\n# Set the cloud mask to avoid computing over clouds\nr.mask raster=LC08_229082_20200114_Cloud_Mask\n\nCalcular el NDVI y establecer la paleta de colores\n\n# Compute NDVI\nr.mapcalc \\\n  expression=\"LC08_229082_20200114_NDVI = \\\n  (LC08_229082_20200114_toar_B5_hpf - LC08_229082_20200114_toar_B4_hpf) / \\\n  (LC08_229082_20200114_toar_B5_hpf + LC08_229082_20200114_toar_B4_hpf) * 1.0\"\n# Set the color palette\nr.colors map=LC08_229082_20200114_NDVI color=ndvi\n\nCalcular NDWI y establecer la paleta de colores\n\n# Compute NDWI\nr.mapcalc expression=\"LC08_229082_20200114_NDWI = \\\n  (LC08_229082_20200114_toar_B5_hpf - LC08_229082_20200114_toar_B6_hpf) / \\\n  (LC08_229082_20200114_toar_B5_hpf + LC08_229082_20200114_toar_B6_hpf) * 1.0\"\n# Set the color palette\nr.colors map=LC08_229082_20200114_NDWI color=ndwi\n\nMostrar los mapas\n\n# display maps in different monitors\nd.mon wx0\nd.rast map=LC08_229082_20200114_NDVI\n\nd.mon wx1\nd.rast map=LC08_229082_20200114_NDWI\n\n \nNDVI y NDWI a partir de datos Landsat 8\n\nTarea:\nEstimar NDVI y NDWI para la otra escena usando el módulo i.vi\n\n\n\n\n\nAgrupar las bandas (i.e., hacer un stack): i.group\nGenerar firmas para n número de clases: i.cluster\nClasificar: i.maxlik\n\nListar los mapas usando un patrón\n\n# list the bands needed for classification\ng.list type=raster mapset=. pattern=*_toar*_hpf\n\nCrear un grupo de imágenes o stack\n\n# add maps to an imagery group for easier management\ni.group group=l8 subgroup=l8 \\\n input=`g.list type=raster mapset=. pattern=*_toar*_hpf sep=\",\"`\n\nObtener estadísticos -firmas- para las n clases de interés con una muestra de pixeles\n\n# statistics for unsupervised classification\ni.cluster group=l8 subgroup=l8 \\\n sig=l8_hpf \\\n classes=7 \\\n separation=0.6\n\nRealizar la clasificación no supervisada de toda la imagen\n\n# Maximum Likelihood unsupervised classification\ni.maxlik group=l8 subgroup=l8 \\\n sig=l8_hpf \\\n output=l8_hpf_class \\\n rej=l8_hpf_rej\n\nMostrar el mapa clasificado\n\n# display results\nd.mon wx0\nd.rast map=l8_hpf_class\n\n\nInformación derivada adicional podría obtenerse con los siguientes módulos, entre otros:\n\nmedidas de textura: r.texture,\nmedidas de diversidad: r.diversity,\nestadísticas locales con información de contexto: r.neighbors,\ntransformación tasseled cap: i.tasscap,\netc.\n\n\n\n\n\nTopic classification en los manuales de GRASS GIS\nImage classification en la wiki\nEjemplos de clasificación en el curso dictado en Noruega en 2018\nClasificación con Random Forest en la presentación del OpenGeoHub Summer School 2018 en Praga\nDetección de cambios con Landsat"
  },
  {
    "objectID": "unidad_2/imagery_data_in_grass.html#iniciamos-grass-gis",
    "href": "unidad_2/imagery_data_in_grass.html#iniciamos-grass-gis",
    "title": "Datos satelitales en GRASS GIS",
    "section": "Iniciamos GRASS GIS",
    "text": "Iniciamos GRASS GIS\nIniciamos GRASS GIS en el proyecto posgar2007_4_cba y mapset PERMANENT\n\nimport os\n\n# data directory\nhomedir = \"/content/drive/MyDrive/curso_grass_2023\"\n\n# GRASS GIS database variables\ngrassdata = os.path.join(homedir, \"grassdata\")\nproject = \"posgar2007_4_cba\"\nmapset = \"PERMANENT\"\n\n\n# import standard Python packages we need\nimport sys\nimport subprocess\n\n# ask GRASS GIS where its Python packages are to be able to run it from the notebook\nsys.path.append(\n    subprocess.check_output([\"grass\", \"--config\", \"python_path\"], text=True).strip()\n)\n\nAhora sí, estamos listos para importar los paquetes de GRASS e iniciar una sesión:\n\n# import the GRASS GIS packages we need\nimport grass.script as gs\nimport grass.jupyter as gj\n\n# Start the GRASS GIS Session\nsession = gj.init(grassdata, project, mapset)\n\nCorroboramos la proyección\n\n# check the CRS\nprint(gs.read_command(\"g.proj\", flags=\"p\"))"
  },
  {
    "objectID": "unidad_2/imagery_data_in_grass.html#crear-un-nuevo-mapset",
    "href": "unidad_2/imagery_data_in_grass.html#crear-un-nuevo-mapset",
    "title": "Datos satelitales en GRASS GIS",
    "section": "Crear un nuevo mapset",
    "text": "Crear un nuevo mapset\nPara diferenciar sesiones dentro del curso, vamos a crear un nuevo mapset llamado landsat8:\n\n# Create a new mapset\ngs.run_command(\"g.mapset\", \n               mapset=\"landsat8\",\n               flags=\"c\")\n\n\n# Check we are in the mapset just created\ngs.run_command(\"g.mapset\",\n               flags=\"p\")\n\nListamos los mapsets accesibles para corroborar que tenemos acceso a PERMANENT\n\n# list all the mapsets in the search path\ngs.mapsets(search_path=True)\n\n\n\n\n\n\n\nNota\n\n\n\nDesde cualquier mapset en el que estemos trabajando, siempre vamos a tener acceso a PERMANENT.\n\n\nListemos los mapas vectoriales disponibles\n\n# list vector maps in all mapsets in the search path\ngs.list_grouped(type=\"vector\")"
  },
  {
    "objectID": "unidad_2/imagery_data_in_grass.html#región-de-interés",
    "href": "unidad_2/imagery_data_in_grass.html#región-de-interés",
    "title": "Datos satelitales en GRASS GIS",
    "section": "Región de interés",
    "text": "Región de interés\nComo primer paso para trabajar con datos raster,necesitamos establecer la región computacional. Para ello, vamos a extraer el radio urbano de Córdoba del vector de radios urbanos y luego lo vamos a usar para establecer los límites de nuestra region computacional.\n\n# extract Cordoba urban area from `radios_urbanos`\ngs.run_command(\"v.extract\", \n               input=\"radios_urbanos\", \n               where=\"nombre == 'CORDOBA'\", \n               output=\"radio_urbano_cba\")\n\n\n# set the computational region to the extent of Cordoba urban area\ngs.run_command(\"g.region\", \n               flags=\"p\", \n               vector=\"radio_urbano_cba\")"
  },
  {
    "objectID": "unidad_2/imagery_data_in_grass.html#descargar-e-importar-los-datos-l8",
    "href": "unidad_2/imagery_data_in_grass.html#descargar-e-importar-los-datos-l8",
    "title": "Datos satelitales en GRASS GIS",
    "section": "Descargar e importar los datos L8",
    "text": "Descargar e importar los datos L8\nInstalar la extensión i.landsat:\n\n# install i.landsat toolset\ngs.run_command(\"g.extension\",\n               extension=\"i.landsat\")\n\nBuscar escenas de Landsat 8 disponibles\n\n# search for Landsat 8 scenes\ngs.run_command(\"i.landsat.download\", \n               settings=os.path.join(homedir, \"landsat\"),\n               dataset=\"landsat_8_c1\",\n               clouds=\"35\",\n               start=\"2019-10-27\",\n               end=\"2020-03-15\",\n               flags=\"l\")\n\nNO EJECUTAR! Descargar las escenas seleccionadas\n\n# download selected scenes\ngs.run_command(\"i.landsat.download\", \n               settings=os.path.join(homedir, \"landsat\"),\n               id=\"LC82290822020062LGN00,LC82290822020014LGN00\",\n               output=os.path.join(homedir, \"gisdata\", \"landsat_data\"))\n\nImprimir las bandas dentro de la carpeta\n\n# print all landsat bands within landsat_data folder\ngs.run_command(\"i.landsat.import\",\n               input=os.path.join(homedir, \"gisdata\", \"landsat_data\"),\n               flags=\"p\")\n\nImprimir sólo las bandas seleccionadas con un patrón\n\n# print a selection of bands - might be sloooow\ngs.run_command(\"i.landsat.import\",\n               input=os.path.join(homedir, \"gisdata\", \"landsat_data\"), \n               pattern=\"B(2|3|4|5|6|8)\",\n               flags=\"p\")\n\nImportar bandas, recortar y reproyectar al vuelo\n\n# import all bands, subset to region and reproject\ngs.run_command(\"i.landsat.import\", \n               input=os.path.join(homedir, \"gisdata\", \"landsat_data\"), \n               extent=\"region\",\n               flags=\"r\")\n\nListar bandas importadas y revisar metadatos\n\n# list raster maps\ngs.list_grouped(type=\"raster\")[\"landsat8\"]\n\n\n# check metadata of some imported bands\ngs.raster_info(map=\"LC08_L1TP_229082_20200114_20200127_01_T1_B4\")"
  },
  {
    "objectID": "unidad_2/imagery_data_in_grass.html#pre-procesamiento-de-datos-satelitales",
    "href": "unidad_2/imagery_data_in_grass.html#pre-procesamiento-de-datos-satelitales",
    "title": "Datos satelitales en GRASS GIS",
    "section": "Pre-procesamiento de datos satelitales",
    "text": "Pre-procesamiento de datos satelitales\n\n\n\nWorkflow de pre-procesamiento de datos satelitales\n\n\n\nDe número digital (ND) a reflectancia y temperatura\n\nLos datos L8 OLI vienen en 16-bits con rango de datos entre 0 y 65535.\ni.landsat.toar convierte los números digitales (ND) en reflectancia TOA (y temperatura de brillo) para todos los sensores Landsat. Opcionalmente proporciona reflectancia de superficie (BOA) después de la corrección DOS.\ni.atcorr proporciona un método de corrección atmosférica más complejo para gran variedad de sensores (S6).\n\nAntes de comenzar a procesar los datos, vamos a definir la resolución de la región computacional a una banda de 30 m.\n\n# set the region to a 30m band\ngs.run_command(\"g.region\", \n               raster=\"LC08_L1TP_229082_20200114_20200127_01_T1_B4\", \n               flags=\"p\")\n\nAhora sí, convertimos los ND a reflectancia superficial y temperatura usando el método Dark Object Substraction (DOS).\n\n# convert from DN to surface reflectance and temperature\nmetadata = os.path.join(homedir, \"gisdata\", \"landsat_data\", \"LC08_L1TP_229082_20200114_20200127_01_T1_MTL.txt\")\ngs.run_command(\"i.landsat.toar\",\n               input=\"LC08_L1TP_229082_20200114_20200127_01_T1_B\",\n               output=\"LC08_229082_20200114_SR_B\",\n               sensor=\"oli8\",\n               metfile=metadata,\n               method=\"dos1\")\n\nCorroboremos los metadatos antes y después de la conversión ND &gt;&gt; RS para una banda.\n\n# list output maps\ngs.list_grouped(type=\"raster\",\n                pattern=\"*SR*\")[\"landsat8\"]\n\n\n# check info before and after for one band\nprint(gs.read_command(\"r.info\", \n                      map=\"LC08_L1TP_229082_20200114_20200127_01_T1_B3\"))\n\n\nprint(gs.read_command(\"r.info\", \n                      map=\"LC08_229082_20200114_SR_B3\"))\n\n\n# Visualize results\nb3_map=gj.InteractiveMap(width = 500, tiles=\"OpenStreetMap\")\nb3_map.add_raster(\"LC08_L1TP_229082_20200114_20200127_01_T1_B3\")\nb3_map.add_raster(\"LC08_229082_20200114_SR_B3\")\nb3_map.add_layer_control(position = \"bottomright\")\nb3_map.show()\n\n\n\n\n\n\n\nTarea Opcional\n\n\n\nSeguir los mismos pasos para la escena del 02/03/2020. ¿Qué notan de diferente?\n\n\n\n\nAjuste de color y composiciones RGB\nPara lograr una buena visualización en composiciones RGB, primero realizamos un ajuste de colores utilizando el módulo i.colors.enhance.\n\n# enhance the colors\ngs.run_command(\"i.colors.enhance\",\n               red=\"LC08_229082_20200114_SR_B4\",\n               green=\"LC08_229082_20200114_SR_B3\", \n               blue=\"LC08_229082_20200114_SR_B2\",\n               strength=\"95\")\n\nVisualicemos la combinacion RGB color natural usando gj.Map.\n\n# display RGB\nrgb_map = gj.Map(width=450, use_region=True)\nrgb_map.d_rgb(red=\"LC08_229082_20200114_SR_B4\",\n              green=\"LC08_229082_20200114_SR_B3\", \n              blue=\"LC08_229082_20200114_SR_B2\",)\nrgb_map.show()\n\n\n\n\n\n\n\nTarea\n\n\n\nHagamos una composición falso color 543. ¿Sobre qué bandas debieran realizar el ajuste?\n\n\n\n\nEnmascarado de nubes con banda QA\n\nLandsat 8 proporciona una banda de calidad (quality assessment, QA) con valores enteros de 16 bits que representan las combinaciones de superficie, atmósfera y condiciones del sensor que pueden afectar la utilidad general de un determinado pixel.\nLa extensión i.landsat.qa reclasifica la banda QA de Landsat 8 de acuerdo a la calidad del pixel.\n\n\n\n\n\n\n\nNota\n\n\n\nMás información sobre la banda QA de L8 en la guía de usuario.\n\n\nVamos a utilizar i.landsat.qa para crear las reglas necesarias para identificar las nubes y sombras de nubes en las escenas L8.\n\n# create a rule set\ngs.run_command(\"i.landsat.qa\",\n               dataset=\"landsat_8_c1\",\n               cloud_shadow_confidence=\"Medium,High\",\n               cloud_confidence=\"Medium,High\",\n               output=os.path.join(homedir, \"Cloud_Mask_rules.txt\"))\n\nCon las reglas que creamos anteriormente, reclasificamos la banda QA para obtener un mapa ráster que podamos luego usar como máscara.\n\n# reclass the BQA band based on the rule set created\ngs.run_command(\"r.reclass\",\n               input=\"LC08_L1TP_229082_20200114_20200127_01_T1_BQA\",\n               output=\"LC08_229082_20200114_Cloud_Mask\",\n               rules=os.path.join(homedir, \"Cloud_Mask_rules.txt\"))\n\nPara estimar la superficie cubierta por nubes y sombras de nubes, usamos el módulo r.report.\n\n# report % of clouds and shadows\nprint(gs.read_command(\"r.report\",\n                      map=\"LC08_229082_20200114_Cloud_Mask\",\n                      units=\"p\",\n                      flags=\"e\"))\n\nVisualizamos el mapa reclasificado.\n\n# display reclassified map over RGB\nrgb_map.d_rast(map=\"LC08_229082_20200114_Cloud_Mask\")\nrgb_map.show()"
  },
  {
    "objectID": "unidad_2/imagery_data_in_grass.html#semantic-labels",
    "href": "unidad_2/imagery_data_in_grass.html#semantic-labels",
    "title": "Datos satelitales en GRASS GIS",
    "section": "Semantic labels",
    "text": "Semantic labels\nUn concepto bastante nuevo en GRASS GIS son las etiquetas semánticas o semantic labels. Éstas son especialmente relevantes para las imágenes de satélite, ya que nos permiten identificar a qué sensor y banda corresponde una trama determinada. Estas etiquetas son especialmente relevantes a la hora de trabajar con colecciones de imágenes de satélite y también a la hora de clasificar diferentes escenas. Lo veremos más adelante, pero al generar una firma espectral para un determinado conjunto de bandas, puede reutilizarse para clasificar otra escena siempre que las etiquetas semánticas sean las mismas. Cuidado: aunque es posible reutilizar las firmas espectrales para cualquier escena con las mismas bandas, los cambios temporales (estaciones, impacto meteorológico) limitan su aplicabilidad sólo a escenas obtenidas más o menos al mismo tiempo."
  },
  {
    "objectID": "unidad_4/intro_temporal.html",
    "href": "unidad_4/intro_temporal.html",
    "title": "Intro a series de tiempo",
    "section": "",
    "text": "GRASS GIS es el primer SIG de código abierto que incorporó capacidades para gestionar, analizar, procesar y visualizar datos espacio-temporales, así como las relaciones temporales entre series de tiempo.\n\nCompletamente basado en metadatos, por lo que no hay duplicación de datos\nSigue una aproximación Snapshot, i.e., añade marcas de tiempo o timestamps a los mapas\nUna colección de mapas de la misma variable con timestamps se llama space-time dataset o STDS\nLos mapas en una STDS pueden tener diferentes extensiones espaciales y temporales\nTGRASS utiliza una base de datos SQLite para almacenar la extensión temporal y espacial de las STDS, así como las relaciones topológicas entre los mapas y entre las STDS en cada mapset.\n\nTGRASS o GRASS GIS temporal framework fue desarrollado por Sören Gebbert como parte de un proyecto Google Summer of Code en 2012. Detalles técnicos de la implementación pueden encontrarse en: Gebbert y Pebesma (2014), Gebbert y Pebesma (2017) y Gebbert et al. (2019).\n\n\n\nSpace time raster datasets (STRDS)\nSpace time 3D raster datasets (STR3DS)\nSpace time vector datasets (STVDS)\n\n\n\n\n\nEl tiempo puede definirse como intervalos (inicio y fin) o como instancias (sólo inicio)\nEl tiempo puede ser absoluto (por ejemplo, 2017-04-06 22:39:49) o relativo (por ejemplo, 4 años, 90 días)\nGranularidad es el mayor divisor común de todas las extensiones temporales (y posibles gaps) de los mapas de un STDS\n\n\n\n\nSeries de diferente granularidad y tipo de tiempo\n\n\n\nTopología se refiere a las relaciones temporales entre los intervalos de tiempo en una STDS\n\n\n\n\nRelaciones topológicas entre STDS y entre mapas\n\n\n\nMuestreo temporal se utiliza para determinar el estado de un proceso respecto un segundo proceso.\n\n\n\n\nMuestreo temporal\n\n\n\n\n\n\nt.*: Módulos generales para manejar STDS de todos los tipos\nt.rast.*: Módulos que tratan con STRDS\nt.rast3d.*: Módulos que tratan con STR3DS\nt.vect.*: Módulos que tratan con STVDS"
  },
  {
    "objectID": "unidad_4/intro_temporal.html#procesamiento-de-series-de-tiempo-en-grass-gis",
    "href": "unidad_4/intro_temporal.html#procesamiento-de-series-de-tiempo-en-grass-gis",
    "title": "Intro a series de tiempo",
    "section": "",
    "text": "Nociones básicas\nTGRASS framework\nCreación de series de tiempo\nÁlgebra temporal y variables temporales\nDistintos tipos de agregación\nEstadística zonal e islas de calor urbanas\nConexión con R\n\nGRASS GIS es el primer SIG de código abierto que incorporó capacidades para gestionar, analizar, procesar y visualizar datos espacio-temporales, así como las relaciones temporales entre series de tiempo."
  },
  {
    "objectID": "unidad_4/intro_temporal.html#tgrass-grass-temporal",
    "href": "unidad_4/intro_temporal.html#tgrass-grass-temporal",
    "title": "Intro a series de tiempo",
    "section": "TGRASS: GRASS Temporal",
    "text": "TGRASS: GRASS Temporal\n\nCompletamente basado en metadatos, por lo que no hay duplicación de datos\nSigue una aproximación Snapshot, i.e., añade marcas de tiempo o timestamps a los mapas\nUna colección de mapas de la misma variable con timestamps se llama space-time dataset o STDS\nLos mapas en una STDS pueden tener diferentes extensiones espaciales y temporales\nTGRASS utiliza una base de datos SQLite para almacenar la extensión temporal y espacial de las STDS, así como las relaciones topológicas entre los mapas y entre las STDS en cada mapset."
  },
  {
    "objectID": "unidad_4/intro_temporal.html#space-time-datasets",
    "href": "unidad_4/intro_temporal.html#space-time-datasets",
    "title": "Intro a series de tiempo",
    "section": "",
    "text": "Space time raster datasets (STRDS)\nSpace time 3D raster datasets (STR3DS)\nSpace time vector datasets (STVDS)"
  },
  {
    "objectID": "unidad_4/intro_temporal.html#otras-nociones-básicas-en-tgrass",
    "href": "unidad_4/intro_temporal.html#otras-nociones-básicas-en-tgrass",
    "title": "Intro a series de tiempo",
    "section": "",
    "text": "El tiempo puede definirse como intervalos (inicio y fin) o como instancias (sólo inicio)\nEl tiempo puede ser absoluto (por ejemplo, 2017-04-06 22:39:49) o relativo (por ejemplo, 4 años, 90 días)\nGranularidad es el mayor divisor común de todas las extensiones temporales (y posibles gaps) de los mapas de un STDS\n\n\n\n\nSeries de diferente granularidad y tipo de tiempo\n\n\n\nTopología se refiere a las relaciones temporales entre los intervalos de tiempo en una STDS\n\n\n\n\nRelaciones topológicas entre STDS y entre mapas\n\n\n\nMuestreo temporal se utiliza para determinar el estado de un proceso respecto un segundo proceso.\n\n\n\n\nMuestreo temporal"
  },
  {
    "objectID": "unidad_4/intro_temporal.html#módulos-temporales",
    "href": "unidad_4/intro_temporal.html#módulos-temporales",
    "title": "Intro a series de tiempo",
    "section": "",
    "text": "t.*: Módulos generales para manejar STDS de todos los tipos\nt.rast.*: Módulos que tratan con STRDS\nt.rast3d.*: Módulos que tratan con STR3DS\nt.vect.*: Módulos que tratan con STVDS"
  },
  {
    "objectID": "unidad_4/intro_temporal.html#tgrass-marco-general-y-flujo-de-trabajo",
    "href": "unidad_4/intro_temporal.html#tgrass-marco-general-y-flujo-de-trabajo",
    "title": "Intro a series de tiempo",
    "section": "TGRASS: marco general y flujo de trabajo",
    "text": "TGRASS: marco general y flujo de trabajo"
  },
  {
    "objectID": "unidad_4/intro_temporal.html#manos-a-la-obra-con-series-de-tiempo-raster-en-grass-gis",
    "href": "unidad_4/intro_temporal.html#manos-a-la-obra-con-series-de-tiempo-raster-en-grass-gis",
    "title": "Intro a series de tiempo",
    "section": "",
    "text": "Producto MODIS: MOD11B3 Collection 6\nTile: h12v12\nComposiciones mensuales\nResolución espacial: 5600m\nMapset modis_lst\n\n\n\n\n\n\nComandos GRASS\nComandos R\n\nIniciar GRASS GIS directamente en el mapset modis_lst\n\n# paths\ngrassdata='/home/veroandreo/grassdata/'\nlocation='posgar2007_4_cba'\nmapset='modis_lst'\n\n\nimport os\nimport subprocess\nimport sys\n\n# Ask GRASS GIS where its Python packages are to be able to start it from the notebook\nsys.path.append(\n    subprocess.check_output([\"grass\", \"--config\", \"python_path\"], text=True).strip()\n)\n\n# Importar los paquetes python de GRASS\nimport grass.script as gs\nimport grass.jupyter as gj\n\n# Iniciar GRASS\nsession = gj.init(grassdata, location, mapset)\n\nEstablecer región computacional y máscara\nListar los mapas raster y obtener información de uno de ellos\n\n# Get list of raster maps in the 'modis_lst' mapset\ng.list type=raster mapset=.\n\n# Get info from one of the raster maps\nr.info map=MOD11B3.A2015060.h12v12.single_LST_Day_6km\n\nEstablecer la región computacional\n\n# Set region to Cba boundaries with LST maps' resolution\ng.region -p vector=provincia_cba \\\n  align=MOD11B3.A2015060.h12v12.single_LST_Day_6km\n\nAplicar máscara\n\n# Set a MASK to Cba boundary\nr.mask vector=provincia_cba\n\n\n\n\nt.create  - Crea una tabla SQLite en la base de datos temporal - Permite manejar grandes cantidades de mapas usando el STDS como entrada - Necesitamos especificar: - tipo de mapas (raster, raster3d o vector) - tipo de tiempo (absoluto o relativo)\nCrear la STRDS\n\n# Create the STRDS\nt.create type=strds temporaltype=absolute output=LST_Day_monthly \\\n  title=\"Monthly LST Day 5.6 km\" \\\n  description=\"Monthly LST Day 5.6 km MOD11B3.006 Cordoba, 2015-2019\"\n\nChequear si la STRDS fue creada\n\n# Check if the STRDS is created\nt.list type=strds\n\nObtener información sobre la STRDS\n\n# Get info about the STRDS\nt.info input=LST_Day_monthly\n\n\n\n\nt.register  - Asigna o agrega timestamps a los mapas - Necesitamos: - el STDS vacío como entrada, i.e., la tabla SQLite contenedora, - la lista de mapas que se registrarán, - la fecha de inicio, - la opción de incremento junto con -i para la creación de intervalos\nAñadir timestamps a los mapas, i.e., registrar mapas\n\n# Add time stamps to maps (i.e., register maps)\nt.register -i input=LST_Day_monthly \\\n maps=`g.list type=raster pattern=\"MOD11B3*LST_Day*\" separator=comma` \\\n start=\"2015-01-01\" increment=\"1 months\"\n\nChequear la información sobre la STRDS nuevamente\n\n# Check info again\nt.info input=LST_Day_monthly\n\nObtener la lista de mapas en la STRDS\n\n# Check the list of maps in the STRDS\nt.rast.list input=LST_Day_monthly\n\nChequear los valores mínimos y máximos de cada mapa\n\n# Check min and max per map\nt.rast.list input=LST_Day_monthly columns=name,min,max\n\nPara más opciones, ver el manual de t.register y la wiki sobre opciones para registrar mapas en STDS.\nRepresentación gráfica de STDS\nCrear una representación gráfica de la serie de tiempo\n\n# graphical representation of our STRDS\ng.gui.timeline inputs=LST_Day_monthly\n\n\nVer el manual de g.gui.timeline\n\n\n\n\nRealiza una amplia gama de operaciones de álgebra temporal y espacial basadas en la topología temporal de los mapas\n\nOperadores temporales: unión, intersección, etc.\nFunciones temporales: start_time(), start_doy(), etc.\nOperadores espaciales (subconjunto de r.mapcalc)\nModificador de vecindario temporal: [x,y,t]\nOtras funciones temporales como t_snap(), buff_t() o t_shift()\n\n\n¡pueden combinarse en expresiones complejas!\n\n\nRe-escalar a grados Celsius\n\n# Re-scale data to degrees Celsius\nt.rast.algebra basename=LST_Day_monthly_celsius suffix=gran \\\n  expression=\"LST_Day_monthly_celsius = LST_Day_monthly * 0.02 - 273.15\"\n\nVer info de la nueva serie de tiempo\n\n# Check info\nt.info LST_Day_monthly_celsius\n\n\n\n\nGráfico temporal de LST para la ciudad de Córdoba, Argentina\n\n# LST time series plot for Cba city center\ng.gui.tplot strds=LST_Day_monthly_celsius \\\n  coordinates=4323478.531282977,6541664.09350761 \\\n  title=\"Monthly LST. City center of Cordoba\" \\\n  xlabel=\"Time\" ylabel=\"LST\"\n\nPara un único punto, ver g.gui.tplot. Para un vector de puntos, ver t.rast.what.\n\nLas coordenadas del punto pueden ser escritas directamente, copiadas desde el mapa o seleccionadas interactivamente."
  },
  {
    "objectID": "unidad_4/intro_temporal.html#listas-y-selecciones",
    "href": "unidad_4/intro_temporal.html#listas-y-selecciones",
    "title": "Intro a series de tiempo",
    "section": "Listas y selecciones",
    "text": "Listas y selecciones\n\nt.list para listar las STDS y los mapas registrados en la base de datos temporal,\nt.rast.list para mapas en series temporales de rasters, y\nt.vect.list para mapas en series temporales de vectores.\n\n\nVariables usadas para hacer las listas y selecciones\nSTRDS:id, name, creator, mapset, temporal_type, creation_time, start_time, end_time, north, south, west, east, nsres, ewres, cols, rows, number_of_cells, min, max\nSTVDS:id, name, layer, creator, mapset, temporal_type, creation_time, start_time, end_time, north, south, west, east, points, lines, boundaries, centroids, faces, kernels, primitives, nodes, areas, islands, holes, volumes\n\nEjemplos de listas y selecciones\nMapas cuyo valor mínimo es menor o igual a 10\n\n# Maps with minimum value lower than or equal to 10\nt.rast.list input=LST_Day_monthly_celsius order=min \\\n columns=name,start_time,min where=\"min &lt;= '10.0'\"\n\nMapas cuyo valor máximo es mayor a 30\n\n# Maps with maximum value higher than 30\nt.rast.list input=LST_Day_monthly_celsius order=max \\\n columns=name,start_time,max where=\"max &gt; '30.0'\"\n\nMapas contenidos entre dos fechas\n\n# Maps between two given dates\nt.rast.list input=LST_Day_monthly_celsius columns=name,start_time \\\n where=\"start_time &gt;= '2015-05' and start_time &lt;= '2015-08-01 00:00:00'\"\n\nTodos los mapas correspondientes al mes de Enero\n\n# Maps from January\nt.rast.list input=LST_Day_monthly_celsius columns=name,start_time \\\n where=\"strftime('%m', start_time)='01'\"\n\n\n\n\nEstadística descriptiva de STRDS\nImprimir estadísticas descriptivas univariadas para cada mapa dentro de la STRDS\n\n# Print univariate stats for maps within STRDS\nt.rast.univar input=LST_Day_monthly_celsius\n\nObtener estadísticas extendidas con la opción -e\n\n# Get extended statistics\nt.rast.univar -e input=LST_Day_monthly_celsius\n\nEscribir la salida a un archivo de texto\n\n# Write the univariate stats output to a csv file\nt.rast.univar input=LST_Day_monthly_celsius separator=comma \\\n  output=stats_LST_Day_monthly_celsius.csv\n\n\n\nAgregación temporal 1: Serie completa\nt.rast.series\n\nAgrega STRDS completas o partes de ellas usando la opción where.\nDiferentes métodos disponibles: promedio, mínimo, máximo, mediana, moda, etc.\n\nLST máxima y mínima del período 2015-2019\nObtener el mapa de la máxima LST del período\n\n# Get maximum LST in the STRDS\nt.rast.series input=LST_Day_monthly_celsius \\\n  output=LST_Day_max method=maximum\n\nObtener el mapa de la mínima LST del período\n\n# Get minimum LST in the STRDS\nt.rast.series input=LST_Day_monthly_celsius \\\n  output=LST_Day_min method=minimum\n\nCambiar la paleta de colores a celsius\n\n# Change color pallete to celsius\nr.colors map=LST_Day_min,LST_Day_max color=celsius\n\n\nComparar mapas con la herramienta Mapswipe\n\n\n\n\nOperaciones usando variables temporales\nt.rast.mapcalc\n\nEjecuta expresiones espacio-temporales tipo r.mapcalc\nPermite operadores espaciales y temporales, así como variables internas en la expresión\nLas variables temporales incluyen: start_time(), end_time(), start_month(), start_doy(), etc.\n\nCuál es el mes de máxima LST?\nObtener el mes en que ocurre el máximo de LST en cada pixel\n\n# Get month of maximum LST\nt.rast.mapcalc -n inputs=LST_Day_monthly_celsius \\\n  output=month_max_lst \\\n  expression=\"if(LST_Day_monthly_celsius == LST_Day_max, start_month(), null())\" \\\n  basename=month_max_lst\n\nObtener información del mapa resultante\n\n# Get basic info\nt.info month_max_lst\n\nObtener el primer mes en que aparece el máximo de LST\n\n# Get the earliest month in which the maximum appeared (method minimum)\nt.rast.series input=month_max_lst \\\n  method=minimum \\\n  output=max_lst_date\n\nRemover la STRDS intermedia y los mapas que contiene: month_max_lst\n\n# Remove month_max_lst strds \n# we were only interested in the resulting aggregated map\nt.remove -rf inputs=month_max_lst\n\nMostrar el mapa resultante desde la terminal\nAbrir un monitor wx\n\n# Open a monitor\nd.mon wx0\n\nMostrar el mapa raster\n\n# Display the raster map\nd.rast map=max_lst_date\n\nMostrar sólo los bordes del mapa vectorial de NC\n\n# Display boundary vector map\nd.vect map=provincia_cba type=boundary color=#4D4D4D width=2\n\nAgregar leyenda\n\n# Add raster legend\nd.legend -t raster=max_lst_date title=\"Month\" \\\n  labelnum=6 title_fontsize=20 font=sans fontsize=16\n\nAgregar barra de escala\n\n# Add scale bar\nd.barscale length=100 units=kilometers segment=4 fontsize=14\n\nAgregar Norte\n\n# Add North arrow\nd.northarrow style=1b text_color=black\n\nAgregar título\n\n# Add text\nd.text text=\"Month of maximum LST\" \\\n  color=black align=cc font=sans size=12\n\n\n\nPodríamos haber hecho lo mismo pero anualmente para conocer en qué mes ocurre el máximo en cada año y así evaluar la ocurrencia de tendencias. Cómo lo harían?\n\n\n\nAgregación temporal 2: granularidad\nt.rast.aggregate\n\nAgrega mapas raster dentro de STRDS con diferentes granularidades\nLa opción where permite establecer fechas específicas para la agregación\nDiferentes métodos disponibles: promedio, mínimo, máximo, mediana, moda, etc.\n\nDe LST mensual a estacional\nLST media estacional\n\n# 3-month mean LST\nt.rast.aggregate input=LST_Day_monthly_celsius \\\n  output=LST_Day_mean_3month \\\n  basename=LST_Day_mean_3month suffix=gran \\\n  method=average granularity=\"3 months\"\n\nChequear info\n\n# Check info\nt.info input=LST_Day_mean_3month\n\nChequear lista de mapas\n\n# Check map list\nt.rast.list input=LST_Day_mean_3month\n\n\nTarea\nComparar las líneas de tiempo mensual y estacional con g.gui.timeline\n\ng.gui.timeline inputs=LST_Day_monthly_celsius,LST_Day_mean_3month\nGraficar LST estacional con monitores wx\nEstablecer la paleta de colores celsius para la STRDS estacional\n\n# Set STRDS color table to celsius degrees\nt.rast.colors input=LST_Day_mean_3month color=celsius\n\nIniciar un monitor Cairo\n\n# Start a new graphics monitor\nd.mon cairo out=frames.png width=1400 height=500 resolution=4 --o\n\nCrear el primer frame\n\n# create a first frame\nd.frame -c frame=first at=0,100,0,25\nd.rast map=LST_Day_mean_3month_2015_01\nd.vect map=provincia_cba type=boundary color=#4D4D4D width=2\nd.text text='Ene-Mar 2015' color=black font=sans size=6 bgcolor=white\n\nCrear el segundo frame\n\n# create a second frame\nd.frame -c frame=second at=0,100,25,50\nd.rast map=LST_Day_mean_3month_2015_04\nd.vect map=provincia_cba type=boundary color=#4D4D4D width=2\nd.text text='Abr-Jun 2015' color=black font=sans size=6 bgcolor=white\n\nCrear el tercer frame\n\n# create a third frame\nd.frame -c frame=third at=0,100,50,75\nd.rast map=LST_Day_mean_3month_2015_07\nd.vect map=provincia_cba type=boundary color=#4D4D4D width=2\nd.text text='Jul-Sep 2015' color=black font=sans size=6 bgcolor=white\n\nCrear el cuarto frame\n\n# create a fourth frame\nd.frame -c frame=fourth at=0,100,75,100\nd.rast map=LST_Day_mean_3month_2015_10\nd.vect map=provincia_cba type=boundary color=#4D4D4D width=2\nd.text text='Oct-Dic 2015' color=black font=sans size=6 bgcolor=white\n\nLiberar el monitor\n\n# release monitor\nd.mon -r\n\n\nLST estacional en 2015\n\nTarea\nAhora que ya conocen t.rast.aggregate, extraigan el mes de máximo LST por año y luego vean si hay alguna tendencia positiva o negativa, es decir, si los valores máximos de LST se observan más tarde o más temprano con el tiempo (años)\n\nUna solución podría ser…\nt.rast.aggregate \\\n  input=LST_Day_monthly_celsius \\\n  output=month_max_LST_per_year \\\n  basename=month_max_LST suffix=gran \\\n  method=max_raster \\\n  granularity=\"1 year\" \n\nt.rast.series \\\n  input=month_max_LST_per_year \\\n  output=slope_month_max_LST \\\n  method=slope\n\n\nAnimaciones\nAnimación de la serie estacional de LST\n\n# Animation of seasonal LST\ng.gui.animation strds=LST_Day_mean_3month\n\nVer el manual de g.gui.animation para más opciones y ajustes.\n\n\nAgregación vs Climatología\n\nAgregación por granularidad\n\nAgregación tipo climatología\n\n\nClimatologías mensuales\nLST promedio de Enero\n\n# January average LST\nt.rast.series input=LST_Day_monthly_celsius \\\n  method=average \\\n  where=\"strftime('%m', start_time)='01'\" \\\n  output=LST_average_jan\n\nClimatología para todos los meses\n\n# for all months - *nix\nfor MONTH in `seq -w 1 12` ; do \n t.rast.series input=LST_Day_monthly_celsius method=average \\\n  where=\"strftime('%m', start_time)='${MONTH}'\" \\\n  output=LST_average_${MONTH}\ndone\n\n\nTarea\n\nComparar las medias mensuales con las climatologías mensuales\nLas climatologías que creamos forman una STRDS?\n\n\n\n\nAnomalías anuales\n\\[AnomaliaStd_i = \\frac{Media_i - Media}{SD}\\]\nSe necesitan:\n\npromedio y desviación estándar general de la serie\npromedios anuales\n\nObtener el promedio general de la serie\n\n# Get general average\nt.rast.series input=LST_Day_monthly_celsius \\\n method=average output=LST_average\n\nObtener el desvío estándar general de la serie\n\n# Get general SD\nt.rast.series input=LST_Day_monthly_celsius \\\n method=stddev output=LST_sd\n\nObtener los promedios anuales\n\n# Get annual averages\nt.rast.aggregate input=LST_Day_monthly_celsius \\\n method=average granularity=\"1 years\" \\\n output=LST_yearly_average basename=LST_yearly_average\n\nEstimar las anomalías anuales\n\n# Estimate annual anomalies\nt.rast.algebra basename=LST_year_anomaly \\\n expression=\"LST_year_anomaly = (LST_yearly_average - map(LST_average)) / map(LST_sd)\"\n\nEstablecer la paleta de colores differences\n\n# Set difference color table\nt.rast.colors input=LST_year_anomaly color=difference\n\nAnimación\n\n# Animation of annual anomalies\ng.gui.animation strds=LST_year_anomaly\n\n\n\nIsla de calor superficial urbana (Surface Urban Heat Island - SUHI)\n\nLa temperatura del aire de una zona urbana es más alta que la de las zonas cercanas\nLa UHI tiene efectos negativos en la calidad del agua y el aire, la biodiversidad, la salud humana y el clima.\nLa SUHI también está muy relacionada con la salud, ya que influye en la UHI\n\n\nSUHI y área rural en Buenos Aires. Fuente: Wu et al, 2019.\n\n\nEstadística zonal en series de tiempo de datos raster\nv.strds.stats - Permite obtener datos de series de tiempo agregados espacialmente para polígonos de un mapa vectorial\nSUHI estival para Córdoba y alrededores\nInstalar la extensión v.strds.stats\n\n# Install v.strds.stats add-on\ng.extension extension=v.strds.stats\n\nListar mapas\n\n# List maps in seasonal time series\nt.rast.list input=LST_Day_mean_3month\n\nExtraer LST promedio de verano para el Gran Córdoba\n\n# Extract summer average LST for Cba urban area\nv.strds.stats input=area_edificada_cba \\\n  strds=LST_Day_mean_3month \\\n  where=\"fna == 'Gran Córdoba'\" \\\n  t_where=\"strftime('%m', start_time)='01'\" \\\n  output=cba_summer_lst \\\n  method=average\n\nCrear buffer externo - 30 km\n\n# Create outside buffer - 30 km\nv.buffer input=cba_summer_lst \\\n  distance=30000 \\\n  output=cba_summer_lst_buf30\n\nCrear buffer interno - 15 km\n\n# Create inside buffer - 15 km\nv.buffer input=cba_summer_lst \\\n  distance=15000 \\\n  output=cba_summer_lst_buf15\n\nRemover el área del buffer 15 km del buffer de 30 km\n\n# Remove 15km buffer area from the 30km buffer area\nv.overlay ainput=cba_summer_lst_buf15 \\\n  binput=cba_summer_lst_buf30 \\\n  operator=xor \\\n  output=cba_surr\n\n\nLímites del Gran Córdoba y el área rural circundante\nExtraer estadísticas para los alrededores del Gran Córdoba\n\n# Extract zonal stats for Cba surroundings\nv.strds.stats input=cba_surr \\\n  strds=LST_Day_mean_3month \\\n  t_where=\"strftime('%m', start_time)='01'\" \\\n  method=average \\\n  output=cba_surr_summer_lst\n\nChequear la LST estival promedio para el Gran Córdoba y alrededores\n\n# Take a look at mean summer LST in Cba and surroundings\nv.db.select cba_summer_lst\nv.db.select cba_surr_summer_lst"
  },
  {
    "objectID": "unidad_4/intro_temporal.html#recursos-muy-útiles",
    "href": "unidad_4/intro_temporal.html#recursos-muy-útiles",
    "title": "Intro a series de tiempo",
    "section": "Recursos (muy) útiles",
    "text": "Recursos (muy) útiles\n\nTemporal data processing wiki\nGRASS GIS and R for time series processing wiki\nGRASS GIS temporal workshop at NCSU\nGRASS GIS course IRSAE 2018\nGRASS GIS workshop held in Jena 2023"
  },
  {
    "objectID": "unidad_4/intro_temporal.html#referencias",
    "href": "unidad_4/intro_temporal.html#referencias",
    "title": "Intro a series de tiempo",
    "section": "Referencias",
    "text": "Referencias\n\n\nGebbert, S., Leppelt, T., y Pebesma, E. (2019), «A Topology Based Spatio-Temporal Map Algebra for Big Data Analysis», Data, 4, 86. https://doi.org/10.3390/data4020086.\n\n\nGebbert, S., y Pebesma, E. (2014), «A temporal GIS for field based environmental modeling», Environmental Modelling & Software, 53, 1-12. https://doi.org/10.1016/j.envsoft.2013.11.001.\n\n\nGebbert, S., y Pebesma, E. (2017), «The GRASS GIS temporal framework», International Journal of Geographical Information Science, 31, 1273-1292. https://doi.org/10.1080/13658816.2017.1306862."
  },
  {
    "objectID": "unidad_2/python_and_grass.html#otras-librerías-python-en-grass-gis",
    "href": "unidad_2/python_and_grass.html#otras-librerías-python-en-grass-gis",
    "title": "Python y GRASS GIS",
    "section": "Otras librerías Python en GRASS GIS",
    "text": "Otras librerías Python en GRASS GIS\n\nTemporal framework\nEl GRASS GIS Temporal Framework implementa la funcionalidad SIG temporal de GRASS GIS y proporciona una API para implementar módulos de procesamiento espacio-temporal. El framework introduce conjuntos de datos espacio-temporales que representan series temporales de mapas raster, raster 3D o vectoriales. Este marco proporciona las siguientes funcionalidades:\n\nAsignación de marcas de tiempo a mapas y registro de mapas en la base de datos temporal\nModificación de marcas de tiempo\nCreación, cambio de nombre y supresión de conjuntos de datos espacio-temporales\nRegistro y anulación del registro de mapas en conjuntos de datos espacio-temporales\nConsulta de mapas registrados en conjuntos de datos espacio-temporales mediante SQL\nAnálisis de la topología espacio-temporal de los conjuntos de datos espacio-temporales\nMuestreo de conjuntos de datos espacio-temporales\nCálculo de las relaciones temporales y espaciales entre los mapas registrados\nFunciones de nivel superior compartidas entre módulos\n\n\n\n\n\n\n\nNota\n\n\n\nPara más detalles, ver la documentación de la librería en: https://grass.osgeo.org/grass-stable/manuals/libpython/temporal_framework.html\n\n\n\n\nTesting framework\nEl GRASS GIS Testing framework está basado en el paquete unittest de Python con un gran número de mejoras, extensiones y cambios específicos ajustados a GRASS. Estos cambios incluyen la creación de reportes de pruebas HTML compatibles con GRASS, o la ejecución de pruebas de manera que las terminaciones de procesos potencialmente causadas por funciones de la librería C no influyan en el proceso principal de pruebas.\nAlgunas pruebas se ejecutarán sin ningún dato, pero muchas pruebas requieren la versión básica de los datos de muestra para Carolina del Norte.\n\n\n\n\n\n\nNota\n\n\n\nPara más detalles, ver la documentación de la librería en: https://grass.osgeo.org/grass-stable/manuals/libpython/gunittest_testing.html"
  },
  {
    "objectID": "unidad_3/intro_obia.html#references",
    "href": "unidad_3/intro_obia.html#references",
    "title": "Intro a OBIA",
    "section": "Referencias",
    "text": "Referencias\n\n\nBlaschke, T. (2010), «Object based image analysis for remote sensing», ISPRS Journal of Photogrammetry and Remote Sensing, 65, 2-16. https://doi.org/10.1016/j.isprsjprs.2009.06.004.\n\n\nGeorganos, S., Grippa, T., Lennert, M., Vanhuysse, S., y Johnson, B. A. (2018), «Scale Matters: Spatially Partitioned Unsupervised Segmentation Parameter Optimization for Large and Heterogeneous Satellite Images», 23.\n\n\nGrippa, T., Lennert, M., Beaumont, B., Vanhuysse, S., Stephenne, N., Wolff, E., Grippa, T., Lennert, M., Beaumont, B., Vanhuysse, S., Stephenne, N., y Wolff, E. (2017), «An Open-Source Semi-Automated Processing Chain for Urban Object-Based Classification», Remote Sensing, 9, 358. https://doi.org/10.3390/rs9040358."
  },
  {
    "objectID": "unidad_4/exercise_temporal.html",
    "href": "unidad_4/exercise_temporal.html",
    "title": "Ejercicio: Series temporales en GRASS GIS",
    "section": "",
    "text": "En esta notebook vamos a recorrer algunas de las funcionalidades de TGRASS que ya vimos y otras nuevas, pero ahora con una serie de datos de NDVI.\nAntes de empezar y para ganar tiempo, conectamos nuestro drive e instalamos GRASS en Google Colab.\n# import drive from google colab\nfrom google.colab import drive\n# mount drive\ndrive.mount(\"/content/drive\")\n%%bash\nDEBIAN_FRONTEND=noninteractive \nsudo add-apt-repository ppa:ubuntugis/ubuntugis-unstable \napt update \napt install grass subversion grass-dev\napt remove libproj22\n!grass --config path"
  },
  {
    "objectID": "unidad_4/exercise_temporal.html#ejercicio-manos-a-la-obra-con-series-temporales-de-ndvi",
    "href": "unidad_4/exercise_temporal.html#ejercicio-manos-a-la-obra-con-series-temporales-de-ndvi",
    "title": "Ejercicio: Series temporales en GRASS GIS",
    "section": "",
    "text": "Datos para el ejercicio\nUso de bandas de confiabilidad\nCreación de serie de NDVI\nHANTS como método de reconstrucción\nAgregación temporal\nÍndices de fenología\nNDWI y frecuencia de inundación\nRegresión entre NDVI y NDWI\n\n\n\n\n\nProducto MODIS: MOD13C2 Collection 6\nComposiciones globales mensuales\nResolución espacial: 5600 m\nMapset modis_ndvi\n\n\n\n\n\nIniciar GRASS GIS en el mapset modis_ndvi\n\n# paths\ngrassdata='/home/veroandreo/grassdata/'\nlocation='posgar2007_4_cba'\nmapset='modis_ndvi'\n\n\nimport os\nimport subprocess\nimport sys\n\n# Ask GRASS GIS where its Python packages are to be able to start it from the notebook\nsys.path.append(\n    subprocess.check_output([\"grass\", \"--config\", \"python_path\"], text=True).strip()\n)\n\n# Importar los paquetes python de GRASS\nimport grass.script as gs\nimport grass.jupyter as gj\n\n# Iniciar GRASS\nsession = gj.init(grassdata, location, mapset)\n\nAgregar modis_lst a la lista de mapsets accesibles\n\n# add `modis_lst` to accessible mapsets path\ng.mapsets -p\ng.mapsets mapset=modis_lst operation=add\n\nListar los mapas y obtener información de alguno de ellos\n\n# list files and get info and stats\ng.list type=raster mapset=.\n\nr.info map=MOD13C2.A2015001.006.single_Monthly_NDVI\nr.univar map=MOD13C2.A2015001.006.single_Monthly_NDVI\n\n\nTarea\n\nMostrar los mapas de NDVI, NIR y pixel reliability.\nObtener información sobre los valores mínimos y máximos\n¿Qué se puede decir sobre los valores de cada banda?\n¿Hay valores nulos?\n\n\n\n\n\n\nTarea\n\nLeer acerca de la banda de confiabilidad en la Guía de usuario de MOD13 (pag 27).\nPara una misma fecha mostrar la banda de confiabilidad y el NDVI.\nSeleccionar sólo los pixeles con valor 0 (Buena calidad) en la banda de confiabilidad. ¿Qué se observa?\n\n\n\n\n\nDefinir la región computacional\n\n# set computational region\ng.region -p vector=provincia_cba \\\n  align=MOD13C2.A2015001.006.single_Monthly_NDVI\n\nEstablecer los límites provinciales como máscara\n\n# set mask\nr.mask vector=provincia_cba\n\nMantener sólo los pixeles de la mejor calidad\n\n# keep only NDVI most reliable pixels (one map) - *nix\nPR=MOD13C2.A2015274.006.single_Monthly_pixel_reliability\nNDVI=MOD13C2.A2015274.006.single_Monthly_NDVI\n\nr.mapcalc \\\n  expression=\"${NDVI}_filt = if(${PR} != 0, null(), ${NDVI})\"\n\nMantener sólo los pixeles de la mejor calidad - para todos los mapas\n\n# list of maps\nPR=`g.list type=raster pattern=\"*_pixel_reliability\" separator=\" \"`\nNDVI=`g.list type=raster pattern=\"*_Monthly_NDVI\" separator=\" \"`\n# convert list to array\nPR=($PR)\nNDVI=($NDVI)\n\n# iterate over the 2 arrays\nfor ((i=0;i&lt;${#PR[@]};i++)) ; do\n r.mapcalc --o \\\n  expression=\"${NDVI[$i]}_filt = if(${PR[$i]} != 0, null(), ${NDVI[$i]})\"\ndone\n\n\nTarea\nCómo podrían hacer lo mismo pero con módulos temporales?\n\nQué les parece t.rast.algebra?\n\n# apply pixel reliability band\nt.rast.algebra \\\n  expression=\"NDVI_monthly_filt = if(pixel_rel_monthly != 0, null(), ndvi_monthly)\"\n  basename=ndvi_monthly \\\n  suffix=gran\n\n\nTarea\nComparar las estadísticas entre los mapas de NDVI originales y filtrados para la misma fecha\n\n\n\n\nCrear STRDS de NDVI\n\n# create STRDS\nt.create output=ndvi_monthly \\\n  type=strds temporaltype=absolute \\\n  title=\"Filtered monthly NDVI\" \\\n  description=\"Filtered monthly NDVI - MOD13C2 - Cordoba, 2015-2019\"\n\nCorroborar que la STRDS fue creada\n\n# check if it was created\nt.list type=strds\n\nCrear archivo con lista de mapas\n\n# list NDVI filtered files\ng.list type=raster pattern=\"*filt\" output=ndvi_list.txt\n\nAsignar fecha a los mapas, i.e., registrar\n\n# register maps\nt.register -i input=ndvi_monthly \\\n  type=raster file=ndvi_list.txt \\\n  start=\"2015-01-01\" \\\n  increment=\"1 months\"\n\nImprimir info básica de la STRDS\n\n# print time series info\nt.info input=ndvi_monthly\n\nImprimir la lista de mapas en la STRDS\n\n# print list of maps in time series\nt.rast.list input=ndvi_monthly\n\n\nTarea\nExplorar visualmente los valores de las series temporales en diferentes puntos. Usar g.gui.tplot y seleccionar diferentes puntos interactivamente.\n\n\n\n\nObtener las estadísticas de la serie de tiempo\n\n# How much missing data we have after filtering for pixel reliability?\nt.rast.univar input=ndvi_monthly\n\nContar los datos válidos\n\n# count valid data\nt.rast.series input=ndvi_monthly \\\n  method=count \\\n  output=ndvi_count_valid\n\nEstimar el porcentaje de datos faltantes\n\n# estimate percentage of missing data\nr.mapcalc \\\n expression=\"ndvi_missing = ((60 - ndvi_count_valid) * 100.0)/60\"\n\nCómo guardar en una variable el numero de mapas de una serie de tiempo?\n\nt.info -g ndvi_monthly\n`eval t.info ndvi_monthly`\necho $number_of_maps\n\nr.mapcalc \\\n  expression=\"ndvi_missing = (($number_of_maps - ndvi_count_valid) * 100.0)/$number_of_maps\"\n\n\nTarea\n\nMostrar el mapa que representa el porcentaje de datos faltantes y explorar los valores.\nObtener estadísticas univariadas de este mapa.\nDónde estan los mayores porcentajes de datos faltantes? Por qué creen que puede ser?\n\n\n\n\n\n\nHarmonic Analysis of Time Series (HANTS)\nImplementado en la extensión r.hants\n\n\n\n\n\nInstalar la extensión r.hants\n\n# install extension\ng.extension extension=r.hants\n\nListar los mapas y aplicar r.hants\n\n# list maps\nmaplist=`t.rast.list input=ndvi_monthly method=comma`\n\n# gapfill: r.hants\nr.hants input=$maplist range=-2000,10000 \\\n  nf=5 fet=500 base_period=12\n\n\nTarea\nProbar diferentes ajustes de parámetros en r.hants y comparar los resultados\n\n\n\n\nParcheo de serie original y reconstruída\n\n# patch original with filled (one map)\nNDVI_ORIG=MOD13C2.A2015001.006.single_Monthly_NDVI_filt\nNDVI_HANTS=MOD13C2.A2015001.006.single_Monthly_NDVI_filt_hants\n\nr.patch input=${NDVI_ORIG},${NDVI_HANTS} \\\n  output=${NDVI_HANTS}_patch\n\nParcheo de serie original y reconstruída\n\n# list of maps\nORIG=`g.list type=raster pattern=\"*_filt\" separator=\" \"`\nFILL=`g.list type=raster pattern=\"*_hants\" separator=\" \"`\n# convert list to array\nORIG=($ORIG)\nFILL=($FILL)\n\n# iterate over the 2 arrays\nfor ((i=0;i&lt;${#ORIG[@]};i++)) ; do\n  r.patch input=${ORIG[$i]},${FILL[$i]} output=${FILL[$i]}_patch --o\ndone\n\nCrear serie de tiempo con los datos parcheados\n\n# create new time series \nt.create output=ndvi_monthly_patch \\\n  type=strds temporaltype=absolute \\\n  title=\"Patched monthly NDVI\" \\\n  description=\"Filtered, gap-filled and patched monthly NDVI - MOD13C2 - Cordoba, 2015-2019\"\n\nRegistrar los mapas en la serie de tiempo\n\n# list NDVI patched files\ng.list type=raster pattern=\"*patch\" \\\n  output=list_ndvi_patched.txt\n\n# register maps\nt.register -i input=ndvi_monthly_patch \\\n  type=raster file=list_ndvi_patched.txt \\\n  start=\"2015-01-01\" \\\n  increment=\"1 months\"\n\nImprimir información de la serie de tiempo\n\n# print time series info\nt.info input=ndvi_monthly_patch\n\n\nTarea\n\nEvaluar gráficamente los resultados de la reconstrucción de HANTS en pixeles con mayor porcentaje de datos faltantes\nObtener estadísticas univariadas para las nuevas series temporales\n\n\n\nTarea\n\nVer la sección de métodos en Metz el al. 2017\nQué otros algoritmos existen o qué otra aproximación podría seguirse?\n\n\n\n\n\n\n\nTarea\n\nObtener el promedio de NDVI cada dos meses\nVisualizar la serie de tiempo resultante con g.gui.animation\n\n\n\n\n\nMes de máximo y mes de mínimo\n\n# get month of maximum and month of minimum\nt.rast.series input=ndvi_monthly_patch \\\n  method=minimum output=ndvi_min\nt.rast.series input=ndvi_monthly_patch \\\n  method=maximum output=ndvi_max\n\nReemplazar con start_month() los valores en la STRDS si coinciden con el mínimo o máximo global\n\n# get month of maximum and minimum\nt.rast.mapcalc -n inputs=ndvi_monthly_patch \\\n  output=month_max_ndvi \\\n  expression=\"if(ndvi_monthly_patch == ndvi_max, start_month(), null())\" \\\n  basename=month_max_ndvi\n\nt.rast.mapcalc -n inputs=ndvi_monthly_patch \\\n  output=month_min_ndvi \\\n  expression=\"if(ndvi_monthly_patch == ndvi_min, start_month(), null())\" \\\n  basename=month_min_ndvi\n\nObtener el primer mes en el que aparecieron el máximo y el mínimo\n\n# get the earliest month in which the maximum and minimum appeared\nt.rast.series input=month_max_ndvi \\\n  method=maximum output=max_ndvi_date\nt.rast.series input=month_min_ndvi \\\n  method=minimum output=min_ndvi_date\n\nEliminar la serie temporal intermedia\n\n# remove month_max_lst strds \nt.remove -rf inputs=month_max_ndvi,month_min_ndvi\n\n\nTarea\n\nMostrar los mapas resultantes con g.gui.mapswipe\nCuándo se observan los mínimos y máximos? Hay algun patrón? A qué se podría deber?\n\n\n\nTarea\nAsociar el máximo de LST con el máximo de NDVI y, la fecha de la máxima LST con la fecha del máximo NDVI\n\n Ver el módulo r.covar\n\n\n\nObtener series temporales de pendientes entre mapas consecutivos\n\n# time series of slopes\nt.rast.algebra \\\n expression=\"slope_ndvi = (ndvi_monthly_patch[1] - ndvi_monthly_patch[0]) / td(ndvi_monthly_patch)\" \\\n basename=slope_ndvi suffix=gran\n\nObtener la máxima pendiente por año\n\n# get max slope per year\nt.rast.aggregate input=slope_ndvi output=ndvi_slope_yearly \\\n  basename=NDVI_max_slope_year suffix=gran \\\n  method=maximum \\\n  granularity=\"1 years\"\n\n\nTarea\n\nObtener un mapa con la mayor tasa de crecimiento por píxel en el período 2015-2019\nQué modulo usarían?\n\n\n\n\n\nInstalar la extensión r.seasons\n\n# install extension\ng.extension extension=r.seasons\n\nDeterminar el comienzo, el final y la duración del período de crecimiento\n\n# start, end and length of growing season\nr.seasons input=`t.rast.list -u input=ndvi_monthly_patch method=comma` \\\n  prefix=ndvi_season n=3 \\\n  nout=ndvi_season \\\n  threshold_value=3000 min_length=5\n\n\nTarea\n\nQué nos dice cada mapa? Dónde es más larga la estación de crecimiento?\nExportar los mapas resultantes como .png\n\n\n\n\n\nCrear un mapa de umbrales para usar en r.seasons\n\n# create a threshold map: min ndvi + 0.1*ndvi\nr.mapcalc expression=\"threshold_ndvi = ndvi_min * 1.1\"\n\n\nTarea\nUtilizar el mapa de umbrales en r.seasons y comparar los mapas de salida con los resultados de utilizar sólo un valor de umbral\n\n\n\n\nCrear series temporales de NIR y MIR\n\n# create time series of NIR and MIR\nt.create output=NIR \\\n  type=strds temporaltype=absolute \\\n  title=\"NIR monthly\" \\\n  description=\"NIR monthly - MOD13C2 - 2015-2019\"\n\nt.create output=MIR \\\n  type=strds temporaltype=absolute \\\n  title=\"MIR monthly\" \\\n  description=\"MIR monthly - MOD13C2 - 2015-2019\"\n\nListar archivos NIR y MIR\n\n# list NIR and MIR files\ng.list type=raster pattern=\"*NIR*\" output=list_nir.txt\ng.list type=raster pattern=\"*MIR*\" output=list_mir.txt\n\nRegistrar mapas\n\n# register maps\nt.register -i input=NIR \\\n  type=raster file=list_nir.txt \\\n  start=\"2015-01-01\" increment=\"1 months\"\n\nt.register -i input=MIR \\\n  type=raster file=list_mir.txt \\\n  start=\"2015-01-01\" increment=\"1 months\"\n\nImprimir información de la serie de tiempo\n\n# print time series info\nt.info input=NIR\nt.info input=MIR\n\nEstimación de la serie temporal de NDWI\n\n# estimate NDWI time series\nt.rast.algebra basename=ndwi_monthly \\\n  expression=\"ndwi_monthly = if(NIR &gt; 0 && MIR &gt; 0, (float(NIR - MIR) / float(NIR + MIR)), null())\" \\\n  suffix=gran\n\n\nTarea\nObtener valores máximos y mínimos para cada mapa de NDWI y explorar el trazado de la serie de tiempo en diferentes puntos de forma interactiva\n\n Ver el manual de t.rast.univar\n\n\n\nReclasificar los mapas según un umbral\n\n# reclassify\nt.rast.mapcalc -n input=ndwi_monthly \\\n  output=flood basename=flood \\\n  expression=\"if(ndwi_monthly &gt; 0.8, 1, null())\"\n\nObtener frecuencia de inundación\n\n# flooding frequency\nt.rast.series input=flood output=flood_freq method=sum\n\n\nTarea\nCuáles son las áreas que se han inundado con más frecuencia?\n\n\n\n\nInstalar la extensión r.regression.series\n\n# install extension\ng.extension extension=r.regression.series\n\nRealizar una regresión entre las series temporales de NDVI y NDWI - *nix\n\nxseries=`t.rast.list input=ndvi_monthly_patch method=comma`\nyseries=`t.rast.list input=ndwi_monthly method=comma`\n\nr.regression.series xseries=$xseries \\\n  yseries=$yseries \\\n  output=ndvi_ndwi_rsq \\\n  method=rsq\n\n\nTarea\nDeterminar dónde está la mayor correlación entre NDVI y NDWI\n\n\nGracias por su atención!!\n\n\n\nGRASS GIS logo"
  },
  {
    "objectID": "unidad_4/exercise_temporal.html#datos-para-el-ejercicio",
    "href": "unidad_4/exercise_temporal.html#datos-para-el-ejercicio",
    "title": "Ejercicio: Series temporales en GRASS GIS",
    "section": "Datos para el ejercicio",
    "text": "Datos para el ejercicio\n\nProducto MODIS: MOD13C2 Collection 6\nComposiciones globales mensuales\nResolución espacial: 5600 m\nMapset modis_ndvi"
  },
  {
    "objectID": "unidad_4/exercise_temporal.html#iniciamos-grass",
    "href": "unidad_4/exercise_temporal.html#iniciamos-grass",
    "title": "Ejercicio: Series temporales en GRASS GIS",
    "section": "Iniciamos GRASS",
    "text": "Iniciamos GRASS\nDefinimos las rutas y el mapset modis_ndvi\n\nimport os\n\n# data directory\nhomedir = \"/content/drive/MyDrive/curso_grass_2023\"\n\n# GRASS GIS database variables\ngrassdata = os.path.join(homedir, \"grassdata\")\nproject = \"posgar2007_4_cba\"\nmapset = \"modis_ndvi\"\n\n\n# import standard Python packages we need\nimport sys\nimport subprocess\n\n# ask GRASS GIS where its Python packages are to be able to run it from the notebook\nsys.path.append(\n    subprocess.check_output([\"grass\", \"--config\", \"python_path\"], text=True).strip()\n)\n\nImportamos los paquetes de GRASS e iniciamos una sesión:\n\n# import the GRASS GIS packages we need\nimport grass.script as gs\nimport grass.jupyter as gj\n\n# Start the GRASS GIS Session\nsession = gj.init(grassdata, project, mapset)\n\n\n# show current GRASS GIS settings, this also checks if the session works\ngs.gisenv()"
  },
  {
    "objectID": "unidad_4/exercise_temporal.html#exploramos-los-datos-de-ndvi",
    "href": "unidad_4/exercise_temporal.html#exploramos-los-datos-de-ndvi",
    "title": "Ejercicio: Series temporales en GRASS GIS",
    "section": "Exploramos los datos de NDVI",
    "text": "Exploramos los datos de NDVI\nListar los mapas y obtener información de alguno de ellos\n\n# list raster files\nlista_mapas = gs.list_grouped(type=\"raster\")[\"modis_ndvi\"]\nlista_mapas[:10]\n\n\n#  get info and stats\ngs.raster_info(map=\"MOD13C2.A2015001.006.single_Monthly_NDVI\")\n\n\nprint(gs.read_command(\"r.univar\",\n                      map=\"MOD13C2.A2015001.006.single_Monthly_NDVI\"))\n\n\n\n\n\n\n\nTarea\n\n\n\n\nMostrar los mapas de NDVI, NIR y pixel reliability.\nObtener información sobre los valores mínimos y máximos\n¿Qué se puede decir sobre los valores de cada banda?\n¿Hay valores nulos?"
  },
  {
    "objectID": "unidad_4/exercise_temporal.html#referencias",
    "href": "unidad_4/exercise_temporal.html#referencias",
    "title": "Ejercicio: Series temporales en GRASS GIS",
    "section": "Referencias",
    "text": "Referencias\n\n\nMetz, M., Andreo, V., y Neteler, M. (2017), «A New Fully Gap-Free Time Series of Land Surface Temperature from MODIS LST Data», Remote Sensing, 9, 1333. https://doi.org/10.3390/rs9121333."
  },
  {
    "objectID": "unidad_4/exercise_temporal.html#uso-de-la-banda-de-confiabilidad",
    "href": "unidad_4/exercise_temporal.html#uso-de-la-banda-de-confiabilidad",
    "title": "Ejercicio: Series temporales en GRASS GIS",
    "section": "Uso de la banda de confiabilidad",
    "text": "Uso de la banda de confiabilidad\nDefinir la región computacional\n\n# set computational region\ngs.region_env(vector=\"provincia_cba\",\n              align=\"MOD13C2.A2015001.006.single_Monthly_NDVI\",\n              flags=\"p\")\n\nEstablecer los límites provinciales como máscara\n\n# set a MASK to Cba boundary\ngs.run_command(\"r.mask\",\n               vector=\"provincia_cba\")\n\n\n\n\n\n\n\nTarea\n\n\n\n\nLeer acerca de la banda de confiabilidad en la Guía de usuario de MOD13 (pag 27).\nPara una misma fecha mapear la banda de confiabilidad y el NDVI.\nSeleccionar sólo los pixeles con valor 0 (Buena calidad) en la banda de confiabilidad. ¿Qué se observa?\n\n\n\nMantener sólo los pixeles de la mejor calidad\n\n# keep only NDVI most reliable pixels (one map)\nPR=\"MOD13C2.A2015274.006.single_Monthly_pixel_reliability\"\nNDVI=\"MOD13C2.A2015274.006.single_Monthly_NDVI\"\n\ngs.mapcalc(exp=f\"{NDVI}_filt = if({PR} != 0, null(), {NDVI})\")\n\n\n# plot result\nndvi_filt = gj.InteractiveMap(width = 500, tiles=\"OpenStreetMap\")\nndvi_filt.add_raster(\"MOD13C2.A2015274.006.single_Monthly_NDVI_filt\")\nndvi_filt.show()\n\nMantener sólo los pixeles de la mejor calidad para todos los mapas\n\n# list of maps\nPR = gs.list_grouped(type=\"raster\", \n                     pattern=\"*_pixel_reliability\")[\"modis_ndvi\"]\nNDVI = gs.list_grouped(type=\"raster\", \n                       pattern=\"*_Monthly_NDVI\")[\"modis_ndvi\"]\n\n# iterate over the 2 arrays\nfor i,j in zip(PR,NDVI):\n    print(i, j)\n    gs.mapcalc(exp=f\"{j}_filt = if({i} != 0, null(), {j})\")\n\n\n\n\n\n\n\nNota\n\n\n\nCómo podrían hacer lo mismo pero usando módulos temporales? Qué les parece t.rast.algebra? OJO! Esto requiere primero crear las series de tiempo y registrar los mapas para que funcione!\n\n# apply pixel reliability band with t.rast.algebra\nexpression=\"NDVI_monthly_filt = if(pixel_rel_monthly != 0, null(), ndvi_monthly)\"\n\ngs.run_command(\"t.rast.algebra\",\n               expression=expression,\n               basename=\"ndvi_monthly\",\n               suffix=\"gran\",\n               nproc=4)\n\n\n\n\n\n\n\n\n\nTarea\n\n\n\nComparar las estadísticas entre los mapas de NDVI originales y filtrados para la misma fecha"
  },
  {
    "objectID": "unidad_4/exercise_temporal.html#creación-de-la-serie-de-tiempo",
    "href": "unidad_4/exercise_temporal.html#creación-de-la-serie-de-tiempo",
    "title": "Ejercicio: Series temporales en GRASS GIS",
    "section": "Creación de la serie de tiempo",
    "text": "Creación de la serie de tiempo\nCrear STRDS de NDVI\n\n# create STRDS\ngs.run_command(\"t.create\",\n               type=\"strds\",\n               temporaltype=\"absolute\",\n               output=\"ndvi_monthly\",\n               title=\"Filtered monthly NDVI\",\n               description=\"Filtered monthly NDVI - MOD13C2 - Cordoba, 2015-2019\")\n\nCorroborar que la STRDS fue creada\n\n# check if it was created\ngs.read_command(\"t.list\",\n                type=\"strds\")\n\nCrear archivo con lista de mapas\n\n# list NDVI filtered files\nNDVI_filt = gs.list_grouped(type=\"raster\", \n                            pattern=\"*_filt\")[\"modis_ndvi\"]\nNDVI_filt[:10]\n\nAsignar fecha a los mapas, i.e., registrar\n\n# register maps\ngs.run_command(\"t.register\",\n               input=\"ndvi_monthly\",\n               maps=NDVI_filt,\n               start=\"2015-01-01\",\n               increment=\"1 months\",\n               flags=\"i\")\n\nImprimir info básica de la STRDS\n\n# print time series info\nprint(gs.read_command(\"t.info\", \n                      input=\"ndvi_monthly\"))\n\nImprimir la lista de mapas en la STRDS\n\n# print list of maps in time series\nprint(gs.read_command(\"t.rast.list\", \n                      input=\"ndvi_monthly\"))\n\nTambién podemos obtener los valores para un único pixel\n\n# Get region center coordinates for query \ngs.region(complete=True)\n\n\n# Query map at center coordinates\nprint(gs.read_command(\"t.rast.what\", \n                      strds=\"s2_ndvi\", \n                      coordinates=\"637500,221750\", \n                      layout=\"col\", \n                      flags=\"n\"))\n\n\n\n\n\n\n\nTarea\n\n\n\nExplorar visualmente los valores de las series temporales en diferentes puntos. Usar g.gui.tplot y seleccionar diferentes puntos interactivamente."
  },
  {
    "objectID": "unidad_4/exercise_temporal.html#datos-faltantes",
    "href": "unidad_4/exercise_temporal.html#datos-faltantes",
    "title": "Ejercicio: Series temporales en GRASS GIS",
    "section": "Datos faltantes",
    "text": "Datos faltantes\nObtener las estadísticas de la serie de tiempo\n\n# How much missing data we have after filtering for pixel reliability?\nprint(gs.read_command(\"t.rast.univar\",\n                      input=\"ndvi_monthly\"))\n\nContar los datos válidos\n\n# count valid data\ngs.run_command(\"t.rast.series\",\n               input=\"ndvi_monthly\",\n               method=\"count\",\n               output=\"ndvi_count_valid\")\n\nEstimar el porcentaje de datos faltantes\n\n# estimate percentage of missing data\ngs.mapcalc(exp=\"ndvi_missing = ((60 - ndvi_count_valid) * 100.0)/60\")\n\nCómo guardar en una variable el numero de mapas de una serie de tiempo?\n\nn = gs.parse_command(\"t.info\", \n                     input=\"ndvi_monthly\", \n                     flags=\"g\")[\"number_of_maps\"]\nn\n\n\ngs.mapcalc(exp=f\"ndvi_missing = (({n} - ndvi_count_valid) * 100.0)/{n}\")\n\n\n\n\n\n\n\nTarea\n\n\n\n\nMostrar el mapa que representa el porcentaje de datos faltantes y explorar los valores.\nObtener estadísticas univariadas de este mapa.\nDónde estan los mayores porcentajes de datos faltantes? Por qué creen que puede ser?"
  },
  {
    "objectID": "unidad_4/exercise_temporal.html#reconstrucción-temporal-hants",
    "href": "unidad_4/exercise_temporal.html#reconstrucción-temporal-hants",
    "title": "Ejercicio: Series temporales en GRASS GIS",
    "section": "Reconstrucción temporal: HANTS",
    "text": "Reconstrucción temporal: HANTS\n\nHarmonic Analysis of Time Series (HANTS)\nImplementado en la extensión r.hants\n\n\nInstalar la extensión r.hants\n\n# install extension\ngs.run_command(\"g.extension\",\n               extension=\"r.hants\")\n\nListar los mapas y aplicar r.hants\n\n# list maps\nmaplist = gs.parse_command(\"t.rast.list\",\n                          input=\"ndvi_monthly\",\n                          columns=\"name\",\n                          method=\"comma\",\n                          flags=\"u\")\nmaplist = list(maplist.keys())\n\n\n# gapfill: r.hants\ngs.run_command(\"r.hants\",\n               input=maplist,\n               range=[-2000,10000],\n               nf=5,\n               fet=500,\n               base_period=12)\n\n\n# list filled maps\ngs.list_grouped(type=\"raster\",\n                pattern=\"*hants\")[\"modis_ndvi\"]\n\n\n\n\n\n\n\nTarea\n\n\n\nProbar diferentes ajustes de parámetros en r.hants y comparar los resultados\n\n\nParcheo de serie original y reconstruída\n\n# patch original with filled (one map)\nNDVI_ORIG = \"MOD13C2.A2015001.006.single_Monthly_NDVI_filt\"\nNDVI_HANTS = \"MOD13C2.A2015001.006.single_Monthly_NDVI_filt_hants\"\n\ngs.run_command(\"r.patch\",\n               input=[NDVI_ORIG, NDVI_HANTS],\n               output=f\"{NDVI_HANTS}_patch\")\n\nParcheo de serie original y reconstruída\n\n# list of maps\nORIG = gs.list_grouped(type=\"raster\",\n                     pattern=\"*_filt\")[\"modis_ndvi\"]\nFILL = gs.list_grouped(type=\"raster\",\n                       pattern=\"*_hants\")[\"modis_ndvi\"]\n\n\n# patching\nfor i,j in zip(ORIG,FILL):\n    print(i, j)\n    out=f\"{j}_patch\"\n    gs.run_command(\"r.patch\",\n                   input=[i, j],\n                   output=out)\n\nCrear serie de tiempo con los datos parcheados\n\n# create new time series \ngs.run_command(\"t.create\",\n               output=\"ndvi_monthly_patch\",\n               type=\"strds\",\n               temporaltype=\"absolute\",\n               title=\"Patched monthly NDVI\",\n               description=\"Filtered, gap-filled and patched monthly NDVI - MOD13C2 - Cordoba, 2015-2019\")\n\nRegistrar los mapas en la serie de tiempo\n\n# list NDVI patched files\npatched_maps = gs.list_grouped(type=\"raster\",\n                               pattern=\"*patch\")[\"modis_ndvi\"]\npatched_maps[:5]\n\n\n# register maps\ngs.run_command(\"t.register\",\n               flags=\"i\",\n               input=\"ndvi_monthly_patch\",\n               type=\"raster\",\n               maps=patched_maps,\n               start=\"2015-01-01\",\n               increment=\"1 months\")\n\nImprimir información de la serie de tiempo\n\n# print time series info\nprint(gs.read_command(\"t.info\", \n                      input=\"ndvi_monthly_patch\"))\n\n\n\n\n\n\n\nTarea\n\n\n\n\nEvaluar gráficamente los resultados de la reconstrucción de HANTS en pixeles con mayor porcentaje de datos faltantes\nObtener estadísticas univariadas para las nuevas series temporales\n\n\n\n\n\n\n\n\n\n\nTarea\n\n\n\n\nVer la sección de métodos en Metz et al. (2017)\nQué otros algoritmos existen o qué otra aproximación podría seguirse?"
  },
  {
    "objectID": "unidad_4/exercise_temporal.html#agregación-con-granularidad",
    "href": "unidad_4/exercise_temporal.html#agregación-con-granularidad",
    "title": "Ejercicio: Series temporales en GRASS GIS",
    "section": "Agregación con granularidad",
    "text": "Agregación con granularidad\n\n\n\n\n\n\nTarea\n\n\n\n\nObtener el promedio de NDVI cada dos meses\nVisualizar la serie de tiempo resultante con TimeSeriesMap"
  },
  {
    "objectID": "unidad_4/exercise_temporal.html#indicadores-de-fenología",
    "href": "unidad_4/exercise_temporal.html#indicadores-de-fenología",
    "title": "Ejercicio: Series temporales en GRASS GIS",
    "section": "Indicadores de fenología",
    "text": "Indicadores de fenología\n\nFecha de ocurrencia de máximos y mínimos\nIdentificamos primero los máximos y mínimos de la serie, luego reemplazamos con start_month() los valores en la STRDS si coinciden con el mínimo o máximo global y finalmente obtenemos el primer mes en el que aparecieron el máximo y el mínimo.\n\nmethods = [\"maximum\",\"minimum\"]\n\nfor me in methods:\n    # get maximum and minimum\n    gs.run_command(\"t.rast.series\",\n                   input=\"ndvi_monthly_patch\",\n                   method=me,\n                   output=f\"ndvi_{me}\")\n    # get month of maximum and minimum\n    gs.run_command(\"t.rast.mapcalc\",\n                   inputs=\"ndvi_monthly_patch\",\n                   output=f\"month_{me}_ndvi\",\n                   expression=f\"if(ndvi_monthly_patch == ndvi_{me}, start_month(), null())\",\n                   basename=f\"month_{me}_ndvi\")\n    # get the earliest month in which the maximum and minimum appeared\n    gs.run_command(\"t.rast.series\",\n                   input=f\"month_{me}_ndvi\",\n                   method=\"minimum\",\n                   output=f\"earliest_month_{me}_ndvi\")\n    # remove intermediate strds \n    gs.run_command(\"t.remove\",\n                   flags=\"rfd\",\n                   inputs=f\"month_{me}_ndvi\")\n\n\n\n\n\n\n\nTarea\n\n\n\n\nMostrar los mapas resultantes con InteractiveMap\nCuándo se observan los mínimos y máximos? Hay algun patrón? A qué se podría deber?\n\n\n\n\n\n\n\n\n\nTarea\n\n\n\n\nAsociar el máximo de LST con el máximo de NDVI y, la fecha de la máxima LST con la fecha del máximo NDVI\nAgregar el mapset modis_lst a los mapsets accesibles.\nVer el módulo r.covar\n\n\n\n\n\nTasa de crecimiento\nObtener series temporales de pendientes entre mapas consecutivos\n\n# time series of slopes\nexpression = \"slope_ndvi = (ndvi_monthly_patch[1] - ndvi_monthly_patch[0]) / td(ndvi_monthly_patch)\"\n\ngs.run_command(\"t.rast.algebra\", \n               expression=expression,\n               basename=\"slope_ndvi\",\n               suffix=\"gran\")\n\nObtener la máxima pendiente por año\n\n# get max slope per year\ngs.run_command(\"t.rast.aggregate\",\n               input=\"slope_ndvi\",\n               output=\"ndvi_slope_yearly\",\n               basename=\"NDVI_max_slope_year\",\n               suffix=\"gran\",\n               method=\"maximum\",\n               granularity=\"1 years\")\n\n\n\n\n\n\n\nTarea\n\n\n\n\nObtener un mapa con la mayor tasa de crecimiento por píxel en el período 2015-2019\nQué modulo usarían?\n\n\n\n\n\nPeríodo de crecimiento\nInstalar la extensión r.seasons\n\n# install extension\ngs.run_command(\"g.extension\",\n               extension=\"r.seasons\")\n\nDeterminar el comienzo, el final y la duración del período de crecimiento\n\n# start, end and length of growing season\ngs.run_command(\"r.seasons\",\n               input=patched_maps,\n               prefix=\"ndvi_season\",\n               n=3,\n               nout=\"ndvi_season\",\n               threshold_value=3000,\n               min_length=5)\n\n\n\n\n\n\n\nTarea\n\n\n\n\nQué nos dice cada mapa? Dónde es más larga la estación de crecimiento?\nExportar los mapas resultantes como .png\n\n\n\nCrear un mapa de umbrales para usar en r.seasons\n\n# create a threshold map: min ndvi + 0.1*ndvi\ngs.mapcalc(exp=\"threshold_ndvi = ndvi_min * 1.1\")\n\n\n\n\n\n\n\nTarea\n\n\n\nUtilizar el mapa de umbrales en r.seasons y comparar los mapas de salida con los resultados de utilizar sólo un valor de umbral"
  },
  {
    "objectID": "unidad_4/exercise_temporal.html#serie-de-tiempo-de-ndwi",
    "href": "unidad_4/exercise_temporal.html#serie-de-tiempo-de-ndwi",
    "title": "Ejercicio: Series temporales en GRASS GIS",
    "section": "Serie de tiempo de NDWI",
    "text": "Serie de tiempo de NDWI\nListas de mapas de reflectancia\n\nlist_nir = gs.list_grouped(type=\"raster\", \n                           pattern=\"*NIR*\")[\"modis_ndvi\"]\nlist_mir = gs.list_grouped(type=\"raster\", \n                           pattern=\"*MIR*\")[\"modis_ndvi\"]\n\nlen(list_nir,list_mir)\n\nAsignamos semantic labels correspondientes a las bandas\n\n# asign semantic labels to NIR and MIR maps\nfor i in list_nir:\n    gs.run_command(\"r.support\",\n                   map=i,\n                   semantic_label=\"nir\")\n\nfor i in list_mir:\n    gs.run_command(\"r.support\",\n                   map=i,\n                   semantic_label=\"mir\")\n\n\n# check\ngs.raster_info(\"MOD13C2.A2015001.006.single_Monthly_MIR_reflectance\")[\"semantic_label\"]\n\nCrear series temporales de NIR y MIR\n\n# create time series of NIR and MIR altogether\ngs.run_command(\"t.create\",\n               output=\"modis_surf\",\n               type=\"strds\",\n               temporaltype=\"absolute\",\n               title=\"Monthly surface reflectance, NIR and MIR\",\n               description=\"NIR and MIR monthly - MOD13C2 - 2015-2019\")\n\nRegistrar mapas\n\n# register maps\ngs.run_command(\"t.register\",\n               input=\"modis_surf\",\n               maps=list_nir,\n               start=\"2015-01-01\",\n               increment=\"1 months\",\n               flags=\"i\")\n\ngs.run_command(\"t.register\",\n               input=\"modis_surf\",\n               maps=list_mir,\n               start=\"2015-01-01\",\n               increment=\"1 months\",\n               flags=\"i\")\n\nImprimir información de la serie de tiempo\n\n# print time series info\nprint(gs.read_command(\"t.info\", \n                      input=\"modis_surf\"))\n\n\n# List only NIR maps\nprint(gs.read_command(\"t.rast.list\", \n                      input=\"modis_surf.nir\", \n                      columns=\"name,semantic_label\"))\n\nEstimación de la serie temporal de NDWI\n\n# extract nir and mir strds\nsls = [\"nir\", \"mir\"]\n\nfor sl in sls:\n    gs.run_command(\"t.rast.extract\",\n                   input=\"modis_surf\",\n                   where=f\"semantic_label == '{sl}'\",\n                   output=sl)\n\n\n# estimate NDWI time series\nexpression=\"ndwi_monthly = if(nir &gt; 0 && mir &gt; 0, (float(nir - mir) / float(nir + mir)), null())\"\n\ngs.run_command(\"t.rast.algebra\",\n               basename=\"ndwi_monthly\",\n               expression=expression,\n               suffix=\"gran\",\n               flags=\"n\")\n\n\n# estimate NDWI time series\n#gs.run_command(\"t.rast.mapcalc\", \n#               inputs=\"modis_surf.mir,modis_surf.nir\", \n#               output=\"ndwi_monthly\", \n#               basename=\"ndwi\",\n#               expression=\"float(modis_surf.nir - modis_surf.mir) / (modis_surf.nir + modis_surf.mir)\")\n\n\ngs.run_command(\"t.rast.colors\", \n               input=\"ndwi_monthly\", \n               color=\"ndwi\")\n\n\nprint(gs.read_command(\"t.info\", \n                      input=\"ndwi_monthly\"))\n\n\n\n\n\n\n\nTarea\n\n\n\nObtener valores máximos y mínimos para cada mapa de NDWI y explorar el trazado de la serie de tiempo en diferentes puntos de forma interactiva\nVer el manual de t.rast.univar\n\n\n\nFrecuencia de inundación\nReclasificar los mapas según un umbral\n\n# reclassify\ngs.run_command(\"t.rast.mapcalc\",\n               input=\"ndwi_monthly\",\n               output=\"flood\",\n               basename=\"flood\",\n               expression=\"if(ndwi_monthly &gt; 0.8, 1, null())\",\n               flags=\"n\")\n\nObtener frecuencia de inundación\n\n# flooding frequency\ngs.run_command(\"t.rast.series\",\n               input=\"flood\",\n               output=\"flood_freq\",\n               method=\"sum\")\n\n\n\n\n\n\n\nTarea\n\n\n\nCuáles son las áreas que se han inundado con más frecuencia?"
  },
  {
    "objectID": "unidad_4/exercise_temporal.html#regresión-ndvi-ndwi",
    "href": "unidad_4/exercise_temporal.html#regresión-ndvi-ndwi",
    "title": "Ejercicio: Series temporales en GRASS GIS",
    "section": "Regresión NDVI-NDWI",
    "text": "Regresión NDVI-NDWI\nInstalar la extensión r.regression.series\n\n# install extension\ngs.run_command(\"g.extension\",\n               extension=\"r.regression.series\")\n\nRealizar una regresión entre las series temporales de NDVI y NDWI\n\nxseries = patched_maps[1:]\nyseries = gs.list_grouped(type=\"raster\",\n                          pattern=\"ndwi_monthly*\")[\"modis_ndvi\"]\n\ngs.run_command(\"r.regression.series\",\n               xseries=xseries,\n               yseries=yseries,\n               output=\"ndvi_ndwi_rsq\",\n               method=\"rsq\")\n\n\nrsq = gj.InteractiveMap(width = 400, use_region=True)\nrsq.add_raster(\"ndvi_ndwi_rsq\", opacity=0.8)\nrsq.add_layer_control(position = \"bottomright\")\nrsq.show()\n\n\n\n\n\n\n\nTarea\n\n\n\nDeterminar dónde está la mayor correlación entre NDVI y NDWI"
  },
  {
    "objectID": "unidad_4/exercise_temporal.html#recursos-muy-útiles",
    "href": "unidad_4/exercise_temporal.html#recursos-muy-útiles",
    "title": "Ejercicio: Series temporales en GRASS GIS",
    "section": "Recursos (muy) útiles",
    "text": "Recursos (muy) útiles\n\nTemporal data processing wiki\nGRASS GIS and R for time series processing wiki\nGRASS GIS temporal workshop at NCSU\nGRASS GIS course IRSAE 2018\nGRASS GIS workshop held in Jena 2023"
  },
  {
    "objectID": "unidad_5/grass_and_r_sdm.html#uso",
    "href": "unidad_5/grass_and_r_sdm.html#uso",
    "title": "R y GRASS: Modelado de nicho",
    "section": "Uso",
    "text": "Uso\nGRASS GIS y R se pueden utilizar juntos de dos maneras:\nA. Usar R dentro de una sesión de GRASS GIS, es decir, iniciar R (o RStudio) desde la terminal de GRASS \n\nescribimos R o rstudio & en la terminal GRASS GIS\ncargar el paquete rgrass (previo haberlo instalado)\nusar read_VECT(), read_RAST() para leer datos de GRASS en R\nacceder a los módulos y la base de datos de GRASS GIS a través de execGRASS() (notar que este comando es equivalente a run_command de grass.script)\nvolver a escribir datos en la base de datos de GRASS con write_VECT() y write_RAST()\n\n\n\n\n\n\nB. Usar GRASS GIS dentro de una sesión de R, es decir, nos conectamos a la base de datos de GRASS GIS desde R (o RStudio). \n\nNecesitamos iniciar GRASS GIS con initGRASS() desde R\nAccedemos a los módulos GRASS GIS a través de execGRASS()\n\nusamos read_VECT(), read_RAST(), write_VECT() y write_RAST() para leer datos desde y hacia la base de datos GRASS.\n\n\n\n\n\n\n\nNota\n\n\n\nOriginalmente, rgrass estaba destinado a aplicar funciones de GRASS en datos fuera de la base de datos de GRASS; de ahí que algunos prefieran crear proyectos (i.e., locations) desechables o temporarios."
  },
  {
    "objectID": "unidad_5/grass_and_r_sdm.html#iniciamos-grass",
    "href": "unidad_5/grass_and_r_sdm.html#iniciamos-grass",
    "title": "R y GRASS: Modelado de nicho",
    "section": "Iniciamos GRASS",
    "text": "Iniciamos GRASS\nUsaremos la opción B, es decir, iniciamos GRASS GIS desde R en un proyecto y mapset existentes. Notar las similitudes con gj.init() de grass.jupyter y gs.setup.init() de grass.script.\n\n%%R\n# path to GRASS binaries (run `grass --config path`)\ngrassbin &lt;- system(\"grass --config path\", intern = TRUE)\n# path to GRASS database in GDrive\ngrassdata &lt;- \"/content/drive/MyDrive/curso_grass_2023/grassdata\"\n# path to project\nproject &lt;- \"posgar2007_4_cba\"\n# path to mapset\nmapset &lt;- \"PERMANENT\"\n\n# start GRASS GIS from R\ninitGRASS(gisBase = grassbin, \n          gisDbase = grassdata, \n          location = project, \n          mapset = mapset, \n          override = TRUE,\n          remove_GISRC= TRUE)\n\nExploramos los mapas raster y vectoriales disponibles en el mapset PERMANENT:\n\n%%R\nr &lt;- execGRASS(\"g.list\", \n               parameters = list(type = \"raster\",\n                                 mapset = \".\"))\nv &lt;- execGRASS(\"g.list\", \n               parameters = list(type = \"vector\",\n                                 mapset = \".\"))"
  },
  {
    "objectID": "unidad_5/grass_and_r_sdm.html#disclaimer",
    "href": "unidad_5/grass_and_r_sdm.html#disclaimer",
    "title": "R y GRASS: Modelado de nicho",
    "section": "Disclaimer",
    "text": "Disclaimer\nThis is only a simple example for doing SDM and only the beginning… There are:\n\nother models to test\nhyper-parameter tuning\nensemble modeling\nuncertainty assessment: where we can predict with confidence\nmany other relevant packages:\n\n\ndismo, sdm, kuenm, caret, CAST, etc."
  },
  {
    "objectID": "unidad_5/grass_and_r_sdm.html#lectura-de-datos-vectoriales",
    "href": "unidad_5/grass_and_r_sdm.html#lectura-de-datos-vectoriales",
    "title": "R y GRASS: Modelado de nicho",
    "section": "Lectura de datos vectoriales",
    "text": "Lectura de datos vectoriales\nAhora leemos desde GRASS los datos de ocurrencia y los puntos de background, los convertimos en objetos sf y los mostramos con mapview.\n\n# Read vector layers\npresence &lt;- st_as_sf(read_VECT(\"aedes_aegypti\"))\nbackground &lt;- st_as_sf(read_VECT(\"background_points\"))"
  },
  {
    "objectID": "unidad_5/grass_and_r_sdm.html#lectura-de-datos-ráster",
    "href": "unidad_5/grass_and_r_sdm.html#lectura-de-datos-ráster",
    "title": "R y GRASS: Modelado de nicho",
    "section": "Lectura de datos ráster",
    "text": "Lectura de datos ráster\nLeemos ahora algunas de las variables que derivamos de las series temporales de LST y NDVI.\n\n# List rasters by pattern\nworldclim &lt;- execGRASS(\"g.list\", \n                       parameters = list(type = \"raster\", \n                                         pattern = \"worldclim*\"))\navg &lt;- execGRASS(\"g.list\", \n                 parameters = list(type = \"raster\", \n                                   pattern = \"avg*\"))\nmedian &lt;- execGRASS(\"g.list\", \n                    parameters = list(type = \"raster\", \n                                      pattern = \"median*\", \n                                      exclude = \"*[1-5]\"))\n\n# Concatenate map lists\nto_import &lt;- c(attributes(worldclim)$resOut, \n               attributes(avg)$resOut, \n               attributes(median)$resOut)\n\n# Read raster layers\npredictors &lt;- list()\nfor (i in to_import){ \n  predictors[i] &lt;- read_RAST(i) }\n\n# Stack rasters\npredictors_r &lt;- rast(predictors)\n\nVisualicemos los mapas importados. Convertimos el objeto terra en raster porque mapview aún no es compatible con terra.\n\n# Quick visualization in mapview\nmapview(raster::raster(predictors_r[['worldclim_bio01']])) + presence"
  },
  {
    "objectID": "unidad_5/grass_and_r_sdm.html#preparación-de-los-datos",
    "href": "unidad_5/grass_and_r_sdm.html#preparación-de-los-datos",
    "title": "R y GRASS: Modelado de nicho",
    "section": "Preparación de los datos",
    "text": "Preparación de los datos\nAhora que hemos creado y/o importado los registros de presencia, los puntos de background y las variables predictivas, necesitamos preparar los datos en un formato llamado samples with data (SWD). Éste es básicamente una tabla con coordenadas de presencia y background más los valores correspondientes a las variables predictoras para cada punto.\n\n%%R\n# Variables for models\nsp &lt;- \"Aedes aegypti\"\npresence_coords &lt;- st_coordinates(presence)\nbackground_coords &lt;- background\nenv &lt;- predictors_r\n\n# Prepare data: SWD\ndata_sp &lt;- prepareSWD(species = sp, \n                      p = presence_coords, \n                      a = background_coords, \n                      env = env)\n\ndata_sp"
  },
  {
    "objectID": "unidad_5/grass_and_r_sdm.html#definición-de-parámetros",
    "href": "unidad_5/grass_and_r_sdm.html#definición-de-parámetros",
    "title": "R y GRASS: Modelado de nicho",
    "section": "Definición de parámetros",
    "text": "Definición de parámetros\nAquí definimos algunos de los valores de entrada necesarios para el flujo de trabajo:\n\n%%R\nseed=123\nperc_test = 0.2\nk = 4\nmethod=\"Maxent\"\ncor_th=0.7\nperm=10\nimp_th=10"
  },
  {
    "objectID": "unidad_5/grass_and_r_sdm.html#datos-de-entrenamiento-y-evaluación",
    "href": "unidad_5/grass_and_r_sdm.html#datos-de-entrenamiento-y-evaluación",
    "title": "R y GRASS: Modelado de nicho",
    "section": "Datos de entrenamiento y evaluación",
    "text": "Datos de entrenamiento y evaluación\nEntrenaremos el modelo con un 80% de muestras de presencia, y dejaremos el 20% restante para la evaluación al final.\n\n%%R\n# Create training and test sets\nc(train_sp, test_sp) %&lt;-% \n  trainValTest(data_sp, \n               test = perc_test,\n               only_presence = TRUE, \n               seed = seed)\n\n\n%R train_sp\n\n\n%R test_sp"
  },
  {
    "objectID": "unidad_5/grass_and_r_sdm.html#creación-de-folds-para-validación-cruzada",
    "href": "unidad_5/grass_and_r_sdm.html#creación-de-folds-para-validación-cruzada",
    "title": "R y GRASS: Modelado de nicho",
    "section": "Creación de folds para validación cruzada",
    "text": "Creación de folds para validación cruzada\nComo usaremos validación cruzada durante el entrenamiento del modelo, creamos los folds con anticipación. En este caso utilizamos folds aleatorios, pero existen otros métodos de determinarlos. Como estamos limitados por la cantidad de registros de presencia, crearemos solo 4 folds o subconjuntos. El algoritmo utilizará iterativamente 3 subconjuntos para entrenar y 1 para validar, pero siempre dentro del entrenamiento.\n\n%%R\n# Create folds \nran_folds &lt;- randomFolds(train_sp, \n                         k = k,\n                         only_presence = TRUE, \n                         seed = seed)"
  },
  {
    "objectID": "unidad_5/grass_and_r_sdm.html#entrenamiento-con-validación-cruzada",
    "href": "unidad_5/grass_and_r_sdm.html#entrenamiento-con-validación-cruzada",
    "title": "R y GRASS: Modelado de nicho",
    "section": "Entrenamiento con validación cruzada",
    "text": "Entrenamiento con validación cruzada\nPrimero entrenaremos un llamado modelo completo, es decir, un modelo con todos los predictores, y de allí eliminaremos aquellos que estén altamente correlacionados y cuya contribución a la predicción no sea importante.\n\n%%R\n# Train a full model\nfull_model_sp &lt;- train(method = method,\n                       data = train_sp, \n                       folds = ran_folds)\n\nfull_model_sp\n\nVeamos las predicciones geográficas del modelo completo o full model\n\n%%R\npred_full_model &lt;- predict(full_model_sp,\n                           data = env,\n                           type = \"cloglog\")\n\nplot(pred_full_model)"
  },
  {
    "objectID": "unidad_5/grass_and_r_sdm.html#selección-de-variables",
    "href": "unidad_5/grass_and_r_sdm.html#selección-de-variables",
    "title": "R y GRASS: Modelado de nicho",
    "section": "Selección de variables",
    "text": "Selección de variables\n\nRemover variables altamente correlacionadas\nLuego procedemos a eliminar los predictores correlacionados ya que proporcionan información altamente redundante y pueden afectar el rendimiento de los modelos, es decir, como con todos los modelos, queremos que sea simple y del mayor rendimiento posible. Usaremos el área bajo la curva ROC (AUC) como métrica de rendimiento y eliminaremos las variables correlacionadas solo si el AUC disminuye si las mantenemos.\n\n%%R\n# Prepare background locations to test correlation\nbg_sp &lt;- prepareSWD(species = sp, \n                    a = background_coords,\n                    env = env)\n\n# Remove variables with correlation higher than 0.7 \n# while accounting for the AUC\nvs_sp &lt;- varSel(full_model_sp,\n                metric = \"auc\", \n                bg4cor = bg_sp, \n                cor_th = cor_th,\n                permut = perm,\n                interactive = FALSE)\n\nExploremos el objeto de salida\n\n%R vs_sp@data\n\n\n\nRemover variables de menor importancia\nDespués de descartar las variables correlacionadas, también eliminaremos las variables que tengan una contribución porcentual o una importancia inferior al 10%, considerando como su mantenimiento o remoción afecta al AUC.\n\n%%R\n# remove less important variables only if auc does not decrease\nreduc_var_sp &lt;- reduceVar(vs_sp,\n                          th = imp_th, \n                          metric = \"auc\", \n                          test = TRUE, \n                          permut = perm, \n                          use_jk = TRUE,\n                          interactive = FALSE)\n\nExploremos el objeto resultante\n\n%R reduc_var_sp\n\nAhora necesitamos recrear el objeto SWD y los conjuntos de datos de entrenamiento y evaluación, pero solo con las variables seleccionadas, para poder ejecutar el modelo final y hacer predicciones.\n\n%%R\n# Get only relevant variables from the reduced model\nretained_varnames &lt;- names(reduc_var_sp@models[[1]]@data@data)\n\n# Subset stack\nenv &lt;- terra::subset(env, retained_varnames)\n\n# SWD with the selected vars\nsubset_train_sp &lt;- prepareSWD(species = sp, \n                              p = presence_coords,\n                              a = background_coords,\n                              env = env)\n\nc(train_sp, test_sp) %&lt;-% \n  trainValTest(subset_train_sp, \n               test = perc_test, \n               only_presence = TRUE, \n               seed = seed)"
  },
  {
    "objectID": "unidad_5/grass_and_r_sdm.html#predicciones-con-el-modelo-seleccionado",
    "href": "unidad_5/grass_and_r_sdm.html#predicciones-con-el-modelo-seleccionado",
    "title": "R y GRASS: Modelado de nicho",
    "section": "Predicciones con el modelo seleccionado",
    "text": "Predicciones con el modelo seleccionado\nAhora entrenamos el modelo final con el conjunto de entrenamiento completo, ya no necesitamos los folds en este punto. Tengan en cuenta que también utilizamos las feature classes (fc) y la regularización (reg) del mejor modelo obtenido anteriormente. En este caso, son solo valores predeterminados, pero si también realizamos una optimización de hiperparámetros, pueden diferir.\n\n%%R\nfinal_model_sp &lt;- train(method = method, \n                        data = train_sp,\n                        fc = reduc_var_sp@models[[1]]@model@fc,\n                        reg = reduc_var_sp@models[[1]]@model@reg)\n\n\n\n\n\n\n\nNota\n\n\n\nSi les interesa conocer opciones de optimización de hiperparámetros en el contexto de los SDM, puedes chequear el siguiente artículo: https://consbiol-unibern.github.io/SDMtune/articles/tune-hyperparameters.html\n\n\nHagamos las predicciones en el espacio geográfico y exploremos el resultado\n\n%%R\nmap_sp_maxent &lt;- predict(final_model_sp,\n                         data = env, \n                         type = \"cloglog\")\n\nplot(map_sp_maxent)"
  },
  {
    "objectID": "unidad_5/grass_and_r_sdm.html#write-result-back-to-grass",
    "href": "unidad_5/grass_and_r_sdm.html#write-result-back-to-grass",
    "title": "R y GRASS: Modelado de nicho",
    "section": "Write result back to GRASS",
    "text": "Write result back to GRASS\nWe can now write the raster with the final model’s predictions into the GRASS database.\n\nwrite_RAST(map_sp_maxent, \n           \"Aedes_albopictus_maxent\", \n           flags = c(\"o\",\"overwrite\"))\n\nCheck the map is there\n\nexecGRASS(\"g.list\", \n          parameters = list(type=\"raster\",\n                            pattern=\"Aedes*\"))"
  },
  {
    "objectID": "unidad_5/grass_and_r_sdm.html#model-evaluation",
    "href": "unidad_5/grass_and_r_sdm.html#model-evaluation",
    "title": "R y GRASS: Modelado de nicho",
    "section": "Model evaluation",
    "text": "Model evaluation\nWe want to know how good our model is, so in this step we use the test dataset that we separated in the beginning. An AUC of 0.5 would mean the model performs like flipping a coin. AUC is what we call a threshold independent evaluation metric.\n\n# AUC\nauc_maxent &lt;- auc(final_model_sp, test = test_sp)\nauc_maxent\n\nUsually, however, the result of SDM is converted into presence/absence maps. To determine which threshold to use we perform threshold dependent evaluations.\n\n# Threshold dependent evaluation\nth_maxent &lt;- thresholds(final_model_sp, \n                        type = \"cloglog\", \n                        test = test_sp)\n\nknitr::kable(th_maxent, format = 'html', digits = 2)\n\nLet’s choose one threshold and create a binary map\n\np = map_sp_maxent &gt;= 0.5\na = map_sp_maxent &lt; 0.5\nmap_sp_maxent[p] &lt;- 1\nmap_sp_maxent[a] &lt;- 0\n\nmapview(raster::raster(map_sp_maxent))"
  },
  {
    "objectID": "unidad_5/grass_and_r_sdm.html#variable-importance",
    "href": "unidad_5/grass_and_r_sdm.html#variable-importance",
    "title": "R y GRASS: Modelado de nicho",
    "section": "Variable importance",
    "text": "Variable importance\nVariable importance is an indicator of variable contribution to prediction.\n\nvi_model_sp &lt;- maxentVarImp(final_model_sp)\nvi_model_sp\n\n\nplotVarImp(vi_model_sp)"
  },
  {
    "objectID": "unidad_5/grass_and_r_sdm.html#response-curves",
    "href": "unidad_5/grass_and_r_sdm.html#response-curves",
    "title": "R y GRASS: Modelado de nicho",
    "section": "Response curves",
    "text": "Response curves\nResponse curves give us an idea of the relationship between predictor variables and probability of occurrence.\n\nmy_rp &lt;- function(i){\n  plotResponse(reduc_var_sp, i)\n}\n\nplotlist &lt;- lapply(retained_varnames, my_rp)\nlabels &lt;- LETTERS[1:length(retained_varnames)]\nggpubr::ggarrange(plotlist = plotlist, labels = labels)\n\nWe close the mapset and done\n\n# close the mapset\nunlink_.gislock()"
  },
  {
    "objectID": "unidad_5/grass_and_r_sdm.html#vamos-a-r",
    "href": "unidad_5/grass_and_r_sdm.html#vamos-a-r",
    "title": "R y GRASS: Modelado de nicho",
    "section": "Vamos a R",
    "text": "Vamos a R\nCargamos los paquetes necesarios\n\n%%R\nlibrary(rgrass)\nlibrary(sf)\nlibrary(terra)\nlibrary(mapview)\nlibrary(biomod2)\nlibrary(dismo)\nlibrary(usdm)\nlibrary(SDMtune)\nlibrary(zeallot)\nlibrary(tmap)\nlibrary(tmaptools)"
  },
  {
    "objectID": "unidad_5/grass_and_r_sdm.html#guardamos-la-predicción-en-grass",
    "href": "unidad_5/grass_and_r_sdm.html#guardamos-la-predicción-en-grass",
    "title": "R y GRASS: Modelado de nicho",
    "section": "Guardamos la predicción en GRASS",
    "text": "Guardamos la predicción en GRASS\nAhora podemos escribir el ráster con las predicciones del modelo final en la base de datos de GRASS.\n\n%%R\nwrite_RAST(map_sp_maxent, \n           \"Aedes_aegypti_maxent\", \n           flags = c(\"o\",\"overwrite\"))\n\nCorroboramos que el mapa creado esté allí\n\n%%R\nexecGRASS(\"g.list\", \n          parameters = list(type=\"raster\",\n                            pattern=\"Aedes*\"))"
  },
  {
    "objectID": "unidad_5/grass_and_r_sdm.html#evaluación-del-modelo",
    "href": "unidad_5/grass_and_r_sdm.html#evaluación-del-modelo",
    "title": "R y GRASS: Modelado de nicho",
    "section": "Evaluación del modelo",
    "text": "Evaluación del modelo\nQueremos saber qué tan bueno es nuestro modelo, por eso en este paso usamos el conjunto de datos de evaluación que separamos al principio. Un AUC de 0,5 significaría que el modelo funciona equivalentemente a lanzar una moneda al aire. AUC es lo que llamamos una métrica de evaluación independiente de umbral.\n\n%%R\n# AUC\nauc_maxent &lt;- auc(final_model_sp, test = test_sp)\nauc_maxent\n\nNormalmente el resultado del SDM se convierte en mapas de presencia/ausencia. Para determinar qué umbral utilizar, realizamos evaluaciones dependientes del umbral.\n\n%%R\n# Threshold dependent evaluation\nth_maxent &lt;- thresholds(final_model_sp, \n                        type = \"cloglog\", \n                        test = test_sp)\n\nknitr::kable(th_maxent, format = 'html', digits = 2)\n\nElegimos un umbral y creamos un mapa binario, i.e., de presencia y ausencia\n\n%%R\np = map_sp_maxent &gt;= 0.5\na = map_sp_maxent &lt; 0.5\nmap_sp_maxent[p] &lt;- 1\nmap_sp_maxent[a] &lt;- 0\n\nplot(map_sp_maxent)"
  },
  {
    "objectID": "unidad_5/grass_and_r_sdm.html#importancia-de-las-variables",
    "href": "unidad_5/grass_and_r_sdm.html#importancia-de-las-variables",
    "title": "R y GRASS: Modelado de nicho",
    "section": "Importancia de las variables",
    "text": "Importancia de las variables\nLa importancia de las variables es un indicador de la contribución variable a la predicción.\n\n%%R\nvi_model_sp &lt;- maxentVarImp(final_model_sp)\nvi_model_sp\n\n\n%R plotVarImp(vi_model_sp)"
  },
  {
    "objectID": "unidad_5/grass_and_r_sdm.html#cuervas-de-respuesta",
    "href": "unidad_5/grass_and_r_sdm.html#cuervas-de-respuesta",
    "title": "R y GRASS: Modelado de nicho",
    "section": "Cuervas de respuesta",
    "text": "Cuervas de respuesta\nLas curvas de respuesta nos dan una idea de la relación entre las variables predictoras y la probabilidad de ocurrencia del evento de interés.\n\nmy_rp &lt;- function(i){\n  plotResponse(reduc_var_sp, i)\n}\n\nplotlist &lt;- lapply(retained_varnames, my_rp)\nlabels &lt;- LETTERS[1:length(retained_varnames)]\nggpubr::ggarrange(plotlist = plotlist, labels = labels)\n\nCerramos el mapset y terminamos :)\n\n# close the mapset\nunlink_.gislock()"
  },
  {
    "objectID": "index.html#dia-1-localmente",
    "href": "index.html#dia-1-localmente",
    "title": "Procesamiento y análisis de series temporales con GRASS GIS",
    "section": "Dia 1: localmente",
    "text": "Dia 1: localmente\nPara el primer día del curso, necesitamos ejecutar GRASS GIS de manera local. Si bien la mayor parte del material del taller se puede ejecutar teóricamente en todas las plataformas, algunas partes requieren herramientas que suelen ser más difíciles de configurar en Windows. Por lo tanto, para quien desee ejecutar todo el curso de manera local recomendamos usar entornos Linux/Unix.\n\nSoftware necesario\n\nGRASS GIS &gt;= v8.2.0\nPython &gt;= 3.7 con los siguientes paquetes:\n\njupyterlab, numpy, matplotlib, seaborn, scikit-learn, scipy, pandas, folium\n\nR &gt;= 4.2 con los siguientes paquetes:\n\nrgrass, sf, terra, raster, mapview, SDMtune, biomod2, dismo, usdm, zeallot, ggpubr, rJava\n\nQGIS\n\n\nNota para usuarios Ubuntu\nUsar el PPA inestable de ubuntugis para obtener la última versión de GRASS GIS:\nsudo add-apt-repository ppa:ubuntugis/ubuntugis-unstable\nsudo apt update\nsudo apt install grass grass-gui grass-dev\n\n\n\nDatos necesarios\n\nDescargar el archivo comprimido que incluye los datos de muestra para utilizar durante el primer día."
  },
  {
    "objectID": "index.html#día-2-al-5-online",
    "href": "index.html#día-2-al-5-online",
    "title": "Procesamiento y análisis de series temporales con GRASS GIS",
    "section": "Día 2 al 5: online",
    "text": "Día 2 al 5: online\nEl resto del curso se ejecutará en línea ya sea dentro de la plataforma Whole Tale o en Google Colab.\nWhole Tale es una iniciativa de la Data Infrastructure Building Block (DIBBS) financiada por NSF para construir una plataforma escalable y multiusuario de código abierto, basada en la web para investigaciones reproducibles. Permite la creación, publicación y ejecución de tales: objetos de investigación ejecutables que capturan datos, código y el entorno de software completo utilizado para producir los resultados de la investigación. También es fantástico para enseñar, ya que los participantes no necesitan instalar todos los paquetes de software necesarios. ¡Solo necesitan registrarse con un correo electrónico institucional o personal y ya están listos para comenzar!\nWhole Tale:\n\nIr a Curso GRASS GIS 2023\nLog in (hay diferentes opciones)\nEjecutar la Tale (botón azul arriba a la derecha)\nConfirmar Copy y Run Tale\nSi sigue mostrando “Importing…”, recargar\nRun Tale\n\nGoogle Colab:\n\nFile -&gt; Open notebook\nSeleccionar Github\nPegar https://github.com/veroandreo/curso-grass-gis/blob/main/install_colab.ipynb\n\nEn Google Colab no tenemos preinstalado el software necesario, así que necesitarás ejecutar la notebook para instalarlo.\n\nDatos necesarios\n\nCopiarse al drive la siguiente carpeta:\n\nSi bien la mayor parte del material del taller se puede ejecutar teóricamente en todas las plataformas, algunas partes requieren herramientas que suelen ser más difíciles de configurar en Windows. Por lo tanto, para quien desee ejecutar todo el curso de manera local recomendamos usar entornos Linux/Unix."
  },
  {
    "objectID": "unidad_5/grass_and_r_sdm.html#datos-de-presenciaocurrencia",
    "href": "unidad_5/grass_and_r_sdm.html#datos-de-presenciaocurrencia",
    "title": "R y GRASS: Modelado de nicho",
    "section": "Datos de presencia/ocurrencia",
    "text": "Datos de presencia/ocurrencia\nPara este ejercicio vamos a generar los puntos de ocurrencia del mosquito Aedes aegypti como un sub-conjunto al azar de las localidades (áreas edificadas) de la provincia de Córdoba que estén a una altura de menos de 850 m. Notar que estamos trabajando en la base de datos de GRASS GIS, pero desde R.\n\n%%R\n# Extract centroids from built-up area polygons\nexecGRASS(\"v.extract\", \n          parameters = list(input=\"area_edificada_cba\", \n                            type=\"centroid\", \n                            output=\"area_edificada_cba_centroides\", \n                            random=250))\n\n# convert centroids to points\nexecGRASS(\"v.type\", \n          parameters = list(input=\"area_edificada_cba_centroides\", \n                            output=\"area_edificada_cba_puntos\", \n                            from_type=\"centroid\", \n                            to_type=\"point\"))\n\n# extract elevation data for points\nexecGRASS(\"v.what.rast\", \n          parameters = list(map=\"area_edificada_cba_puntos\", \n                            raster=\"elevation\", \n                            column=\"elevation\"))\n\n# filter points by elevation, keep those &lt;= 850m\nexecGRASS(\"v.extract\",\n          parameters = list(input=\"area_edificada_cba_puntos\",\n                            where=\"elevation &lt;= 850\",\n                            output=\"aedes_aegypti\"))\n\nAhora leemos desde GRASS los datos de ocurrencia que generamos, los convertimos en un objeto sf, y los graficamos.\n\n%%R\n# Read vector layers\npresence &lt;- st_as_sf(read_VECT(\"aedes_aegypti\"))\n\n\n%%R\n# Display presence vector\nplot(presence)\n\nPodemos usar la función plot() para visualizar la geometría o la geometría y los atributos (o una selección de los mismos) de los objetos sf.\n\n%%R\n# Plot only the geometry \nplot(st_geometry(presence))\n\n# Plot geometry + attr\nplot(presence[\"elevation\"])"
  },
  {
    "objectID": "unidad_5/grass_and_r_sdm.html#datos-de-background",
    "href": "unidad_5/grass_and_r_sdm.html#datos-de-background",
    "title": "R y GRASS: Modelado de nicho",
    "section": "Datos de background",
    "text": "Datos de background\nEl algoritmo MaxEnt que vamos a usar en este ejercicio, requiere contrastar las variables ambientales en los sitios de ocurrencia con el resto del ambiente disponible para la especie, el background. Entonces, necesitamos generar puntos de background para caracterizar este ambiente disponible.\nUna opción es generar puntos al azar sobre nuestra área de estudio. No obstante, no es cierto que toda la extensión del área de estudio está disponible para Aedes aegypti. Esta especie de mosquito no cría en aguas abiertas y tampoco sobre las salinas. Entonces, vamos a enmascarar primero esas áreas del ambiente disponible.\n\n%%R\n# Check region\ngmeta()\n\n\n%%R\n# Generar máscara a partir del raster de LULC\nexpression &lt;- \n  \"no_water = if(landcover_2018 == 7 || landcover_2018 == 8, null(), landcover_2018)\"\n\nexecGRASS(\"r.mapcalc\",\n          parameters = list(expression=expression))\n\nLuego, leemos a R la máscara creada para visualizarla\n\n%%R\n# Import mask\nno_water &lt;- raster(read_RAST(\"no_water\"))\nplot(no_water)\n\nComo la región tiene una resolución de 30 m, vamos a llevarla a 1 km, para asegurarnos una mejor separación de los puntos de background, y volvemos a leer la máscara dentro de R.\n\n%%R\n# Change resolution\nexecGRASS(\"g.region\",\n          parameters = list(res=\"1000\"),\n          flags = c(\"a\",\"p\"))\n\n# Upscale\nexecGRASS(\"r.resamp.stats\",\n          parameters = list(input=\"no_water\",\n                            output=\"MASK\",\n                            method=\"mode\"))\n\n# Leer en R la mascara_spp que vive en GRASS\nmask &lt;- raster(read_RAST(\"MASK\"))\n\nAhora sí, generamos los puntos de background utilizando una función del paquete dismo(Hijmans et al. 2023) y los convertimos a sf para luego visualizarlos.\n\n%%R\n# Generate random points within mask\nset.seed(123)\nbackground &lt;- randomPoints(mask = mask, \n                           n = 500)\n\n# Convert to sf to plot\nbackground_sf &lt;- st_as_sf(as.data.frame(background), \n                          coords = c(1,2), \n                          crs = st_crs(mask))\n\n\n\n\n\n\n\nPregunta\n\n\n\nCon qué funcion de GRASS podríamos haber hecho algo similar?\n\n\nVisualizamos el mapa que usamos como máscara junto con los vectores de presencia y background usando la librería tmap (Tennekes 2018).\n\n%%R\n# Aux data\nbbox &lt;- st_bbox(mask)\n\nfig_puntos &lt;- \n  tm_shape(mask, \n           bbox = bbox) +\n  tm_raster(title = \"Classes\") +\n  tm_shape(presence) +\n  tm_dots(size = 0.02) +\n  tm_layout(main.title = \"Aedes aegypti\",\n            main.title.fontface = \"italic\",\n            main.title.size = 0.7,\n            main.title.position = \"left\",\n            legend.show = TRUE,\n            legend.outside = TRUE)\n\ntmap_save(fig_puntos, \n          filename = \"fig_puntos_y_mascara.png\", \n          width = 1000, height = 1300)\n\n\n\n\nMapa generado con tmap"
  },
  {
    "objectID": "unidad_5/grass_and_r_sdm.html#variables-ambientales",
    "href": "unidad_5/grass_and_r_sdm.html#variables-ambientales",
    "title": "R y GRASS: Modelado de nicho",
    "section": "Variables ambientales",
    "text": "Variables ambientales\nAntes de leer las variables ambientales que obtuvimos a partir de las series de tiempo de LST y NDVI, vamos a generar dos mapas ráster que representan la distancia a fuentes de agua y rutas y caminos, respectivamente. Para eso, vamos a usar mapas ya disponibles en el mapset PERMANENT.\n\n%%R\n# Patch water lines + water bodies\nexecGRASS(\"v.patch\",\n          parameters = list(input=\"lineas_aguas_continentales_perennes_cba,\n                            areas_aguas_continentales_perennes_cba,\n                            embalses\",\n                            output=\"lineas_y_cuerpos_de_agua_cba\"))\n\n# Convert to raster\nexecGRASS(\"v.to.rast\",\n          parameters = list(input=\"lineas_y_cuerpos_de_agua_cba\",\n                            output=\"lineas_y_cuerpos_de_agua_cba\",\n                            use=\"val\"))\n\n# Distance to water and roads\nexecGRASS(\"r.grow.distance\",\n          parameters = list(input=\"lineas_y_cuerpos_de_agua_cba\",\n                            distance=\"distancia_agua\"))\n\n\n%%R\n# Patch primary + secondary roads\nexecGRASS(\"v.patch\",\n          parameters = list(input=\"vial_primaria_cba,vial_secundaria_cba\",\n                            output=\"red_vial_cba\"))\n# Convert to raster\nexecGRASS(\"v.to.rast\",\n          parameters = list(input=\"red_vial_cba\",\n                            output=\"red_vial_cba\",\n                            use=\"val\"))\n\n# Distance to roads\nexecGRASS(\"r.grow.distance\",\n          parameters = list(input=\"red_vial_cba\",\n                            distance=\"distancia_caminos\"))\n\nLeemos los mapas generados y los visualizamos con plot(), que en este caso reconoce los objetos SpatRast.\n\n%%R\n\ndistancia_agua &lt;- read_RAST(\"distancia_agua\")\ndistancia_caminos &lt;- read_RAST(\"distancia_caminos\")\n\nplot(c(distancia_agua,distancia_caminos), \n     main=c(\"Distancia agua\", \"Distancia rutas\"))\n\nTambién podemos usar tmap y su función tm_facets()\n\n%%R\ndistancia &lt;- read_RAST(c(\"distancia_agua\",\"distancia_caminos\"))\n\nfig_raster_facet &lt;- \n  tm_shape(distancia, \n           bbox = bbox) +\n  tm_raster(style = \"cont\",\n            palette = \"magma\",\n            legend.show = FALSE) +\n  tm_facets()\n\nfig_raster_facet\n\n\nLectura de datos ráster de otros mapsets\nPara leer mapas de otros mapsets, necesitamos agregar esos mapsets a la lista de mapsets accesibles en el mapset donde estamos ahora.\n\n%%R\nexecGRASS(\"g.mapsets\",\n          parameters = list(mapset=\"modis_lst\",\n                            operation=\"add\"))\nexecGRASS(\"g.mapsets\",\n          parameters = list(mapset=\"modis_ndvi\",\n                            operation=\"add\"))\nexecGRASS(\"g.mapsets\",\n          flags = \"p\")\n\nLeemos ahora algunas de las variables que derivamos de las series temporales de LST y NDVI. Primero, necesitamos aplicar la máscara de los límites de la provincia.\n\n%R execGRASS(\"r.mask\", parameters = list(vector=\"provincia_cba\"))\n\n\n%%R\n# List rasters to import\nto_import &lt;- c(\"LST_Day_minimum\",\n               \"LST_Day_maximum\",\n               \"LST_Day_average\",\n               \"ndvi_maximum\",\n               \"ndvi_minimum\")\n\n# Read raster layers\npredictors &lt;- list()\nfor (i in to_import){ \n  predictors[i] &lt;- read_RAST(i) }\n\nAgrupamos todos los rasters de variables ambientales.\n\n%%R\n# Stack rasters\npredictors_r &lt;- rast(c(predictors,distancia))\ncapas &lt;- c(\"LST_Day_minimum\", \n           \"LST_Day_maximum\", \n           \"LST_Day_average\",\n           \"ndvi_maximum\",\n           \"ndvi_minimum\", \n           \"distancia_agua\",\n           \"distancia_caminos\")\nnames(predictors_r) &lt;- capas"
  },
  {
    "objectID": "bla.html",
    "href": "bla.html",
    "title": "how_to_run_this_course",
    "section": "",
    "text": "Hay múltiples opciones para ejecutar este curso: * Instalación local (preparar antes del taller) * Máquina Virtual OSGeoLive (preparación antes del taller) * Entorno en la nube (WholeTale o Google Colab)\n\n\nSi bien la mayor parte del material del taller se puede ejecutar teóricamente en todas las plataformas, algunas partes requieren herramientas que suelen ser más difíciles de configurar en Windows. Por lo tanto, recomendamos ejecutar este curso localmente en entornos Linux/Unix.\n\n\n\nGRASS GIS &gt;= v8.2.0\n\naddons\n\nPython &gt;= 3.7 con los siguientes paquetes:\n\njupyterlab, scipy, pandas, tqdm, folium\n\nR &gt;= 4.2 con los siguientes paquetes:\n\nrgrass, sf, terra, raster, mapview, SDMtune\n\n\nUna vez instalado el software, ejecutar:\ngit clone https://github.com/veroandreo/curso-grass-gis\ncd curso-grass-gis\njupyter lab\n\n\n\nUsuarios de Ubuntu: usar el PPA inestable de ubuntugis para obtener la última versión de GRASS GIS:\nsudo add-apt-repository ppa:ubuntugis/ubuntugis-unstable\nsudo apt update\nsudo apt install grass grass-dev\nDependiendo de la versión de GRASS, la instalación de complementos puede requerir el paquete subversion. Los complementos se pueden instalar con:\ngrass --tmp-location XY --exec g.extension r.futures\ngrass --tmp-location XY --exec g.extension r.mapcalc.tiled\n\n\n\n\nOSGeoLive nos permite probar una amplia variedad de otros programas geoespaciales de código abierto que pueden resultar útiles. Para configurar la VM, seguir estas instrucciones. Tener en cuenta que para configurar OSGeoLive es necesario descargar un archivo grande, lo que puede tardar un poco dependiendo de la conexión disponible, así que se recomienda planificar de antemano. No habrá sesión de instalación del software dentro del curso. Al configurar la VM, se deben especificar los recursos que la VM puede usar. Se recomienda usar al menos 4 cpus y, en general, más recursos darán como resultado una mejor experiencia.\nUna vez que OSGeoLive esté configurado, seguir estos pasos adicionales para prepararse para el curso:\n# install additional packages\nsudo apt -y install subversion parallel python-is-python3\n# install addons\ngrass --tmp-location XY --exec g.extension r.futures\ngrass --tmp-location XY --exec g.extension r.mapcalc.tiled\n# download course material\ngit clone https://github.com/veroandreo/curso-grass-gis\ncd curso-grass-gis\njupyter lab\n\n\n\nEl taller se puede realizar en línea en WholeTale y Google Colab. Esta es una forma conveniente, ya que no se necesita instalación; sin embargo, existen limitaciones de recursos; por ejemplo, Colab nos proporcionará solo 2 cpus.\n\n\nWholeTale es una plataforma web escalable, de código abierto para investigaciones reproducibles.\n\nGo to https://dashboard.wholetale.org/run/64c96871e6fabc2991d17f94\nLog in (there are different options)\nRun Tale (blue button at the top right)\nConfirm Copy and Run Tale\nIf it keeps showing Importing… try to reload\nRun Tale\n\n\n\n\nIn Colab: 1. File-&gt; Open notebook 2. Select Github 3. Paste https://github.com/ncsu-geoforall-lab/opengeohub-2023/blob/main/colab_notebook.ipynb\nEn Google Colab no tenemos preinstalado el software necesario, así que continúa y ejecuta la primera parte para instalarlo."
  },
  {
    "objectID": "bla.html#cómo-ejecutar-este-curso",
    "href": "bla.html#cómo-ejecutar-este-curso",
    "title": "how_to_run_this_course",
    "section": "",
    "text": "Hay múltiples opciones para ejecutar este curso: * Instalación local (preparar antes del taller) * Máquina Virtual OSGeoLive (preparación antes del taller) * Entorno en la nube (WholeTale o Google Colab)\n\n\nSi bien la mayor parte del material del taller se puede ejecutar teóricamente en todas las plataformas, algunas partes requieren herramientas que suelen ser más difíciles de configurar en Windows. Por lo tanto, recomendamos ejecutar este curso localmente en entornos Linux/Unix.\n\n\n\nGRASS GIS &gt;= v8.2.0\n\naddons\n\nPython &gt;= 3.7 con los siguientes paquetes:\n\njupyterlab, scipy, pandas, tqdm, folium\n\nR &gt;= 4.2 con los siguientes paquetes:\n\nrgrass, sf, terra, raster, mapview, SDMtune\n\n\nUna vez instalado el software, ejecutar:\ngit clone https://github.com/veroandreo/curso-grass-gis\ncd curso-grass-gis\njupyter lab\n\n\n\nUsuarios de Ubuntu: usar el PPA inestable de ubuntugis para obtener la última versión de GRASS GIS:\nsudo add-apt-repository ppa:ubuntugis/ubuntugis-unstable\nsudo apt update\nsudo apt install grass grass-dev\nDependiendo de la versión de GRASS, la instalación de complementos puede requerir el paquete subversion. Los complementos se pueden instalar con:\ngrass --tmp-location XY --exec g.extension r.futures\ngrass --tmp-location XY --exec g.extension r.mapcalc.tiled\n\n\n\n\nOSGeoLive nos permite probar una amplia variedad de otros programas geoespaciales de código abierto que pueden resultar útiles. Para configurar la VM, seguir estas instrucciones. Tener en cuenta que para configurar OSGeoLive es necesario descargar un archivo grande, lo que puede tardar un poco dependiendo de la conexión disponible, así que se recomienda planificar de antemano. No habrá sesión de instalación del software dentro del curso. Al configurar la VM, se deben especificar los recursos que la VM puede usar. Se recomienda usar al menos 4 cpus y, en general, más recursos darán como resultado una mejor experiencia.\nUna vez que OSGeoLive esté configurado, seguir estos pasos adicionales para prepararse para el curso:\n# install additional packages\nsudo apt -y install subversion parallel python-is-python3\n# install addons\ngrass --tmp-location XY --exec g.extension r.futures\ngrass --tmp-location XY --exec g.extension r.mapcalc.tiled\n# download course material\ngit clone https://github.com/veroandreo/curso-grass-gis\ncd curso-grass-gis\njupyter lab\n\n\n\nEl taller se puede realizar en línea en WholeTale y Google Colab. Esta es una forma conveniente, ya que no se necesita instalación; sin embargo, existen limitaciones de recursos; por ejemplo, Colab nos proporcionará solo 2 cpus.\n\n\nWholeTale es una plataforma web escalable, de código abierto para investigaciones reproducibles.\n\nGo to https://dashboard.wholetale.org/run/64c96871e6fabc2991d17f94\nLog in (there are different options)\nRun Tale (blue button at the top right)\nConfirm Copy and Run Tale\nIf it keeps showing Importing… try to reload\nRun Tale\n\n\n\n\nIn Colab: 1. File-&gt; Open notebook 2. Select Github 3. Paste https://github.com/ncsu-geoforall-lab/opengeohub-2023/blob/main/colab_notebook.ipynb\nEn Google Colab no tenemos preinstalado el software necesario, así que continúa y ejecuta la primera parte para instalarlo."
  },
  {
    "objectID": "unidad_5/grass_and_r_sdm.html#cómo-usamos-rgrass",
    "href": "unidad_5/grass_and_r_sdm.html#cómo-usamos-rgrass",
    "title": "R y GRASS: Modelado de nicho",
    "section": "Cómo usamos rgrass?",
    "text": "Cómo usamos rgrass?\nGRASS GIS y R se pueden utilizar juntos de dos maneras:\nA. Usar R dentro de una sesión de GRASS GIS, es decir, iniciar R (o RStudio) desde una sesión de GRASS\n\nescribimos R o rstudio & en la terminal GRASS GIS o en la pestaña Consola de la interfaz gráfica\nuna vez en R (o RStudio) cargamos el paquete rgrass (previo haberlo instalado)\nusamos read_VECT(), read_RAST() para leer datos de GRASS en R\naccedemos a los módulos y la base de datos de GRASS GIS a través de execGRASS()\nescribimos datos resultantes en la base de datos de GRASS con write_VECT() y write_RAST()\n\n\n\n\n\n\n\n\n\n\n\n\n\nB. Iniciar y usar GRASS GIS dentro de una sesión de R, es decir, nos conectamos a la base de datos de GRASS GIS desde R (o RStudio).\n\nPrimero cargamos el paquete rgrass\nNecesitamos iniciar GRASS GIS con initGRASS() desde R y para ello, necesitamos especificar el ejecutable de GRASS y las ubicaciones de la base de datos, el proyecto (location) y mapset\nAccedemos a los módulos GRASS GIS a través de execGRASS()\nusamos read_VECT(), read_RAST(), write_VECT() y write_RAST() para leer datos desde y hacia la base de datos GRASS.\n\n\n\n\n\n\n\n\n\n\n\n\nNota\n\n\n\nOriginalmente, rgrass estaba destinado a aplicar funciones de GRASS en datos fuera de la base de datos de GRASS; de ahí que algunos prefieran crear proyectos (i.e., locations) desechables o temporarios. Por ejemplo:\nlibrary(terra)\n\nf &lt;- system.file(\"ex/elev.tif\", package=\"terra\")\nr &lt;- rast(f)\n\nlibrary(rgrass)\ninitGRASS(home=tempdir(), SG=r, override=TRUE)"
  },
  {
    "objectID": "unidad_5/grass_and_r_sdm.html#curvas-de-respuesta",
    "href": "unidad_5/grass_and_r_sdm.html#curvas-de-respuesta",
    "title": "R y GRASS: Modelado de nicho",
    "section": "Curvas de respuesta",
    "text": "Curvas de respuesta\nLas curvas de respuesta nos dan una idea de la relación entre las variables predictoras y la probabilidad de ocurrencia del evento de interés.\n\n%%R\nmy_rp &lt;- function(i){\n  plotResponse(reduc_var_sp, i)\n}\n\nplotlist &lt;- lapply(retained_varnames, my_rp)\nlabels &lt;- LETTERS[1:length(retained_varnames)]\nggpubr::ggarrange(plotlist = plotlist, labels = labels)\n\nCerramos el mapset y terminamos :)\n\n%%R\n# close the mapset\nunlink_.gislock()"
  },
  {
    "objectID": "about.html#fa-solid-dna-sobre-la-disertante",
    "href": "about.html#fa-solid-dna-sobre-la-disertante",
    "title": "Verónica Andreo",
    "section": "",
    "text": "Verónica Andreo es Licenciada y Doctora en Ciencias Biológicas segresada de la Universidad Nacional de Río Cuarto (UNRC). Además, cuenta con una maestría en Aplicaciones de la Información Espacial de la Universidad Nacional de Córdoba (UNC). Desde 2018, se desempeña como investigadora de CONICET y docente de postgrado en el Instituto Gulich dependiente de la (CONAE) y la UNC.\nSu investigación esta enfocada en las aplicaciones del sensado remoto y los sistemas de información geográfica (SIG) a problemas relacionados con la Salud Pública y los reservorios y vectores de enfermedades. Su principal interés son los determinantes ambientales de la distribución y riesgo de las enfermedades vectoriales y zoonóticas, especialmente aquellos determinantes que pueden derivarse del análisis de imágenes satelitales, series de tiempo de productos satelitales y aprendizaje automático.\nVero forma parte del GRASS GIS Development team y desempeña el rol de chair del proyecto desde Febrero 2021. Además, es Charter member de OSGeo y promotora del software libre y de código abierto en general, y de FOSS4G en especial. Fue coordinadora del Comité de Programa de la FOSS4G 2021 que se realizó en Argentina. Entre otras cosas, ha sido voluntaria como mentora para GRASS GIS en el concurso Google Code-In introduciendo a estudiantes de secundaria en el mundo del software de código abierto. También dicta cursos y talleres introductorios y avanzados sobre los módulos temporales de GRASS GIS y sus aplicaciones."
  },
  {
    "objectID": "about.html#fa-solid-heart-intereses",
    "href": "about.html#fa-solid-heart-intereses",
    "title": "Verónica Andreo",
    "section": "",
    "text": "Remote sensing time series\nImage analysis\nGIS\nSDM\nVector-borne diseases\nFree and Open Source Software"
  },
  {
    "objectID": "about.html#fa-solid-graduation-cap-educación",
    "href": "about.html#fa-solid-graduation-cap-educación",
    "title": "Verónica Andreo",
    "section": "",
    "text": "PhD in Biological Sciences. National University of Río Cuarto. 2012.\nMSc in Spatial Applications for Early Warning and Response to Emergencies. National University of Córdoba. 2015.\nBiologist. National University of Río Cuarto. 2005."
  },
  {
    "objectID": "unidad_1/explore_grass_gui.html#contenidos",
    "href": "unidad_1/explore_grass_gui.html#contenidos",
    "title": "Explorando la GUI de GRASS GIS",
    "section": "Contenidos",
    "text": "Contenidos\n\nEstructura de la base de datos GRASS GIS\nDatos de muestra: North Carolina sample location\nIniciamos GRASS y exploramos su interfaz gráfica\nAbrir mapas raster y vectoriales\nConsultas sobre mapas raster y vectoriales\nVisualización 3D\nVisualización de mapas base (WMS)\nComposición cartográfica"
  },
  {
    "objectID": "unidad_1/explore_grass_gui.html#datos-de-muestra",
    "href": "unidad_1/explore_grass_gui.html#datos-de-muestra",
    "title": "Explorando la GUI de GRASS GIS",
    "section": "Datos de muestra:",
    "text": "Datos de muestra:\n\nNorth Carolina sample location\n\nNorth Carolina full\nCrear un directorio en $HOME (o dentro de Documentos) con el nombre grassdata\nDescomprimir el archivo nc_spm_08_grass7.zip dentro de grassdata\n\nUsuarios Windows: la descompresión crea un nivel extra de subdirectorios"
  },
  {
    "objectID": "unidad_1/explore_grass_gui.html#iniciamos-grass-gis",
    "href": "unidad_1/explore_grass_gui.html#iniciamos-grass-gis",
    "title": "Explorando la GUI de GRASS GIS",
    "section": "Iniciamos GRASS GIS",
    "text": "Iniciamos GRASS GIS\n\nClick sobre el ícono de GRASS GIS (MS Windows: Inicio (fa?, arrow-right) OSGeo4W (fa?, arrow-right) GRASS GIS)\nAbrir una terminal o la OSGeo4W Shell y escribir:\n\n# abrir GRASS con el GUI Location wizard\ngrass\n\n# abrir GRASS en modo texto, i.e., solo veremos la terminal\ngrass --text $HOME/grassdata/nc_spm_08_grass7/user1/\nSi no han descargado el location de North Carolina (NC)… no hay problema!\n\n\n\nStartup-download location\n\n\n\n\n\nDownload location\n\n\nGRASS GIS GUI\n\n… y la Terminal\n\n\nObtener información sobre el CRS\n\n o simplemente desde la terminal:\ng.proj -p"
  },
  {
    "objectID": "unidad_1/explore_grass_gui.html#abrir-mapas-raster-y-vectoriales",
    "href": "unidad_1/explore_grass_gui.html#abrir-mapas-raster-y-vectoriales",
    "title": "Explorando la GUI de GRASS GIS",
    "section": "Abrir mapas raster y vectoriales",
    "text": "Abrir mapas raster y vectoriales\nMuchas opciones: - Desde el menú principal: File (fa?, arrow-right) Map display (fa?, arrow-right) Add raster|vector - Desde los íconos de la barra de tareas del Layer Manager - Desde la pestaña Consola del Layer Manager - Doble-click sobre el mapa en la pestaña Datos del Layer Manager - Desde la terminal, llamando monitores wx: d.mon\n\nTarea\nProbar las diferentes maneras de abrir mapas en GRASS GIS"
  },
  {
    "objectID": "unidad_1/explore_grass_gui.html#invocar-comandos-de-grass-gis",
    "href": "unidad_1/explore_grass_gui.html#invocar-comandos-de-grass-gis",
    "title": "Explorando la GUI de GRASS GIS",
    "section": "Invocar comandos de GRASS GIS",
    "text": "Invocar comandos de GRASS GIS\nHay diferentes opciones para invocar comandos o herramientras de GRASS GIS, tanto desde la GUI como desde la terminal.\n\nDesde la interfaz gráfica (GUI):\n\nseleccionando desde el menú principal\ntipeando en la pestaña Console\nexplorando el árbol de herramientas o buscando por nombre o palabra clave en la pestaña Tools\n\nDesde la terminal:\n\ntipear la primera letra o algunas letras del comando + &lt;tab&gt;&lt;tab&gt; para opciones y autocompletado\n\n\n\n\n\n\n\n\nTarea\n\n\n\n\nEjecutar r.univar map=elevation desde la GUI (Raster &gt;&gt; Reports and statistics)\nEjecutar r.univar map=elevation desde la pestaña Console\nEscribir r.un en la terminal + &lt;tab&gt;&lt;tab&gt;, luego &lt;Enter&gt;\nEjecutar r.univar map=elevation en la terminal\n\n\n\nAl ejecutar comandos desde la pestaña Consola en la GUI, tenemos la posibilidad de guardar tanto las salidas de texto de los comandos como la historia de comandos ejecutados desde allí. Esto es equivalente a ejecutar history en la terminal.\n\n\n\n\n\nPor otra parte, al ejecutar los comandos desde la interfaz gráfica de cada uno de ellos podemos ver cómo con cada parámetro que definimos, se va construyendo el comando con la sintaxis de GRASS. Éstos se pueden copiar y pegar en un archivo de texto para después modificar o volver a ejecutar, sin necesidad de hacer todos los clicks."
  },
  {
    "objectID": "unidad_1/explore_grass_gui.html#ayuda",
    "href": "unidad_1/explore_grass_gui.html#ayuda",
    "title": "Explorando la GUI de GRASS GIS",
    "section": "Ayuda",
    "text": "Ayuda\nCómo obtenemos ayuda sobre los módulos de GRASS GIS?\n\nDesde el menú principal Help de la GUI.\nEn la GUI de cada comando.\n&lt;comando&gt; --help en la terminal o en la pestaña Consola para obtener la descripción de parámetros y opciones del módulo.\ng.manual &lt;comando&gt; para acceder al manual online.\n\n\n\n\n\n\n\nTarea\n\n\n\nObtener ayuda para r.grow.distance y v.what.rast. Para qué se usan? Cuáles son sus parámetros y opciones?"
  },
  {
    "objectID": "unidad_1/explore_grass_gui.html#consultas-sobre-mapas-raster",
    "href": "unidad_1/explore_grass_gui.html#consultas-sobre-mapas-raster",
    "title": "Explorando la GUI de GRASS GIS",
    "section": "Consultas sobre mapas raster",
    "text": "Consultas sobre mapas raster\n\n\n\nQuery raster map"
  },
  {
    "objectID": "unidad_1/explore_grass_gui.html#consultas-sobre-mapas-vectoriales",
    "href": "unidad_1/explore_grass_gui.html#consultas-sobre-mapas-vectoriales",
    "title": "Explorando la GUI de GRASS GIS",
    "section": "Consultas sobre mapas vectoriales",
    "text": "Consultas sobre mapas vectoriales"
  },
  {
    "objectID": "unidad_1/explore_grass_gui.html#tablas-de-atributos-de-mapas-vectoriales",
    "href": "unidad_1/explore_grass_gui.html#tablas-de-atributos-de-mapas-vectoriales",
    "title": "Explorando la GUI de GRASS GIS",
    "section": "Tabla(s) de atributos de mapas vectoriales",
    "text": "Tabla(s) de atributos de mapas vectoriales\n\n\n\n\n\n\n\nTarea\n\n\n\n\nAbrir el mapa vectorial zipcode\nCambiar el color de las áreas\nSeleccionar sólo los límites (boundaries) y mostrarlos con otro color\nMostrar sólo los valores de cat entre 1 y 40\nConstruir una consulta SQL con al menos dos condiciones"
  },
  {
    "objectID": "unidad_1/explore_grass_gui.html#explorando-los-datos-de-muestra-y-la-región-computacional",
    "href": "unidad_1/explore_grass_gui.html#explorando-los-datos-de-muestra-y-la-región-computacional",
    "title": "Explorando la GUI de GRASS GIS",
    "section": "Explorando los datos de muestra y la región computacional",
    "text": "Explorando los datos de muestra y la región computacional\n# lista de los mapas raster\ng.list rast\n# lista de los mapas vectoriales\ng.list vect\n# imprimir la región computacional\ng.region -p\n\n\n\n\n\n\nTarea\n\n\n\n\nExplorar la ayuda de r.info y v.info y obtener información básica sobre un mapa raster y un mapa vectorial\nCambiar la región computacional actual a un mapa vectorial e imprimir los nuevos ajustes\nAlinear la resolución de la región computacional a un mapa raster e imprimir los nuevos ajustes para comprobar"
  },
  {
    "objectID": "unidad_1/explore_grass_gui.html#visualización-3d",
    "href": "unidad_1/explore_grass_gui.html#visualización-3d",
    "title": "Explorando la GUI de GRASS GIS",
    "section": "Visualización 3D",
    "text": "Visualización 3D\n\n\n\n\n\n\n\nTarea\n\n\n\n\nCambiar a Vista 3D en la ventana Map Display.\nExplorar las opciones disponibles en la nueva pestaña 3D que aparece en el panel Layers."
  },
  {
    "objectID": "unidad_1/explore_grass_gui.html#visualizar-mapas-base-wms",
    "href": "unidad_1/explore_grass_gui.html#visualizar-mapas-base-wms",
    "title": "Explorando la GUI de GRASS GIS",
    "section": "Visualizar mapas base WMS",
    "text": "Visualizar mapas base WMS\nPaso 1 \nPaso 2"
  },
  {
    "objectID": "unidad_1/explore_grass_gui.html#visualizar-mapas-base-wms-1",
    "href": "unidad_1/explore_grass_gui.html#visualizar-mapas-base-wms-1",
    "title": "Explorando la GUI de GRASS GIS",
    "section": "Visualizar mapas base WMS",
    "text": "Visualizar mapas base WMS\n\n\nTarea\n\nExplorar el área, acercar y alejar\nAbrir y mostrar un mapa vectorial sobre la capa WMS (Sugerencia: Ajustar la opacidad del mapa vectorial)"
  },
  {
    "objectID": "unidad_1/explore_grass_gui.html#composición-cartográfica-en-la-gui",
    "href": "unidad_1/explore_grass_gui.html#composición-cartográfica-en-la-gui",
    "title": "Explorando la GUI de GRASS GIS",
    "section": "Composición cartográfica en la GUI",
    "text": "Composición cartográfica en la GUI\n\n\n\n\n\n\nTarea\n\n\n\n\nDesplegar los mapas elevation y roadsmajor.\nSuperponer una grilla.\nAgregar labels a los caminos (Sugerencia: botón derecho sobre el nombre del mapa en el Layer Manager).\nAgregar las leyendas para el mapa raster y vectorial.\nAgregar barra de escala.\nAgregar símbolo indicando el Norte.\nAgregar título al mapa.\nExportar el resultado en formato png."
  },
  {
    "objectID": "unidad_1/functions_in_grass.html",
    "href": "unidad_1/functions_in_grass.html",
    "title": "Funciones de GRASS GIS",
    "section": "",
    "text": "Interoperabilidad\nProcesamiento de datos raster\nProcesamiento de datos satelitales\nProcesamiento de datos vectoriales\nManejo de bases de datos\nProcesamiento de datos temporales\nModelador gráfico\nVisualización"
  },
  {
    "objectID": "unidad_1/functions_in_grass.html#contenidos",
    "href": "unidad_1/functions_in_grass.html#contenidos",
    "title": "Funciones de GRASS GIS",
    "section": "",
    "text": "Interoperabilidad\nProcesamiento de datos raster\nProcesamiento de datos satelitales\nProcesamiento de datos vectoriales\nManejo de bases de datos\nProcesamiento de datos temporales\nModelador gráfico\nVisualización"
  },
  {
    "objectID": "unidad_1/functions_in_grass.html#interoperabilidad",
    "href": "unidad_1/functions_in_grass.html#interoperabilidad",
    "title": "Funciones de GRASS GIS",
    "section": "Interoperabilidad",
    "text": "Interoperabilidad"
  },
  {
    "objectID": "unidad_1/functions_in_grass.html#importar-y-exportar-mapas-raster",
    "href": "unidad_1/functions_in_grass.html#importar-y-exportar-mapas-raster",
    "title": "Funciones de GRASS GIS",
    "section": "Importar y exportar mapas raster",
    "text": "Importar y exportar mapas raster\n\n\n\n\n\n\n\nGRASS se apoya en GDAL para importar y exportar mapas raster"
  },
  {
    "objectID": "unidad_1/functions_in_grass.html#importar-y-exportar-mapas-vectoriales",
    "href": "unidad_1/functions_in_grass.html#importar-y-exportar-mapas-vectoriales",
    "title": "Funciones de GRASS GIS",
    "section": "Importar y exportar mapas vectoriales",
    "text": "Importar y exportar mapas vectoriales\n\n\n\n\n\n\n\n\n\nGRASS se apoya en OGR para importar y exportar datos vectoriales"
  },
  {
    "objectID": "unidad_1/functions_in_grass.html#procesamiento-de-datos-raster",
    "href": "unidad_1/functions_in_grass.html#procesamiento-de-datos-raster",
    "title": "Funciones de GRASS GIS",
    "section": "Procesamiento de datos raster",
    "text": "Procesamiento de datos raster\n\n\n\n\n\nDatos raster: DEM, cobertura, clima, etc.\nImágenes satelitales: Landsat, Sentinel, MODIS, SPOT, QuickBird, etc.\n\n\n\nRaster processing manual\n\n\nRemuestreo\n\nr.resamp.interp: Remuestrea el mapa raster a una cuadrícula más fina usando diferentes métodos de interpolación: vecino más cercano, bilinear, bicúbico (downscaling)\nr.resamp.stats: Remuestrea el mapa raster a una cuadrícula más gruesa utilizando agregación (upscaling)\n\n\n\n\n\n\n\n\n\n\n\nSuperposición de mapas raster\n\n\n\n\n\n\n\n\nr.series: Permite agregar una lista de mapas con diferentes métodos como promedio, mínimo, máximo, etc.\nr.patch: Crea un mapa raster utilizando los valores de las categorías de uno (o más) mapa(s) para rellenar las áreas “sin datos” en otro mapa\n\n\n\n\nModelado hidrológico\n\n\n\n\n… además de muchos otros addons, por ejemplo:\n\n\n\n\n\n\n\nJasiewicz y Metz (2011)\n\n\n\n\nAnálisis del terreno\n\n\n\n\n\nSalida de r.geomorphon\n\n\n\n\n\nAnálisis de paisaje\n\n\n\n\n\nr.pi.searchtime on West African rainforest fragments\n\n\n… varios add-ons para análisis de parches\n\n\n\n\nWegmann et al. (2018)"
  },
  {
    "objectID": "unidad_1/functions_in_grass.html#procesamiento-de-datos-satelitales",
    "href": "unidad_1/functions_in_grass.html#procesamiento-de-datos-satelitales",
    "title": "Funciones de GRASS GIS",
    "section": "Procesamiento de datos satelitales",
    "text": "Procesamiento de datos satelitales\n\n\nMenú Imagery\n\n\n\n\n\nImage processing manual\n\n\nAdministrar colores y visualización\n\n\n\n\n\n\n\n\n\n\nTransformaciones\n\n\n\n\n\ni.pca: Análisis de componentes principales\ni.fft: Transformada rápida de Fourier\ni.pansharpen: Algoritmos de fusión de imágenes para mejorar la resolución de los canales multiespectrales con una banda pancromática de alta resolución\n\n\n\n\n\n\nClasificación\n\n\n\nMétodos supervisados y no supervisados, ver la wiki de Image classification para más detalles)\n\n\nr.learn.ml: Clasificación supervisada y regresión con Machine Learning\nr.fuzzy.system: Sistema de clasificación autónomo de lógica difusa\ni.ann.maskrcnn: Clasificación supervisada con redes neuronales artificiales\ni.object.activelearning: Aprendizaje activo para la clasificación de objetos raster\n\n\n\n\n\n\nSegmentación y OBIA\n\n\nClasificación basada en objetos\n\n\n\ni.segment: Identifica segmentos (objetos) a partir de datos de imágenes\ni.segment.hierarchical: Segmentación jerárquica\ni.segment.stats: Calcula estadísticas para describir segmentos u objetos\ni.segment.uspo: Optimización no supervisada de parámetros de segmentación\ni.superpixels.slic: Realiza la segmentación de imágenes mediante el método SLIC\n\n\n\n\n\n\nHerramientas genéricas y para sensores específicos\n\n\n\n\nBanda 2 de Sentinel-2A después de i.atcorr\n\n\n\n\n… además de diversas extensiones para MODIS, Sentinel 2, Landsat, SRTM, GPM, etc.\n\n\n\n\nProductos derivados de sensado remoto\n\n\n\n\n\n\ni.wi: Calcula diferentes tipos de índices de agua\ni.lswt: Calcula la temperatura de la superficie de los lagos a partir de la temperatura de brillo\ni.landsat8.swlst: Algoritmo split-window para estimar LST a partir de datos Landsat 8 OLI/TIRS\ni.rh: humedad relativa, vapor de agua\ni.water: Detección de agua a partir de índices derivados de datos satelitales"
  },
  {
    "objectID": "unidad_1/functions_in_grass.html#procesamiento-de-datos-raster-3d",
    "href": "unidad_1/functions_in_grass.html#procesamiento-de-datos-raster-3d",
    "title": "Funciones de GRASS GIS",
    "section": "Procesamiento de datos raster 3D",
    "text": "Procesamiento de datos raster 3D\n\n\nMenú raster 3D\n\n\nSistema de coordenadas raster 3D y su disposición interna\n\n\n\n\n3D raster processing manual"
  },
  {
    "objectID": "unidad_1/functions_in_grass.html#procesamiento-de-datos-vectoriales",
    "href": "unidad_1/functions_in_grass.html#procesamiento-de-datos-vectoriales",
    "title": "Funciones de GRASS GIS",
    "section": "Procesamiento de datos vectoriales",
    "text": "Procesamiento de datos vectoriales\n\n\nMenú Vector\n\n\n\nFormatos vectoriales topológicos en GRASS GIS\n\n\n\nVector processing manual\n\n\n\nMantenimiento de la topología\n\n\n\n\nLimpieza de errores de topología en mapa vectorial\n\n\nSuavizado. Ver también la wiki de v.generalize\n\n\n\n\n\nSelección y superposición\n\n\n\n\n\n\nOperador TOUCHES\n\nOperador NOT\n\n\n\n\n\n\nAnálisis de redes\n\n\n\n\n\n\n\n\n\n\nReportes, estadísticas y actualización de atributos"
  },
  {
    "objectID": "unidad_1/functions_in_grass.html#manejo-de-bases-de-datos",
    "href": "unidad_1/functions_in_grass.html#manejo-de-bases-de-datos",
    "title": "Funciones de GRASS GIS",
    "section": "Manejo de bases de datos",
    "text": "Manejo de bases de datos\n\n\nMenú Database"
  },
  {
    "objectID": "unidad_1/functions_in_grass.html#procesamiento-de-datos-temporales",
    "href": "unidad_1/functions_in_grass.html#procesamiento-de-datos-temporales",
    "title": "Funciones de GRASS GIS",
    "section": "Procesamiento de datos temporales",
    "text": "Procesamiento de datos temporales\nMenú Temporal\n\n\n\n\n\nimportar/exportar\ntopología temporal\nagregación\nacumulación\nálgebra temporal\ninterpolación"
  },
  {
    "objectID": "unidad_1/functions_in_grass.html#modelador-gráfico",
    "href": "unidad_1/functions_in_grass.html#modelador-gráfico",
    "title": "Funciones de GRASS GIS",
    "section": "Modelador gráfico",
    "text": "Modelador gráfico\n\n\n\n\n\ng.gui.gmodeler"
  },
  {
    "objectID": "unidad_1/functions_in_grass.html#visualización-en-la-gui",
    "href": "unidad_1/functions_in_grass.html#visualización-en-la-gui",
    "title": "Funciones de GRASS GIS",
    "section": "Visualización en la GUI",
    "text": "Visualización en la GUI\n\n\n\nMap display: vista 3D\n\n\n\n\n\n\nMonitores wx\nEn la terminal:\n\n\n\nLos monitores wx tienen los mismos botones que el Map Display en la GUI\n\n\n\n\n\n\n\nMap-swipe\n\n\ng.gui.mapswipe\n\n\n\n\nHerramienta de animación\n\n\ng.gui.animation\n\n\n\n\nCompositor cartográfico\n\n\ng.gui.psmap\n\n\nExportar como .ps .eps or .pdf\n\n\n\n\nArchivo .psmap para automatizar la composición cartográfica\n\n# timestamp: 2018-09-19 18:10\n# location: nc_spm_08_grass7\n# mapset: user1\n# page orientation: Portrait\n# g.region raster=elevation@PERMANENT nsres=10.75697211 ewres=10.75268817\n\nmaploc 0.450 0.666  4.624 4.174\nborder n\n\npaper\n    width 7.48031496063\n    height 5.51181102362\n    left 0.196850393701\n    right 0.196850393701\n    bottom 0.393700787402\n    top 0.393700787402\n    end\n\nraster elevation@PERMANENT\n\nvareas lakes@PERMANENT\n    layer 1\n    masked n\n    color 136:138:133\n    width 1.0\n    fcolor 114:159:207\n    label Lakes\n    lpos 1\n    end\nvlines roadsmajor@PERMANENT\n    type line\n    layer 1\n    masked n\n    color 46:52:54\n    width 1.5\n    style solid\n    linecap butt\n    label Roads\n    lpos 2\n    end\ncolortable y\n    raster elevation@PERMANENT\n    where 5.245 0.735\n    discrete n\n    tickbar n\n    font Helvetica\n    fontsize 10\n    color black\n    end\nvlegend\n    where 5.234 2.249\n    font Helvetica\n    fontsize 10\n    width 0.4\n    cols 1\n    border none\n    end\nscalebar s\n    where 6.040 4.591\n    length 5000.0\n    units auto\n    height 0.1\n    segment 5\n    numbers 1\n    fontsize 8\n    background y\n    end\nend"
  },
  {
    "objectID": "unidad_1/functions_in_grass.html#addons",
    "href": "unidad_1/functions_in_grass.html#addons",
    "title": "Funciones de GRASS GIS",
    "section": "Addons",
    "text": "Addons\n\ni.modis: Herramientas para la descarga y el procesamiento de productos MODIS utilizando pyModis\ni.sentinel: Herramientas para la descarga y el procesamiento de los productos de Copernicus Sentinel\ni.landsat: Herramientas para la descarga y el procesamiento de datos Landsat\nr.hants: Aproxima una serie temporal periódica con armónicos\nr.bioclim: Calcula índices bioclimáticos\n… y otros 300+ en el repo oficial!!\n\nhttps://grass.osgeo.org/grass-stable/manuals/addons/"
  },
  {
    "objectID": "unidad_1/functions_in_grass.html#referencias",
    "href": "unidad_1/functions_in_grass.html#referencias",
    "title": "Funciones de GRASS GIS",
    "section": "Referencias",
    "text": "Referencias\n\n\nJasiewicz, J., y Metz, M. (2011), «A new GRASS GIS toolkit for Hortonian analysis of drainage networks», Computers & Geosciences, 37, 1162-1173. https://doi.org/10.1016/j.cageo.2011.03.003.\n\n\nWegmann, M., Leutner, B. F., Metz, M., Neteler, M., Dech, S., y Rocchini, D. (2018), «r.pi: A grass gis package for semi-automatic spatial pattern analysis of remotely sensed land cover data», Methods in Ecology and Evolution, 9, 191-199. https://doi.org/10.1111/2041-210X.12827."
  },
  {
    "objectID": "index.html#agradecimientos",
    "href": "index.html#agradecimientos",
    "title": "Procesamiento y análisis de series temporales con GRASS GIS",
    "section": "Agradecimientos",
    "text": "Agradecimientos\n\nA todos los desarrolladores, usuarios y entusiastas del software libre y de código abierto (FOSS)\nA la NASA y la ESA por poner a disposición del público los datos y productos satelitales\nAl IGN e IDECOR por las capas vectoriales y de cobertura de acceso libre y gratuito"
  },
  {
    "objectID": "unidad_1/data_storage_and_management_in_grass.html#contenidos",
    "href": "unidad_1/data_storage_and_management_in_grass.html#contenidos",
    "title": "Manejo y almacenamiento de datos",
    "section": "Contenidos",
    "text": "Contenidos\n\nEstructura de la base de datos GRASS GIS\nDatos para el ejercicio\nCreación de nuevos locations y mapsets: diferentes opciones\nCambiar de mapset / agregar mapsets\nImportar mapas raster y vectoriales\nRe-proyección de mapas\nExportar mapas raster y vectoriales"
  },
  {
    "objectID": "unidad_1/data_storage_and_management_in_grass.html#datos-para-el-ejercicio",
    "href": "unidad_1/data_storage_and_management_in_grass.html#datos-para-el-ejercicio",
    "title": "Manejo y almacenamiento de datos",
    "section": "Datos para el ejercicio",
    "text": "Datos para el ejercicio\n\nDescargar los rasters y el vector de muestra\nCrear un directorio en $HOME (o Documentos) y llamarlo gisdata\nDescomprimir los archivos descargados dentro de $HOME/gisdata"
  },
  {
    "objectID": "unidad_1/data_storage_and_management_in_grass.html#creación-de-un-nuevo-location",
    "href": "unidad_1/data_storage_and_management_in_grass.html#creación-de-un-nuevo-location",
    "title": "Manejo y almacenamiento de datos",
    "section": "Creación de un nuevo Location",
    "text": "Creación de un nuevo Location\n\nDesde la GUI\n\nbotón “Nuevo” en el Location wizard al inicio\ndesde dentro de GRASS: Settings &gt; GRASS working environment &gt; Create new location\n\nDesde la terminal\n\ncon la opción -c en el comando de inicio grass + la ruta al nuevo location y un archivo geo-referenciado o un código EPSG\n\n\n\n\nCreando un nuevo Location desde la GUI\n\nCrear un location Lat-Long usando el código EPSG\n\n\n\nCreando un nuevo Location desde la línea de comandos\n# Crear un nuevo location con EPSG:4326\ngrass -c EPSG:4326 $HOME/grassdata/mylocation\n\n# Crear un nuevo location basado en un Shapefile \ngrass -c myvector.shp $HOME/grassdata/mylocation\n\n# Crear un nuevo location basado en un GeoTIFF\ngrass -c myraster.tif $HOME/grassdata/mylocation\nEsto puede ejecutarse desde un location diferente; GRASS cambiará al nuevo location creado.\n\n\n\nCreando un nuevo mapset\n\nDesde la GUI\n\nbotón “Nuevo” en el Mapset wizard al inicio\ndesde dentro de GRASS: Settings &gt; GRASS working environment &gt; Create new mapset\n\nDesde la terminal\n\ncon el comando g.mapset\n\n\n\n\n\nCreando un nuevo mapset desde la GUI\nUsando el botón “Nuevo”\n\nDesde dentro de GRASS\n\n\n\n\nCreando un nuevo mapset desde la línea de comandos\n\nCrear un nuevo mapset desde dentro de GRASS:\n\ng.mapset -c mapset=curso\n\n\n(fa?, tasks) Tarea\n\nCrear un nuevo location con código EPSG:4326 y llamarlo latlong\nCrear un nuevo mapset llamado curso dentro del location latlong\n\n\nDesde la terminal son sólo dos líneas!"
  },
  {
    "objectID": "unidad_1/data_storage_and_management_in_grass.html#eliminar-locations-y-mapsets",
    "href": "unidad_1/data_storage_and_management_in_grass.html#eliminar-locations-y-mapsets",
    "title": "Manejo y almacenamiento de datos",
    "section": "Eliminar Locations y Mapsets",
    "text": "Eliminar Locations y Mapsets\nSimplemente se elimina el directorio o se utiliza el Location wizard del inicio"
  },
  {
    "objectID": "unidad_1/data_storage_and_management_in_grass.html#renombrar-locations-y-mapsets",
    "href": "unidad_1/data_storage_and_management_in_grass.html#renombrar-locations-y-mapsets",
    "title": "Manejo y almacenamiento de datos",
    "section": "Renombrar Locations y Mapsets",
    "text": "Renombrar Locations y Mapsets\nDesde el Location wizard del inicio"
  },
  {
    "objectID": "unidad_1/data_storage_and_management_in_grass.html#cambiar-de-mapset",
    "href": "unidad_1/data_storage_and_management_in_grass.html#cambiar-de-mapset",
    "title": "Manejo y almacenamiento de datos",
    "section": "Cambiar de mapset",
    "text": "Cambiar de mapset\n\nDesde la GUI:\n\n\n\n\n\n\n\n\n\n\n\nDesde la terminal o la Consola:\n\n# imprimir el mapset actual\ng.mapset -p\n\n# cambiar al mapset PERMANENT\ng.mapset mapset=PERMANENT"
  },
  {
    "objectID": "unidad_1/data_storage_and_management_in_grass.html#agregar-mapsets-a-la-lista-de-mapsets-accesibles",
    "href": "unidad_1/data_storage_and_management_in_grass.html#agregar-mapsets-a-la-lista-de-mapsets-accesibles",
    "title": "Manejo y almacenamiento de datos",
    "section": "Agregar mapsets a la lista de mapsets accesibles",
    "text": "Agregar mapsets a la lista de mapsets accesibles\nA veces se requiere leer datos de otro mapset y usarlos para algún procesamiento. Entonces es necesario ver ese mapset desde el mapset actual donde estamos trabajando.\n# imprimir el mapset actual\ng.mapset -p\n# imprimir los mapsets accesibles\ng.mapsets -p\n# agregar *user1* a la lista de mapsets accesibles\ng.mapsets mapset=user1 operation=add\n# corroborar que es visible\ng.mapsets -p\n\n\n\n\n\n\nNota\n\n\n\nEstas operaciones se realizan dentro de un mismo proyecto. No es posible agregar/ver mapas de otros proyectos (locations)."
  },
  {
    "objectID": "unidad_1/data_storage_and_management_in_grass.html#importar-mapas-raster-y-vectoriales",
    "href": "unidad_1/data_storage_and_management_in_grass.html#importar-mapas-raster-y-vectoriales",
    "title": "Manejo y almacenamiento de datos",
    "section": "Importar mapas raster y vectoriales",
    "text": "Importar mapas raster y vectoriales\n\nr.in.gdal: Importa datos raster en GRASS usando la librería GDAL\n\nr.in.gdal input=myraster.tif output=myraster\n\nv.in.ogr: Importa datos vectoriales en GRASS usando la librería OGR.\n\nv.in.ogr input=myvector.shp output=myvector\n\n\n\n\n\n\nImportante\n\n\n\nPara usar estos comandos, los mapas deben tener el mismo sistema de coordenadas que el location al que los queremos importar\n\n\n\n\n\n\n\n\nNota\n\n\n\nCómo obtener los metadatos de cualquier mapa raster?\ngdalinfo &lt;mapname&gt;\n\n\nAlternativamente, podemos usar r.import y v.import que ofrecen re-proyección al vuelo y también, remuestreo y recorte para los datos raster. En este caso, entonces, los mapas raster y vectoriales no necesitan tener el mismo sistema de coordenadas que el proyecto (location) de destino. Veamos dos ejemplos y sigamos las instrucciones que nos muestran.\n\nImportar un mapa raster en el proyecto NC\n\n\n\n\n\n\n\n\n\n\n\nImportar un mapa vectorial en el proyecto NC\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTarea\n\n\n\nImportar los rasters y el vector de muestra provistos dentro del mapset curso que crearon más arriba."
  },
  {
    "objectID": "unidad_1/data_storage_and_management_in_grass.html#importar-mapas-raster-y-vectoriales-1",
    "href": "unidad_1/data_storage_and_management_in_grass.html#importar-mapas-raster-y-vectoriales-1",
    "title": "Manejo y almacenamiento de datos",
    "section": "Importar mapas raster y vectoriales",
    "text": "Importar mapas raster y vectoriales\nAlternativamente, podemos usar:\n\nr.import\nv.import\n\nque ofrecen re-proyección al vuelo y también, remuestreo y recorte para los datos raster\n\nImportar un mapa raster en el Location NC\n\n\n\n\n\n\n\n\n\nImportar un mapa vectorial en el Location NC\n\n\n\n\n\n\n\n\n\n\nimported maps"
  },
  {
    "objectID": "unidad_1/data_storage_and_management_in_grass.html#crear-location-y-mapset-a-partir-de-archivo-con-geo-referencia",
    "href": "unidad_1/data_storage_and_management_in_grass.html#crear-location-y-mapset-a-partir-de-archivo-con-geo-referencia",
    "title": "Manejo y almacenamiento de datos",
    "section": "Crear location y mapset a partir de archivo con geo-referencia",
    "text": "Crear location y mapset a partir de archivo con geo-referencia\n\n\n\n\n\n\n\n\n\nNota\n\n\n\nCómo obtener los metadatos de cualquier mapa raster?\ngdalinfo &lt;mapname&gt;"
  },
  {
    "objectID": "unidad_1/data_storage_and_management_in_grass.html#crear-location-y-mapset-a-partir-de-archivo-con-geo-referencia-1",
    "href": "unidad_1/data_storage_and_management_in_grass.html#crear-location-y-mapset-a-partir-de-archivo-con-geo-referencia-1",
    "title": "Manejo y almacenamiento de datos",
    "section": "Crear location y mapset a partir de archivo con geo-referencia",
    "text": "Crear location y mapset a partir de archivo con geo-referencia"
  },
  {
    "objectID": "unidad_1/data_storage_and_management_in_grass.html#crear-location-y-mapset-a-partir-de-archivo-con-geo-referencia-2",
    "href": "unidad_1/data_storage_and_management_in_grass.html#crear-location-y-mapset-a-partir-de-archivo-con-geo-referencia-2",
    "title": "Manejo y almacenamiento de datos",
    "section": "Crear location y mapset a partir de archivo con geo-referencia",
    "text": "Crear location y mapset a partir de archivo con geo-referencia\n\n\n\n\n\n\n\nNota\n\n\n\nCómo obtener los metadatos de cualquier mapa raster?\ngdalinfo &lt;mapname&gt;"
  },
  {
    "objectID": "unidad_1/data_storage_and_management_in_grass.html#inspeccionar-y-definir-la-región-computacional",
    "href": "unidad_1/data_storage_and_management_in_grass.html#inspeccionar-y-definir-la-región-computacional",
    "title": "Manejo y almacenamiento de datos",
    "section": "Inspeccionar y definir la región computacional",
    "text": "Inspeccionar y definir la región computacional\n# inspeccionar la región\ng.region -p\n# definir la región a un raster\ng.region -p raster=XX"
  },
  {
    "objectID": "unidad_1/data_storage_and_management_in_grass.html#trabajar-sin-importar-los-mapas",
    "href": "unidad_1/data_storage_and_management_in_grass.html#trabajar-sin-importar-los-mapas",
    "title": "Manejo y almacenamiento de datos",
    "section": "Trabajar sin importar los mapas",
    "text": "Trabajar sin importar los mapas\nEn lugar de importar los datos a la base de datos de GRASS, se puede trabajar solamente vinculando los datos. Para ello, usamos los siguientes módulos:\n\nr.external: Vincula datos raster en formatos soportados por GDAL como un pseudo raster de GRASS.\nv.external: Crea un pseudo-vector GRASS vinculando formatos vectoriales soportados por OGR o tablas de PostGIS.\n\n\n\n\n\n\n\nImportante\n\n\n\nNo renombrar, eliminar o mover los archivos vinculados…!"
  },
  {
    "objectID": "unidad_1/data_storage_and_management_in_grass.html#re-proyección-de-mapas",
    "href": "unidad_1/data_storage_and_management_in_grass.html#re-proyección-de-mapas",
    "title": "Manejo y almacenamiento de datos",
    "section": "Re-proyección de mapas",
    "text": "Re-proyección de mapas\nCada location está definida por su sistema de coordenadas de referencia (CRS por su abreviación en Inglés), así que re-proyectar == transferir/transformar mapas entre distintos proyectos.\nPara la re-proyección de rasters se definen extensión y resolución deseadas en el proyecto de destino previo a la re-proyección, mientras que para la re-proyección de vectores se re-proyecta todo el mapa por transformación de coordenadas.\nEn general, el mecanismo es el siguiente: se trabaja desde el proyecto de destino, y desde allí se llama a los mapas en el proyecto de origen.\n\n\n\n\n\n\nTarea\n\n\n\n\nCrear un nuevo proyecto (location) con el nombre UTM18N a partir de una de las bandas de L8 provistas como rasters de muestra e importarla.\nImportar a nc_spm_08_grass7/user1 (con re-proyección al vuelo) la banda de L8 importada al proyecto UTM18N. ¿En qué mapset estaba?\nDefinir (e imprimir) la región computacional al raster importado en ambos proyectos.\n\n\n\nTambién está la opción de copiar y pegar mapas de un proyecto a otro desde el menú contextual de la GUI."
  },
  {
    "objectID": "unidad_1/data_storage_and_management_in_grass.html#re-proyección-de-mapas-1",
    "href": "unidad_1/data_storage_and_management_in_grass.html#re-proyección-de-mapas-1",
    "title": "Manejo y almacenamiento de datos",
    "section": "Re-proyección de mapas",
    "text": "Re-proyección de mapas\n\nRe-proyección de rasters: Se definen extensión y resolución deseadas en el location de destino previo a la re-proyección.\nRe-proyección de vectores: Se re-proyecta todo el mapa vectorial por transformación de coordenadas.\n\n\nMecanismo: Se trabaja desde el location de destino, y desde allí se llama a los mapas en el location de origen\n\n\n\n\n\n\n\nTarea\n\n\n\n\nCrear un nuevo location con el nombre UTM18N a partir de una de las bandas de L8\nCambiarse al location nc_spm_08_grass7 y mapset user1\nImportar (con re-proyección al vuelo) la banda 2 de la escena L8\nDefinir (e imprimir) la región computacional al raster importado"
  },
  {
    "objectID": "unidad_1/data_storage_and_management_in_grass.html#exportar-mapas-raster-y-vectoriales",
    "href": "unidad_1/data_storage_and_management_in_grass.html#exportar-mapas-raster-y-vectoriales",
    "title": "Manejo y almacenamiento de datos",
    "section": "Exportar mapas raster y vectoriales",
    "text": "Exportar mapas raster y vectoriales\nPara exportar mapas desde GRASS GIS utilizamos los comandos r.out.gdal y v.out.ogr que nos permiten exportar a formatos soportados por GDAL/OGR.\n\n\n\n\n\n\nTarea\n\n\n\n\nExplorar r.out.gdal y v.out.ogr y exportar los mapas elevation y roadsmajor.\nAbrir los mapas exportados en QGIS."
  },
  {
    "objectID": "unidad_1/explore_grass_gui.html",
    "href": "unidad_1/explore_grass_gui.html",
    "title": "Explorando la GUI de GRASS GIS",
    "section": "",
    "text": "En ésta primera sesión práctica, vamos a familiarizarnos con las diferentes interfaces de GRASS GIS, especialmente la terminal y la GUI. Vamos a explorar los datos de muestra más clásicos de GRASS GIS y en los que se basan la mayoría de los ejemplos en los manuales: el famoso North Carolina sample project. Así visualizaremos algunos mapas vectoriales y ráster, haremos consultas sobre los mismos y configuraremos la región computacional, entre otras cosas."
  },
  {
    "objectID": "unidad_1/explore_grass_gui.html#obtener-información-sobre-el-crs",
    "href": "unidad_1/explore_grass_gui.html#obtener-información-sobre-el-crs",
    "title": "Explorando la GUI de GRASS GIS",
    "section": "Obtener información sobre el CRS",
    "text": "Obtener información sobre el CRS\n\n… o simplemente desde la terminal:\ng.proj -p"
  },
  {
    "objectID": "unidad_1/explore_grass_gui.html#visualizar-mapas-ráster-y-vectoriales",
    "href": "unidad_1/explore_grass_gui.html#visualizar-mapas-ráster-y-vectoriales",
    "title": "Explorando la GUI de GRASS GIS",
    "section": "Visualizar mapas ráster y vectoriales",
    "text": "Visualizar mapas ráster y vectoriales\nTenemos muchas opciones para visualizar mapas:\n\nDesde el menú principal: File &gt;&gt; Map display &gt;&gt; Add raster|vector (Shift+Ctrl+R ó Shift+Ctrl+V)\nDesde los íconos de la barra de tareas del panel Layers\nDoble-click sobre el mapa en el panel Data Catalog\nDesde la pestaña Consola con los comandos d.vect|rast\nDesde la pestaña Python con AddLayer('map_name')\nDesde la terminal negra llamando monitores wx con d.mon + d.vect|rast\n\n\n\n\n\n\n\nTarea\n\n\n\nProbar las diferentes maneras de visualizar mapas en GRASS GIS y explorar las opciones de zoom al mapa y zoom a la región del menú del panel Map Display."
  },
  {
    "objectID": "unidad_1/explore_grass_gui.html#región-computacional",
    "href": "unidad_1/explore_grass_gui.html#región-computacional",
    "title": "Explorando la GUI de GRASS GIS",
    "section": "Región computacional",
    "text": "Región computacional\nLa región computacional es la configuración de límites del área de análisis y resolución espacial (raster).\n\nImprimamos la region computacional actual:\ng.region -p\n\n\n\n\n\n\nTarea\n\n\n\n\nCambiar la región computacional actual a un mapa vectorial e imprimir los nuevos ajustes.\nAlinear la resolución de la región computacional a un mapa raster e imprimir los nuevos ajustes para comprobar.\nConfiguremos la region computacional al mapa elevation, imprimamos su estadistica univariada, luego cambiemos la region computacional desde el Map Display e imprimimos la estadistica del mapa una vez más… qué notan?"
  },
  {
    "objectID": "unidad_1/explore_grass_gui.html#máscaras",
    "href": "unidad_1/explore_grass_gui.html#máscaras",
    "title": "Explorando la GUI de GRASS GIS",
    "section": "Máscaras",
    "text": "Máscaras"
  },
  {
    "objectID": "unidad_1/explore_grass_gui.html#listar-mapas",
    "href": "unidad_1/explore_grass_gui.html#listar-mapas",
    "title": "Explorando la GUI de GRASS GIS",
    "section": "Listar mapas",
    "text": "Listar mapas\nComo vimos al principio para listar “cosas” dentro de la base de datos de GRASS, usamos g.list. Probemos escribir los siguientes comandos en la Consola de la GUI o en la terminal:\n# lista de los mapas raster\ng.list type=raster\n# lista de los mapas vectoriales\ng.list type=vector\n\n\n\n\n\n\nTarea\n\n\n\nQué otros tipos de elementos podemos listar con g.list?\n\n\nAhora, busquemos mapas raster cuyo nombre comienza con “el”, pero que no sean el mapa “elevation”.\n# listar con un patrón\ng.list type=raster pattern=\"el*\" exclude=elevation\n\n\n\n\n\n\nTarea\n\n\n\nUsen g.list y expresiones regulares para listar únicamente los mapas vectoriales P079214 y P079215"
  },
  {
    "objectID": "unidad_1/explore_grass_gui.html#consultas-sobre-mapas",
    "href": "unidad_1/explore_grass_gui.html#consultas-sobre-mapas",
    "title": "Explorando la GUI de GRASS GIS",
    "section": "Consultas sobre mapas",
    "text": "Consultas sobre mapas"
  },
  {
    "objectID": "unidad_1/data_storage_and_management_in_grass.html",
    "href": "unidad_1/data_storage_and_management_in_grass.html",
    "title": "Manejo y almacenamiento de datos",
    "section": "",
    "text": "En este segundo ejercicio de familiarización con GRASS GIS, vamos a explorar la base de datos de GRASS (o lo que usualmente llamaremos grassdata), ver cómo crear nuevos proyectos y mapsets, cómo cambiar de mapset y leer datos de mapsets diferentes al actual, realizar reproyecciones, e importar y exportar datos."
  },
  {
    "objectID": "unidad_1/data_storage_and_management_in_grass.html#creación-de-un-nuevo-proyecto-location",
    "href": "unidad_1/data_storage_and_management_in_grass.html#creación-de-un-nuevo-proyecto-location",
    "title": "Manejo y almacenamiento de datos",
    "section": "Creación de un nuevo proyecto (location)",
    "text": "Creación de un nuevo proyecto (location)\nTenemos diferentes opciones para crear proyectos (locations) nuevos en GRASS GIS:\n\nDesde la GUI\n\nbotón Crear nuevo location en el menú del panel Data Catalog \ndesde el menú principal: Settings &gt;&gt; GRASS working environment &gt;&gt; Create new location \n\nDesde la terminal o la pestaña Consola\n\ncon la opción -c en el comando de inicio grass + la ruta al nuevo location y un archivo geo-referenciado o un código EPSG\n\n\n# con archivo geo-referenciado\ngrass -c geofile.tif grassdata/UTM20S\n\n# con código epsg\ngrass -c EPSG:32720 grassdata/UTM20S\n\n\n\n\n\n\nTarea\n\n\n\nSiguiendo los pasos ejemplificados en la siguiente figura, vamos a crear un nuevo proyecto “latlong” utilizando el código EPSG 4326. Notar que una vez completado el proceso, GRASS cambia al nuevo proyecto.\n\n\n\n\n\n\n\n\nLos pasos de arriba se podrían haber reemplazado por el siguiente comando desde la terminal o la pestaña Consola dentro del panel lateral:\n# Crear un nuevo location con EPSG:4326\ngrass -c EPSG:4326 $HOME/grassdata/latlong\nCuando creamos un nuevo proyecto de esta manera, GRASS abrirá una nueva sesión en el proyecto creado."
  },
  {
    "objectID": "unidad_1/data_storage_and_management_in_grass.html#eliminar-y-renombrar-proyectos-y-mapsets",
    "href": "unidad_1/data_storage_and_management_in_grass.html#eliminar-y-renombrar-proyectos-y-mapsets",
    "title": "Manejo y almacenamiento de datos",
    "section": "Eliminar y renombrar proyectos y mapsets",
    "text": "Eliminar y renombrar proyectos y mapsets\nSimplemente se elimina el directorio desde el explorador de archivos del sistema o se utiliza el menú contextual. Notar que tiene que estar activado el modo edición y que para eliminar proyectos o mapsets, debemos estar en proyectos y mapsets diferentes de aquellos que deseamos eliminar."
  },
  {
    "objectID": "unidad_1/data_storage_and_management_in_grass.html#crear-un-nuevo-mapset",
    "href": "unidad_1/data_storage_and_management_in_grass.html#crear-un-nuevo-mapset",
    "title": "Manejo y almacenamiento de datos",
    "section": "Crear un nuevo mapset",
    "text": "Crear un nuevo mapset\nTambién existen varias opciones para crear mapsets dentro de los proyectos.\n\nDesde la GUI\n\nbotón Crear nuevo mapset desde el menú del panel Data Catalog \ndesde el menú principal: Settings &gt;&gt; GRASS working environment &gt;&gt; Create new mapset \n\nDesde la terminal o la pestaña Consola\n\ncon el comando g.mapset\n\n\ng.mapset mapset=curso\nGRASS cambia automáticamente al nuevo mapset creado.\n\n\n\n\n\n\nTarea\n\n\n\nCrear un nuevo mapset llamado curso dentro del location latlong con el método que deseen."
  },
  {
    "objectID": "unidad_2/imagery_data_in_grass.html#descargar-e-importar-los-datos-landsat-8",
    "href": "unidad_2/imagery_data_in_grass.html#descargar-e-importar-los-datos-landsat-8",
    "title": "Datos satelitales en GRASS GIS",
    "section": "Descargar e importar los datos Landsat 8",
    "text": "Descargar e importar los datos Landsat 8\nEntre las extensiones disponibles, hay una extensión i.landsat, que nos permite buscar, filtrar, descargar, importar y aplicar bandas de calidad a imágenes Landsat. Para la busqueda y descarga de datos, esta extensión depende de una librería de python denominada landsatxplore.\nDesafortunadamente, landsatxplore fue abandonada por su autor, y es difícil de mantener. Estamos considerando utilizar otras opciones, pero es un WIP. Por este motivo, vamos a instalar la extensión igualmente porque nos sirve para la importación y enmascarado de pixeles según la calidad.\n\n\n\n\n\n\nNota\n\n\n\nVoluntari@s para actualizar y testear los pull request de landsatxplore o actualizar i.landsat.download para que use otro paquete distinto, son mas que bienvenid@s!!\n\n\n\n# install i.landsat toolset\ngs.run_command(\"g.extension\",\n               extension=\"i.landsat\")\n\nLa búsqueda de escenas se basa en la región computacional definida y funcionaría como se detalla a continuación.\n\n# search for Landsat 8 scenes\n# l8_credentials = os.path.join(homedir, \"gisdata\", \"landsat\")\n# gs.run_command(\"i.landsat.download\", \n#               settings=l8_credentials,\n#               dataset=\"landsat_8_c1\",\n#               clouds=\"35\",\n#               start=\"2019-10-27\",\n#               end=\"2020-03-15\",\n#               flags=\"l\")\n\nPor defecto, usando el comando anterior sin la opción l y proveyendo una carpeta de descarga, se descargarían todas las imágenes encontradas anteriormente. Sin embargo, también es posible descargar imágenes seleccionadas via su id.\n\n# download selected scenes\n# gs.run_command(\"i.landsat.download\", \n#               settings=l8_credentials,\n#               id=\"LC82290822020062LGN00,LC82290822020014LGN00\",\n#               output=os.path.join(homedir, \"gisdata\", \"landsat_data\"))\n\nComo el módulo de descarga no está andando y porque la descarga puede tomar mucho tiempo con conexiones lentas, vamos a usar imágenes previamente descargadas. Como primer paso vamos a imprimir todas las bandas presentes dentro de la carpeta landsat_data.\n\n# print all landsat bands within landsat_data folder\n# (1: projection match, 0: projection does not match)\ngs.run_command(\"i.landsat.import\",\n               input=os.path.join(homedir, \"gisdata\", \"landsat_data\"),\n               flags=\"p\")\n\nTambién podemos imprimir sólo las bandas seleccionadas con un patrón.\n\n# print a selection of bands - might be sloooow\ngs.run_command(\"i.landsat.import\",\n               input=os.path.join(homedir, \"gisdata\", \"landsat_data\"), \n               pattern=\"B(2|3|4|5|6|8)\",\n               flags=\"p\")\n\nPara empezar a trabajar con los datos L8, vamos entonces a importar todas las bandas, recortar a la región y reproyectar al vuelo, ya que vimos que su CRS no coincide con el del proyecto donde nos encontramos.\n\n# import all bands, subset to region and reproject\ngs.run_command(\"i.landsat.import\", \n               input=os.path.join(homedir, \"gisdata\", \"landsat_data\"), \n               extent=\"region\",\n               flags=\"r\")\n\nListamos las bandas importadas y revisamos los metadatos de alguna de ellas.\n\n# list raster maps\ngs.list_grouped(type=\"raster\")[\"landsat8\"]\n\n\n# check metadata of some imported bands\ngs.raster_info(map=\"LC08_L1TP_229082_20200114_20200127_01_T1_B4\")"
  },
  {
    "objectID": "unidad_2/imagery_data_in_grass.html#otros-links-con-info-y-ejercicios-de-clasificación-en-grass-gis",
    "href": "unidad_2/imagery_data_in_grass.html#otros-links-con-info-y-ejercicios-de-clasificación-en-grass-gis",
    "title": "Datos satelitales en GRASS GIS",
    "section": "Otros links con info y ejercicios de clasificación en GRASS GIS",
    "text": "Otros links con info y ejercicios de clasificación en GRASS GIS\n\nTopic classification en los manuales de GRASS GIS\nImage classification en la wiki\nEjemplos de clasificación en el curso dictado en Noruega en 2018\nDetección de cambios con Landsat\nTaller GRASS para sensado remoto en FOSS4G 2022"
  },
  {
    "objectID": "unidad_2/imagery_data_in_grass.html#fusión-de-datospansharpening",
    "href": "unidad_2/imagery_data_in_grass.html#fusión-de-datospansharpening",
    "title": "Datos satelitales en GRASS GIS",
    "section": "Fusión de datos/Pansharpening",
    "text": "Fusión de datos/Pansharpening\nVamos a usar la banda pancromática (15 m) para mejorar la definición de las bandas espectrales de 30 m, por medio de: i.fusion.hpf, que aplica un método de adición basado en un filtro de paso alto. Otros métodos de pansharpening están implementados en el módulo i.pansharpen.\nComo primer paso, instalamos la extensión i.fusion.hpf.\n\n# Install the reqquired addon\ngs.run_command(\"g.extension\",\n               extension=\"i.fusion.hpf\")\n\nLuego, como vamos a “mejorar” la resolución espacial de las bandas multiespectrales a 15 m, necesitamos alinear la resolución de la región computacional a la banda PAN.\n\n# Set the region to PAN band (15m)\ngs.run_command(\"g.region\",\n               raster=\"LC08_229082_20200114_SR_B8\",\n               flags=\"p\")\n\n… y ejecutamos la fusión.\n\n# list bands\nms_bands = gs.list_grouped(type=\"raster\", \n                           pattern=\"*_SR_B[1-7]\")[\"landsat8\"]\nms_bands\n\n\n# Apply the fusion based on high pass filter\ngs.run_command(\"i.fusion.hpf\",\n               pan=\"LC08_229082_20200114_SR_B8\", \n               msx=ms_bands,\n               suffix=\"hpf\", \n               center=\"high\", \n               modulation=\"max\", \n               trim=\"0.0\", \n               flags=\"lc\")\n\nFinalmente, listamos los mapas resultantes usando un patrón de búsqueda\n\n# list the fused maps\ngs.list_grouped(type=\"raster\", \n                pattern=\"*.hpf\")[\"landsat8\"]\n\n\n# check info of a pansharpened band\ngs.raster_info(\"LC08_229082_20200114_SR_B4.hpf\")\n\ny visualizamos las diferencias con gj.InteractiveMap.\n\n# display original and fused maps\nhpf_map = gj.InteractiveMap(width = 500, tiles=\"OpenStreetMap\")\nhpf_map.add_raster(\"LC08_229082_20200114_SR_B4\")\nhpf_map.add_raster(\"LC08_229082_20200114_SR_B4.hpf\")\nhpf_map.add_layer_control(position = \"bottomright\")\nhpf_map.show()"
  },
  {
    "objectID": "unidad_2/imagery_data_in_grass.html#índices-de-agua-y-vegetación",
    "href": "unidad_2/imagery_data_in_grass.html#índices-de-agua-y-vegetación",
    "title": "Datos satelitales en GRASS GIS",
    "section": "Índices de agua y vegetación",
    "text": "Índices de agua y vegetación\nEn esta sección vamos a estimar los conocidos índices de vegetación y agua. No obstante, necesitamos primero, establecer la máscara de nubes y sombras de nubes obtenida anteriormente para evitar el cómputo de los índices sobre estas áreas.\n\n# Set the cloud mask to avoid computing over clouds\ngs.run_command(\"r.mask\",\n               raster=\"LC08_229082_20200114_Cloud_Mask\")\n\nCalculamos el NDVI y establecemos la paleta de colores.\n\n# Compute NDVI\nndvi_formula = \"LC08_229082_20200114_NDVI = (LC08_229082_20200114_SR_B5.hpf - LC08_229082_20200114_SR_B4.hpf) / (LC08_229082_20200114_SR_B5.hpf + LC08_229082_20200114_SR_B4.hpf) * 1.0\"\ngs.mapcalc(exp=ndvi_formula)\n\n# Set the color palette\ngs.run_command(\"r.colors\",\n               map=\"LC08_229082_20200114_NDVI\",\n               color=\"ndvi\")\n\nCalculamos el NDWI y establecemos la paleta de colores.\n\n# Compute NDWI\nndwi_formula = \"LC08_229082_20200114_NDWI = (LC08_229082_20200114_SR_B5.hpf - LC08_229082_20200114_SR_B6.hpf) / (LC08_229082_20200114_SR_B5.hpf + LC08_229082_20200114_SR_B6.hpf) * 1.0\"\ngs.mapcalc(exp=ndwi_formula)\n\n# Set the color palette\ngs.run_command(\"r.colors\",\n               map=\"LC08_229082_20200114_NDWI\",\n               color=\"ndwi\")\n\nVisualizamos los mapas resultantes.\n\nndi = gj.InteractiveMap(width=450, use_region=True)\nndi.add_raster(\"LC08_229082_20200114_NDVI\")\nndi.add_raster(\"LC08_229082_20200114_NDWI\")\nndi.add_layer_control(position = \"bottomright\")\nndi.show()\n\n\n\n\n\n\n\nTarea Opcional\n\n\n\nEstimar NDVI y NDWI para la otra escena usando el módulo i.vi."
  },
  {
    "objectID": "unidad_2/imagery_data_in_grass.html#clasificación-no-supervisada",
    "href": "unidad_2/imagery_data_in_grass.html#clasificación-no-supervisada",
    "title": "Datos satelitales en GRASS GIS",
    "section": "Clasificación No Supervisada",
    "text": "Clasificación No Supervisada\nLos pasos para realizar una clasificación no supervisada en GRASS, implican:\n\nAsignar semantic labels a las bandas con r.semantic.label o r.support\nAgrupar las bandas (i.e., hacer un stack): i.group\nGenerar firmas para n número de clases: i.cluster\nClasificar usando las firmas: i.maxlik\n\n\n¿Qué son los semantic labels?\nLos semantic labels son etiquetas que podemos agregar a cualquier mapa ráster y que nos indican qué variable está representada en ese mapa. Estas etiquetas son especialmente relevantes para las imágenes de satélite, ya que nos permiten identificar a qué sensor y banda corresponde el mapa. Son útiles a la hora de trabajar con colecciones de imágenes de satélite y también a la hora de clasificar diferentes escenas.\nPor ejemplo, si generamos firmas espectrales para unas clases usando un determinado conjunto de bandas, estas firmas pueden reutilizarse para clasificar otra escena siempre que las etiquetas semánticas sean las mismas.\n¡Cuidado! Aunque es posible reutilizar las firmas espectrales para cualquier escena con las mismas bandas, los cambios temporales (estaciones, impacto meteorológico) limitan su aplicabilidad sólo a escenas obtenidas más o menos al mismo tiempo.\nProbemos entonces, asignar semantic labels a las bandas de L8 y los índices de vegetación.\n\n# list the bands needed for classification\nbands = gs.list_grouped(type=\"raster\",\n                        pattern=\"*_SR*hpf\")[\"landsat8\"]\nbands\n\n\n# semantic labels list\nlabels = [\"L8_1\", \"L8_2\", \"L8_3\", \"L8_4\", \"L8_5\", \"L8_6\", \"L8_7\"]\n\nPara bandas de satélites como Landsat y Sentinel, usamos el comando r.sematic.label que toma metadatos sobre los labels de i.band.library. Es posible agregar bandas de otros satélites siempre que se siga un determinado formato.\n\n# add semantic labels to bands\ngs.run_command(\"r.semantic.label\",\n               map=bands,\n               semantic_label=labels, \n               operation=\"add\")\n\nPara cualquier otro ráster al que deseemos agregar una etiqueta, usamos r.support que nos permite agregar distintos metadatos a nuestros datos en GRASS.\n\n# add semantic labels to indices\nfor i in [\"NDVI\", \"NDWI\"]:\n    gs.run_command(\"r.support\", \n                   map=f\"LC08_229082_20200114_{i}\",\n                   semantic_label=i)\n\nImprimimos los semantic labels\n\ngs.raster_info(\"LC08_229082_20200114_SR_B7.hpf\")[\"semantic_label\"]\n\nCreamos un grupo de imágenes o stack con las bandas 1 a 7 más el NDVI y el NDWI.\n\n# add ndvi and ndwi to the list of bands\nfor i in [\"NDVI\", \"NDWI\"]:\n    bands.append(f\"LC08_229082_20200114_{i}\")\n\nbands\n\n\n# create an imagery group with the list of bands\ngs.run_command(\"i.group\",\n               group=\"l8\",\n               subgroup=\"l8\",\n               input=bands)\n\n\n# print elements within the group \ngs.run_command(\"i.group\",\n               group=\"l8\",\n               flags=\"l\")\n\nObtenemos estadísticos -firmas- para las n clases de interés con una muestra de pixeles\n\n# statistics for unsupervised classification\ngs.run_command(\"i.cluster\",\n               group=\"l8\",\n               subgroup=\"l8\",\n               sig=\"l8_hpf\",\n               classes=\"7\",\n               separation=\"0.6\")\n\nUsamos las firmas espectrales para realizar la clasificación no supervisada de toda la imagen\n\n# Maximum Likelihood unsupervised classification\ngs.run_command(\"i.maxlik\",\n               group=\"l8\",\n               subgroup=\"l8\",\n               sig=\"l8_hpf\",\n               output=\"l8_hpf_class\",\n               rej=\"l8_hpf_rej\")\n\n\n# Mostrar el mapa clasificado con `InteractiveMap`\nclas = gj.InteractiveMap(width=450, use_region=True)\nclas.add_raster(\"l8_hpf_class\")\nclas.add_layer_control(position = \"bottomright\")\nclas.show()\n\n\n\nInformación derivada adicional\nUsualmente, para realizar clasificaciones, derivamos muchas variables a partir de las bandas de sensores satelitales multiespectrales. Otra información podría obtenerse con los siguientes módulos, entre otros:\n\nmedidas de textura: r.texture,\nmedidas de diversidad: r.diversity,\nestadísticas locales con información de contexto: r.neighbors,\ntransformación tasseled cap: i.tasscap,\netc."
  },
  {
    "objectID": "unidad_2/exercise_sentinel2.html#extensiones-de-grass-para-datos-sentinel",
    "href": "unidad_2/exercise_sentinel2.html#extensiones-de-grass-para-datos-sentinel",
    "title": "Ejercicio: Datos satelitales en GRASS GIS",
    "section": "Extensiones de GRASS para datos Sentinel",
    "text": "Extensiones de GRASS para datos Sentinel\n\ni.sentinel.download: descarga productos Copernicus Sentinel de Copernicus Open Access Hub\ni.sentinel.import: importa datos Sentinel descargados de Copernicus Open Access Hub\ni.sentinel.preproc: importa y realiza corrección atmosférica y topográfica de imágenes S2\ni.sentinel.mask: crea máscaras de nubes y sombras para imágenes S2\ni.sentinel.coverage: comprueba la cobertura de área de las escenas de S1 o S2 seleccionadas\ni.sentinel.parallel.download: descarga imagenes Sentinel en paralelo\n\nPara conectarse al Copernicus Open Access Hub a través de i.sentinel.download, se necesita ser usuario registrado.\nCada participante necesita registrarse y crear el archivo SENTINEL_SETTING.txt en el directorio $HOME/gisdata/ con el siguiente contenido:\nyour_username\nyour_password"
  },
  {
    "objectID": "unidad_2/exercise_sentinel2.html#manos-a-la-obra",
    "href": "unidad_2/exercise_sentinel2.html#manos-a-la-obra",
    "title": "Ejercicio: Datos satelitales en GRASS GIS",
    "section": "Manos a la obra",
    "text": "Manos a la obra\n\nIniciamos GRASS\nIniciar GRASS GIS, crear nuevo mapset y establecer región computacional\n\nimport os\n\n# data directory\nhomedir = \"/content/drive/MyDrive/curso_grass_2023\"\n\n# GRASS GIS database variables\ngrassdata = os.path.join(homedir, \"grassdata\")\nproject = \"posgar2007_4_cba\"\nmapset = \"PERMANENT\"\n\n\nimport subprocess\nimport sys\n\n# Ask GRASS GIS where its Python packages are to be able to start it from the notebook\nsys.path.append(\n    subprocess.check_output([\"grass\", \"--config\", \"python_path\"], text=True).strip()\n)\n\n\n# Importar los paquetes python de GRASS\nimport grass.script as gs\nimport grass.jupyter as gj\n\n# Iniciar GRASS\nsession = gj.init(grassdata, project, mapset)\n\nPara trabajar con los datos de Sentinel 2 en esta sesión, creamos un nuevo mapset y lo llamamos sentinel2.\n\n# Create a new mapset\ngs.run_command(\"g.mapset\",\n               mapset=\"sentinel2\",\n               flags=\"c\")\n\n\n# Check accessible mapsets\ngs.run_command(\"g.mapsets\",\n               flags=\"p\")\n\nAl igual que en la sesión anterior y como haremos cada vez que iniciemos un proyecto, primero definimos la región computacional. En este caso, vamos a usar el radio urbano de Córdoba que extrajimos en la sesión anterior.\n\n# Add mapset landsat8 to the path\ngs.run_command(\"g.mapsets\",\n               mapset=\"landsat8\",\n               operation=\"add\")\n\n\n# List vector maps\ngs.list_grouped(type=\"vector\")\n\n\n# set the computational region to the extent of Cordoba urban area\ngs.run_command(\"g.region\",\n               vector=\"radio_urbano_cba\",\n               flags=\"p\")\n\n\n# display radio_urbano_cba vector\ncba_map = gj.InteractiveMap(width = 500, use_region=True, tiles=\"OpenStreetMap\")\ncba_map.add_vector(\"radio_urbano_cba\")\ncba_map.add_layer_control(position = \"bottomright\")\ncba_map.show()\n\n\n\nBúsqueda y descarga de datos S2\nInstalamos la caja de herramientas i.sentinel que consta de varios módulos que facilitan la búsqueda, filtrado, descarga, importación y pre-procesado de datos Sentinel, especialmente Sentinel 2, desde una sesión de GRASS GIS. Ver i.sentinel y los links de cada módulo para más detalles.\n\n# install extension - run only once\ngs.run_command(\"g.extension\", \n               extension=\"i.sentinel\")\n\nUsamos el módulo i.sentinel.download que internamente utiliza la librería sentinelsat para buscar y filtrar escenas que contengan la región definida a partir del área urbana de la ciudad de Córdoba. Para esto necesitamos estar registrados en el Copernicus hub y tener nuestras credenciales en un archivo de texto. Para más detalles sobre la función y sus usos, visitar el manual.\n\n# list all available S2 level 2A scenes that meet the criteria specified\ns2_credentials = os.path.join(homedir, \"gisdata\", \"sentinel\")\nstart_date = \"2020-03-01\"\nend_date = \"2020-04-30\"\n\nlist_prod = gs.read_command(\"i.sentinel.download\", \n                            settings=s2_credentials, \n                            start=start_date, \n                            end=end_date, \n                            producttype=\"S2MSI2A\", \n                            clouds=30, \n                            area_relation=\"Contains\", \n                            footprints=\"s2_footprints\", \n                            flags=\"l\")\n\n\n# print plain list\nlist_prod\n\nSi con los criterios de búsqueda se encuentra una larga lista de productos, se puede usar la opción limit para controlar el número de escenas listadas.\n\nimport pandas as pd\nfrom io import StringIO\n\npd.read_csv(StringIO(list_prod), delimiter=\" \", usecols=[0, 1, 2, 4, 5, 6, 7],\n            names=['uuid', 'scene', 'date', 'cloud', 'product', 'size', 'unit'])\n\nMostramos los footprints de las escenas que encontramos según los criterios de búsqueda:\n\n# diplay footprints\ncba_map = gj.InteractiveMap(width = 400, use_region=True, tiles=\"OpenStreetMap\")\ncba_map.add_vector(\"s2_footprints\")\ncba_map.add_layer_control(position = \"bottomright\")\ncba_map.show()\n\nSe observan 2 tipos de footprints: uno cuadrado y otro una pasada inclinada. Encontramos solo estos dos porque establecimos que nuestro bounding box (región computacional) debía estar contenido en la escena.\nEl próximo paso es descargar la escena o las escenas de interés. Para eso usamos nuevamente el módulo i.sentinel.download, pero sin el flag l de listar. Elegimos una imagen con nubes para demostrar posteriormente el uso de otro módulo del set de herramientas.\nComo la descarga puede llevar bastante tiempo, nos saltaremos esta parte y utilizaremos directamente una escena ya descargada. Aún así, dejamos un ejemplo a continuación para referencia futura :)\n\n# download selected scene - esto toma tiempo y las escenas ya estan descargadas en la carpeta`s2_data`\ns2_data = os.path.join(homedir, \"gisdata\", \"s2_data\")\n\n# gs.run_command(\"i.sentinel.download\", \n#               settings=s2_credentials, \n#               uuid=\"9a1ea49c-0561-4aa5-ba7a-dc820dc1a316\", \n#               output=s2_data)\n\n\n\nImportar datos Sentinel 2 a GRASS GIS\n\n\n1. Importar con corrección atmosférica\nSi queremos importar con corrección atmosférica productos de nivel 1C, podemos usar el módulo i.sentinel.preproc. Este módulo utiliza i.atcorr internamente y necesita 2 inputs claves: un valor de aerosol optical depth (AOD) y un mapa de elevación.\n\nPara una descripción más detallada del procedimiento para obtener los valores de AOD y mapas de elevación necesarios para la corrección atmosférica y topográfica, ver aquí.\n\n\n2. Importar sin corrección atmosférica\nUna vez descargada la escena deseada, se procede a importarla al mapset de trabajo. Para ello se usa el comando i.sentinel.import que permite subset, resampleo y reproyección al vuelo. Además, si en nuestra carpeta existen varios zip nos permite seleccionar, por medio de un patrón, cuáles queremos importar; y también, elegir solo las bandas de interés. Entonces, vamos a imprimir información sobre las bandas antes de importarlas.\n\n# print bands info before importing\n# (1 -proj match, 0 -no proj match)\ngs.run_command(\"i.sentinel.import\", \n               input=s2_data, \n               flags=\"p\")\n\n\n# import only bands relevant for RGB, NDVI and NDWI\ngs.run_command(\"i.sentinel.import\", \n               input=s2_data, \n               pattern_file=\"*20200330T141049*\", # in case we have more s2 scenes in the s2_data folder \n               pattern=\"B(02_1|03_1|04_1|08_1|8A_2|11_2|12_2)0m\", # select bands and resolutions\n               extent=\"region\", # subset import to region extent\n               flags=\"rcsj\") # reproject, clouds, shadow, json metadata\n\nListamos los mapas importados:\n\n# list raster maps\nlista = gs.list_grouped(type=\"raster\")['sentinel2']\nlista\n\nA continuación, chequeamos los metadatos de uno de los mapas o bandas. Notar que todos los metadatos que vienen con la imagen original se agregan a la banda correspondiente en el momento de la importación. Esto es gracias al uso del flag j en el comando i.sentinel.import.\n\n# check metadata of some imported bands\ngs.raster_info(map=\"T20JLL_20200330T141049_B03_10m\")\n\nVeamos los semantic labels de las bandas importadas:\n\n# print semantic labels of imported bands\nfor i in gs.list_grouped(type=\"raster\")['sentinel2']:\n    label = gs.raster_info(map=i)['semantic_label']\n    print('Mapa: {}, Semantic label: {}'.format(i,label))\n\n\n\n\nBalance de colores y composiciones\nA continuación, aplicamos la paleta de grises a las bandas R, G y B, mejoramos el contraste y las mostramos usando la clase Map de grass.jupyter.\n\n# apply grey color to RGB bands\ngs.run_command(\"r.colors\", \n               map=lista,\n               color=\"grey\")\n\n\n# perform color auto-balancing for RGB bands\ngs.run_command(\"i.colors.enhance\", \n               red=\"T20JLL_20200330T141049_B04_10m\",\n               green=\"T20JLL_20200330T141049_B03_10m\", \n               blue=\"T20JLL_20200330T141049_B02_10m\",\n               strength=90)\n\n\n# display the enhanced RGB combination\ncba_rgb = gj.Map(use_region=True)\ncba_rgb.d_rgb(red=\"T20JLL_20200330T141049_B04_10m\", \n              green=\"T20JLL_20200330T141049_B03_10m\", \n              blue=\"T20JLL_20200330T141049_B02_10m\")\ncba_rgb.d_grid(size=5000, flags=\"b\")\ncba_rgb.show()\n\n\n\n\n\n\n\nTarea\n\n\n\nRealizar balance de colores y mostrar combinacion falso color NIR-RED-GREEN\n\n\n\n\nIdentificación y enmascarado de nubes\nComo empezaremos a generar mapas raster nuevos, es fundamental que establezcamos la región computacional a los límites y resolución de una de nuestras bandas. También podría ser que nos interesase un área más pequeña para hacer unas pruebas iniciales. Esto es sumamente facil y evita que tengamos que cortar raster a raster físicamente.\n\n# set comp reg to a band - all subsequent output rasters will have this extension & resolution\ngs.parse_command(\"g.region\", \n                 raster=\"T20JLL_20200330T141049_B02_10m\", \n                 flags=\"g\")\n\nAhora demostramos el uso del módulo i.sentinel.mask que toma los metadatos registrados al importar las bandas para ejecutar la identificacion de nubes y sus sombras.\n\n# identify and mask clouds and clouds shadows: i.sentinel.mask\ngs.run_command(\"i.sentinel.mask\",\n               blue=\"T20JLL_20200330T141049_B02_10m\",\n               green=\"T20JLL_20200330T141049_B03_10m\",\n               red=\"T20JLL_20200330T141049_B04_10m\", \n               nir=\"T20JLL_20200330T141049_B08_10m\",\n               nir8a=\"T20JLL_20200330T141049_B8A_20m\",\n               swir11=\"T20JLL_20200330T141049_B11_20m\",\n               swir12=\"T20JLL_20200330T141049_B12_20m\",\n               cloud_mask=\"cloud\", \n               shadow_mask=\"shadow\",\n               scale_fac=10000, \n               flags=\"s\", \n               overwrite=True)\n\nPor defecto obtenemos un mapa vectorial con contornos de nubes y otro para las sombras de nubes:\n\n# list vector maps in the mapset\ngs.list_grouped(type=\"vector\")['sentinel2']\n\nVeamos el resultado agregando “capas” al mapa anterior:\n\n# display output\ncba_rgb.d_vect(map=\"shadow\", color=\"red\", fill_color=\"red\")\ncba_rgb.d_vect(map=\"cloud\", color=\"blue\", fill_color=\"blue\")\ncba_rgb.show()\n\nInspeccionamos el mapa de nubes descargado con la escena (a traves de los flags c y s) y establecemos la misma paleta de colores a los fines de comparar ambos productos: la máscara de nubes y sombras obtenida con i.sentinel.mask y la provista por ESA junto con las imágenes.\n\n# utilizamos un comando de GRASS directamente\n!v.db.select T20JLL_20200330T141049_MSK_CLOUDS | head\n\n\n# o su version dentro de la libreria grass.script\nvec_attr_table = gs.vector_db_select(\"T20JLL_20200330T141049_MSK_CLOUDS\")\n\n\nvec_attr_table[\"values\"]\n\nAsignamos la misma paleta de colores y visualizamos el resultado:\n\ns2_clouds = \"T20JLL_20200330T141049_MSK_CLOUDS\"\ncolours = [\"1 0:0:255\", \"2 255:0:0\"]\ncolourise = gs.feed_command(\"v.colors\", map=s2_clouds, use=\"attr\", column=\"value\", rules=\"-\", quiet=True)\ncolourise.stdin.write(\"\\n\".join(colours).encode())\ncolourise.stdin.close()\n\n\ncba_rgb = gj.Map(use_region=True)\ncba_rgb.d_rgb(red=\"T20JLL_20200330T141049_B04_10m\", \n              green=\"T20JLL_20200330T141049_B03_10m\", \n              blue=\"T20JLL_20200330T141049_B02_10m\")\ncba_rgb.d_grid(size=5000, flags=\"b\")\ncba_rgb.d_vect(map=\"T20JLL_20200330T141049_MSK_CLOUDS\")\ncba_rgb.show()\n\nLos resultados son bastante parecidos y en este último caso, no necesitariamos ejecutar un segundo comando. No obstante, tanto i.sentinel.mask como la banda que viene con la escena, tienen opciones para ajustar el tamaño de nubes y sombras identificadas que aquí se dejaron por defecto.\n\n\nIndices espectrales de vegetación y agua\nAntes de proceder a calcular los índices, vamos a enmascarar las áreas identificadas como nubes y sombras. Para eso, primero pegamos los vectores en uno solo y luego lo aplicamos como máscara inversa. Para más detalles del funcionamiento de las máscaras en GRASS ver r.mask.\n\n# set clouds mask\ngs.run_command(\"v.patch\", \n               input=\"cloud,shadow\", \n               output=\"cloud_shadow_mask\")\n\ngs.run_command(\"r.mask\", \n               vector=\"cloud_shadow_mask\", \n               flags=\"i\")\n\nLuego utilizamos los módulos i.vi e i.wi (addon) para estimar NDVI y NDWI. Ver los respectivos manuales para más detalles sobre los índices disponibles.\n\n# estimate vegetation indices\ngs.run_command(\"i.vi\", \n               red=\"T20JLL_20200330T141049_B04_10m\", \n               nir=\"T20JLL_20200330T141049_B08_10m\", \n               output=\"T20JLL_20200330T141049_NDVI_10m\", \n               viname=\"ndvi\")\n\n# add semantic label\ngs.run_command(\"r.support\",\n               map=\"T20JLL_20200330T141049_NDVI_10m\", \n               semantic_label=\"NDVI\")\n\n\n# install extension\ngs.run_command(\"g.extension\", \n               extension=\"i.wi\")\n\n\n# estimate water indices and set color palette\ngs.run_command(\"i.wi\", \n               green=\"T20JLL_20200330T141049_B03_10m\",\n               nir=\"T20JLL_20200330T141049_B08_10m\",\n               output=\"T20JLL_20200330T141049_NDWI_10m\",\n               winame=\"ndwi_mf\")\n\n# add semantic label\ngs.run_command(\"r.support\", \n               map=\"T20JLL_20200330T141049_NDWI_10m\", \n               semantic_label=\"NDWI\")\n\n# set ndwi color table\ngs.run_command(\"r.colors\", \n               map=\"T20JLL_20200330T141049_NDWI_10m\", \n               color=\"ndwi\")\n\n\n# interactive maps\nidx_map = gj.InteractiveMap(width = 400, use_region=True, tiles=\"OpenStreetMap\")\nidx_map.add_raster(\"T20JLL_20200330T141049_NDVI_10m\", opacity=0.7)\nidx_map.add_raster(\"T20JLL_20200330T141049_NDWI_10m\", opacity=0.7)\nidx_map.add_layer_control(position = \"bottomright\")\nidx_map.show()\n# ... use the layer selector in the corner to enable/disable the NDVI/NDWI layers\n\n\n\nMapas de GRASS como arrays de Numpy\nLos mapas de GRASS pueden leerse como arrays de Numpy gracias a la funcion array de la librería grass.script. Esto facilita muchas operaciones posteriores con librerías de Python que requieren un array como input. En este caso, demostramos su uso con un histograma.\n\n# Import required libraries\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nfrom grass.script import array as garray\n\n# Read NDVI as numpy array\nndvi = garray.array(mapname=\"T20JLL_20200330T141049_NDVI_10m\", null=\"nan\")\nndwi = garray.array(mapname=\"T20JLL_20200330T141049_NDWI_10m\", null=\"nan\")\nprint(ndvi.shape,ndwi.shape)\n\n\n# Plot NDVI and NDWI\nsns.set_style('darkgrid')\nfig, axs = plt.subplots(1, 2, figsize=(7, 7))\nsns.histplot(ax=axs[0], data=ndvi.ravel(), kde=True, color=\"olive\")\nsns.histplot(ax=axs[1], data=ndwi.ravel(), kde=True, color=\"skyblue\")\nplt.show()\n\n\nplt.imshow(ndvi, cmap=\"Greens\")\n\n\n\nSegmentación\nExisten varios módulos para relizar segmentación en GRASS GIS, los mas conocidos son i.segment e i.superpixels.slic. Vamos a demostrar su uso.\nPrimero, instalamos la extensión i.superpixels.slic.\n\n# install extension\ngs.run_command(\"g.extension\", \n               extension=\"i.superpixels.slic\")\n\nLuego, listamos los mapas y crear el grupo con las bandas y los índices.\n\n# list maps\ns2_maps = gs.list_grouped(type=\"raster\", \n                          pattern=\"*20200330T141049*\")['sentinel2']\nprint(s2_maps)\n\n\n# create group and subgroup with bands and indices\ngs.run_command(\"i.group\", \n               group=\"s2\", \n               subgroup=\"s2\", \n               input=s2_maps)\n\ngs.parse_command(\"i.group\", \n                 group=\"s2\", \n                 flags=\"l\")\n\nEjecutar i.superpixels.slic y convertir el resultado a vector\n\n# run i.superpixels.slic\ngs.run_command(\"i.superpixels.slic\", \n               input=\"s2\", \n               output=\"superpixels\", \n               num_pixels=50)\n\n\n# convert the resulting raster to vector\ngs.run_command(\"r.to.vect\", \n               input=\"superpixels\", \n               output=\"superpixels\", \n               type=\"area\")\n\nEjecutar i.segment y convertir el resultado a vector\n\n# run i.segment (region growing)\ngs.run_command(\"i.segment\", \n               group=\"s2\", \n               output=\"segments\", \n               threshold=0.5, \n               minsize=50, \n               memory=500)\n\n\n# convert the resulting raster to vector\ngs.run_command(\"r.to.vect\", \n               input=\"segments\", \n               output=\"segments\", \n               type=\"area\")\n\nComparamos el número de segmentos obtenidos:\n\n# compare number of segments\nn1 = gs.vector_info(map=\"superpixels\")['areas']\nn2 = gs.vector_info(map=\"segments\")['areas']\n\nprint(\"Superpixels SLIC: {}\\nRegion growing: {}\".format(n1,n2))\n\nMostrar NDVI junto con las 2 salidas de la segmentación\n\n# diplay results\nseg_map = gj.InteractiveMap(width = 600, use_region=True, tiles=\"OpenStreetMap\")\nseg_map.add_vector(\"superpixels\")\nseg_map.add_vector(\"segments\")\nseg_map.add_layer_control(position = \"bottomright\")\nseg_map.show()\n\n#... si tarda mucho en ejecutar dentro de Colab, usar la class `Map`\n\n\n\n\n\n\n\nTarea\n\n\n\nEjecutar cualquiera de los 2 métodos de segmentación con diferentes parámetros y comparar los resultados\n\n\n\n\nClasificación supervisada\n\nClasificación supervisada con Maximum Likelihood\nVamos a demostrar a continuacion el workflow para realizar una clasificacion supervisada por máxima verosimilitud a partir de unos polígonos de entrenamiento digitalizados en GRASS y que se encuentran en la carpeta s2_data.\nImportamos el vector y lo visualizamos.\n\ntrain_areas = os.path.join(homedir, s2_data, \"training.gpkg\")\n\n\n# import gpkg with training areas\ngs.run_command(\"v.import\", \n               input=train_areas, \n               output=\"training\")\n\n\n# use color column for classes\ngs.run_command(\"v.colors\", \n               map=\"training\", \n               rgb_column=\"color\", \n               flags=\"c\")\n\n\n# map\ncba_rgb_train = gj.Map(width=300, use_region=True)\ncba_rgb_train.d_rgb(red=\"T20JLL_20200330T141049_B04_10m\", \n              green=\"T20JLL_20200330T141049_B03_10m\", \n              blue=\"T20JLL_20200330T141049_B02_10m\")\ncba_rgb_train.d_grid(size=5000, fontsize=7, flags=\"b\")\ncba_rgb_train.d_vect(map=\"training\")\ncba_rgb_train.show()\n\nConvertimos el mapa vectorial con los polígonos de entrenamiento a mapa raster. Para ello, utilizamos la columna que contiene los números de clase.\n\n!v.db.select training | head\n\n\n# convert to raster\ngs.run_command(\"v.to.rast\", \n               input=\"training\", \n               output=\"training\", \n               use=\"attr\", \n               attribute_column=\"cat_\", \n               label_column=\"class\")\n\nA continuación, utilizamos el módulo i.gensig para generar las firmas espectrales de las clases de interés a partir de los polígonos conocidos/etiquetados.\n\n# obtain signature files\ngs.run_command(\"i.gensig\", \n               trainingmap=\"training\", \n               group=\"s2\", \n               subgroup=\"s2\", \n               signaturefile=\"sig_sentinel\")\n\nEl archivo de firmas es un archivo de texto que se guarda automáticamente dentro de la carpeta grassdata/posgar2007_4_cba/sentinel2/signatures/sig/sig_sentinel/ y tiene la siguiente forma:\n1\n#\nS2_2 S2_3 S2_4 S2_8 S2_11 S2_12 S2_8A NDVI NDWI \n#class_1\n34976\n462.107 754.712 650.115 2652.12 2328.17 1354.23 2898.15 0.590024 -0.54825 \n3433.54 \n3439.85 13667.9 \n4587.72 3893.81 16344.2 \n-891.313 51917 -46133.6 508644 \n6381.57 8558.14 18795.3 -11728.6 64026.7 \n5455.05 4485.2 19848.3 -53771.7 37873.6 35044.9 \n-1286.3 52732.6 -45664.8 513310 -5531.12 -52538.1 526931 \n-1.76356 3.82015 -10.8837 64.4926 -9.11136 -12.7041 64.3455 0.0108229 \n1.38826 -0.0813683 6.12975 -29.5299 4.5855 6.97446 -29.4906 -0.00517479 0.00292289 \n#class_2\n37706\n1609.95 1825.69 1919.19 2607.13 2801.12 2369.91 2765.3 0.160587 -0.184169 \n234001 \n240075 251609 \n248408 260806 281060 \n151243 167006 169635 212669 \n123807 133556 145512 127378 164973 \n116139 123360 136440 90707.7 153127 163716 \n93815.4 104574 105790 153545 118673 82117.3 147388 \n-33.6194 -33.5942 -38.5054 -0.417204 -11.895 -16.7121 3.63643 0.0104315 \n33.4993 33.3665 35.3967 1.58334 9.64074 13.9172 -2.8798 -0.00928648 0.00896403 \n#class_3\n13363\n744.78 937.046 1247.71 1824.1 3187.07 2764.02 2009.06 0.191184 -0.325633 \n27636.3 \n34766.2 44710.3 \n42545.7 55127.4 70153.9 \n50592 65854 81541.4 102364 \n39674.6 49909.5 66588.2 79876.4 180631 \n38446.9 49209.5 64455.1 73554.7 120268 105226 \n49526.6 64512.1 80082.1 100116 81815.5 74146.1 99653.8 \n-3.37419 -4.24876 -5.95143 -4.94336 -5.45999 -6.25113 -5.00936 0.0010409 \n4.3353 5.42295 6.64764 6.64209 5.19235 6.46732 6.6178 -0.000876728 0.00103444\ndonde:\n    Line 1: version number (currently always 1)\n    Line 2: text label\n    Line 3: Space separated list of semantic labels\n    Line 4: text label of class\n    Line 5: number of points in class\n    Line 6: mean values per band of the class\n    Line 7-15: (semi)-matrix of band-band covariance \nPara realizar la clasificación supervisada por máxima verosimilitud, el módulo i.maxlik toma el grupo y la firma como principales inputs:\n\n# perform ML supervised classification\ngs.run_command(\"i.maxlik\", \n               group=\"s2\", \n               subgroup=\"s2\", \n               signaturefile=\"sig_sentinel\", \n               output=\"sentinel_maxlik\")\n\nAsignamos etiquetas a las clases y visualizamos el resultado.\n\n# label classes\nlabel_class = [\"1:vegetation\", \"2:urban\", \"3:bare soil\"]\ncategorise = gs.feed_command(\"r.category\", \n                             map=\"sentinel_maxlik\", \n                             separator=\":\", \n                             rules=\"-\", \n                             quiet=True)\ncategorise.stdin.write(\"\\n\".join(label_class).encode())\ncategorise.stdin.close()\n\n\n# display results\ncba_sup_class = gj.Map(width=500, use_region=True)\ncba_sup_class.d_rast(map=\"sentinel_maxlik\")\ncba_sup_class.d_legend(raster=\"sentinel_maxlik\", title=\"Class\", fontsize=10, at=(80, 93, 80, 90), flags=\"b\")\ncba_sup_class.d_barscale()\ncba_sup_class.show()\n\n\n\nEstadísticas por clase\nUtilizamos el comando r.report para obtener la proporción de cada clase, incluida la de celdas sin datos debido al enmascarado de nubes y sombras de nubes.\n\n# porcentaje de cada clase\ngs.parse_command(\"r.report\", \n                 map=\"sentinel_maxlik\", \n                 units=\"p\", \n                 flags=\"h\")\n\nA continuación, usamos el módulo r.univar para obtener estadísticas descriptivas por clase para la variable NDVI. Para esto, además del raster de NDVI, se pasa la clasificación. Así, el módulo calcula las estadísticas para cada clase.\n\n# estadisticas de las clases: NDVI\nclass_stats = gs.read_command(\"r.univar\", \n                              map=\"T20JLL_20200330T141049_NDVI_10m\", \n                              zones=\"sentinel_maxlik\", \n                              flags=\"t\")\nclass_stats_df = pd.DataFrame([line.split(\"|\") for line in class_stats.splitlines()])\nclass_stats_df.columns = class_stats_df.iloc[0]\n\n\ndf2 = class_stats_df.loc[1:,['label', 'min', 'max', 'mean']] # selecciono unicamente min, max mean\ndf2\n\n\n\nClasificación supervisada con Machine Learning\nPrimero tenemos que instalar la extensión r.learn.ml2 que consta de dos módulos: r.learn.train y r.learn.predict. Esta extensión utiliza la librería scikit-learn de Python y requiere que la misma esté instalada de antemano.\n\n# install ML extension\ngs.run_command(\"g.extension\", \n               extension=\"r.learn.ml2\")\n\nAhora entrenamos el modelo ML usando r.learn.train, con el modelo “RandomForestClassifier”.\n\n# train a random forest classification model using r.learn.train\ngs.run_command(\"r.learn.train\", \n               group=\"s2\", \n               training_map=\"training\",\n               model_name=\"RandomForestClassifier\",\n               n_estimators=\"500\", \n               save_model=os.path.join(homedir, \"rf_model.gz\"))\n\nEl modelo se ha almacenado en el archivo rf_model.gz para su uso en el paso de predicción de la clasificación supervisada.\nAhora entonces aplicamos el modelo entrenado a todo el conjunto de datos.\n\n# Perform prediction using r.learn.predict\ngs.run_command(\"r.learn.predict\", \n               group=\"s2\", \n               load_model=os.path.join(homedir, \"rf_model.gz\"), \n               output=\"sentinel_rf\")\n\n\n# label classes\nlabel_class = [\"1:vegetation\", \"2:urban\", \"3:bare soil\"]\ncategorise = gs.feed_command(\"r.category\", \n                             map=\"sentinel_rf\", \n                             separator=\":\", \n                             rules=\"-\", \n                             quiet=True)\ncategorise.stdin.write(\"\\n\".join(label_class).encode())\ncategorise.stdin.close()\n\n\n# display results\ncba_sup_class = gj.Map(width=500, use_region=True)\ncba_sup_class.d_rast(map=\"sentinel_rf\")\ncba_sup_class.d_legend(raster=\"sentinel_rf\", title=\"Class\", fontsize=10, at=(80, 93, 80, 90), flags=\"b\")\ncba_sup_class.d_barscale()\ncba_sup_class.show()\n\n\n\n\n\n\n\nTarea\n\n\n\nEstimar estadísticas por clase al igual que hicimos para la clasificación por maxíma verosimilitud.\n\n\nComparemos los resultados visualmente y con el módulo r.coin, que nos permite tabular la ocurrencia mutua o coincidencia entre las categorías de dos mapas ráster.\n\n# Display both classified maps together\nclas_maps = gj.InteractiveMap(width = 600, tiles=\"OpenStreetMap\")\nclas_maps.add_raster(\"sentinel_maxlik\", opacity=0.7)\nclas_maps.add_raster(\"sentinel_rf\", opacity=0.7)\nclas_maps.add_layer_control(position = \"bottomright\")\nclas_maps.show()\n\n\nprint(gs.read_command(\"r.coin\",\n                      first=\"sentinel_maxlik\",\n                      second=\"sentinel_rf\",\n                      units=\"p\",\n                      flags=\"w\"))\n\n\n\n\n\n\n\nTarea\n\n\n\nComparar los resultados de ambos tipos de clasificación supervisada a través del índice Kappa.\n\n\n\n\n\nPost-procesamiento y validación\n\nr.reclass.area para eliminar pequeñas áreas, enmascarar nuevos valores y rellenar los huecos con r.neighbors o r.fillnulls\nconvertir la salida en vector y ejecutar v.clean con tool=rmarea\nr.kappa para la validación (idealmente también digitalizar una muestra de prueba)"
  },
  {
    "objectID": "unidad_2/import_s2_with_atm_corr.html",
    "href": "unidad_2/import_s2_with_atm_corr.html",
    "title": "Datos Sentinel 2 L1C",
    "section": "",
    "text": "Para obtener un valor de AOD, tenemos 2 opciones:\nA. Estimar el valor desde un gráfico y usarlo en el comando i.sentinel.preproc via la opción aod_value.\n\nB. Descargar un archivo de http://aeronet.gsfc.nasa.gov y el valor será leido desde el mismo via la opción aeronet_file de i.sentinel.preproc.\n\n\n\n\n\nEstación ARM_Cordoba o Pilar_Cordoba\nSeleccionar fechas de inicio y final\nSeleccionar: Combined file y All points\nDescargar y descomprimir (el archivo final tiene extensión .dubovik)\nPasar el archivo con la opción aeronet_file"
  },
  {
    "objectID": "unidad_2/import_s2_with_atm_corr.html#aod",
    "href": "unidad_2/import_s2_with_atm_corr.html#aod",
    "title": "Datos Sentinel 2 L1C",
    "section": "",
    "text": "Para obtener un valor de AOD, tenemos 2 opciones:\nA. Estimar el valor desde un gráfico y usarlo en el comando i.sentinel.preproc via la opción aod_value.\n\nB. Descargar un archivo de http://aeronet.gsfc.nasa.gov y el valor será leido desde el mismo via la opción aeronet_file de i.sentinel.preproc.\n\n\n\n\n\nEstación ARM_Cordoba o Pilar_Cordoba\nSeleccionar fechas de inicio y final\nSeleccionar: Combined file y All points\nDescargar y descomprimir (el archivo final tiene extensión .dubovik)\nPasar el archivo con la opción aeronet_file"
  },
  {
    "objectID": "unidad_2/import_s2_with_atm_corr.html#mapa-de-elevación",
    "href": "unidad_2/import_s2_with_atm_corr.html#mapa-de-elevación",
    "title": "Datos Sentinel 2 L1C",
    "section": "Mapa de elevación",
    "text": "Mapa de elevación\nExisten dos módulos que nos facilitan la busqueda y obtención de datos de elevación:\n\nr.in.srtm.region: importa (y re-proyecta) los mosaicos SRTM que cubren la región computacional, parchea los mosaicos e interpola datos faltantes\nr.in.nasadem: importa (y re-proyecta) los mosaicos de NASADEM que cubren la región computacional y parchea los mosaicos\n\n\n\n\n\n\n\nImportante\n\n\n\nSi el DEM es más chico que la región computacional, sólo la región cubierta por el DEM será corregida atmosféricamente."
  },
  {
    "objectID": "unidad_2/import_s2_with_atm_corr.html#ejemplo-de-la-ejecución-de-i.sentinel.preproc",
    "href": "unidad_2/import_s2_with_atm_corr.html#ejemplo-de-la-ejecución-de-i.sentinel.preproc",
    "title": "Datos Sentinel 2 L1C",
    "section": "Ejemplo de la ejecución de i.sentinel.preproc",
    "text": "Ejemplo de la ejecución de i.sentinel.preproc\ni.sentinel.preproc -atr \\\n  input_dir=$HOME/gisdata/s2_data/name_of_S2_scene.SAFE \\\n  elevation=NASADEM \\\n  aeronet_file=$HOME/gisdata/s2_data/name_of_aeronet_station.dubovik"
  },
  {
    "objectID": "unidad_1/disclaimer.html",
    "href": "unidad_1/disclaimer.html",
    "title": "Disclaimer",
    "section": "",
    "text": "Se asume que el software necesario está instalado (paquetes y versiones correctas).\nSe asume que los datos necesarios han sido descargados.\nEn caso que internet falle, necesitaremos ejecutar las rutinas localmente.\nSe asume que las personas participantes leyeron los requisitos básicos previo a la inscripción en el curso y son responsables de su elección y consecuencias en caso de no alcanzarlos.\nLas personas participantes concurren con sus notebooks y tienen nociones básicas de línea de comandos sea en Linux o Windows.\nLas personas participantes tienen una cuenta de Gmail para poder ejecutar las notebooks en Google Colab o The Whole Tale."
  },
  {
    "objectID": "unidad_1/disclaimer.html#antes-de-comenzar",
    "href": "unidad_1/disclaimer.html#antes-de-comenzar",
    "title": "Disclaimer",
    "section": "",
    "text": "Se asume que el software necesario está instalado (paquetes y versiones correctas).\nSe asume que los datos necesarios han sido descargados.\nEn caso que internet falle, necesitaremos ejecutar las rutinas localmente.\nSe asume que las personas participantes leyeron los requisitos básicos previo a la inscripción en el curso y son responsables de su elección y consecuencias en caso de no alcanzarlos.\nLas personas participantes concurren con sus notebooks y tienen nociones básicas de línea de comandos sea en Linux o Windows.\nLas personas participantes tienen una cuenta de Gmail para poder ejecutar las notebooks en Google Colab o The Whole Tale."
  },
  {
    "objectID": "unidad_1/disclaimer.html#modalidad-de-trabajo-del-curso",
    "href": "unidad_1/disclaimer.html#modalidad-de-trabajo-del-curso",
    "title": "Disclaimer",
    "section": "Modalidad de trabajo del curso",
    "text": "Modalidad de trabajo del curso\n\nDia 1: Trabajamos con la interfaz gráfica de GRASS. Necesitamos GRASS GIS &gt;= 8.2 instalado localmente.\nDia 2: Empezamos a trabajar con Jupyter notebooks. Explicación sobre su funcionamiento y sobre los paquetes de GRASS para utilizar sus funcionalidades desde Python. Ejemplos. Manejo y procesamiento de datos ráster y satelitales en GRASS GIS dentro de Jupyter notebooks.\nDía 3: OBIA dentro de Jupyter notebooks.\nDía 4: Series de tiempo dentro de Jupyter notebooks.\nDía 5: GRASS y R. Trabajamos con R dentro de Jupyter notebooks."
  },
  {
    "objectID": "unidad_1/disclaimer.html#trabajo-integrador",
    "href": "unidad_1/disclaimer.html#trabajo-integrador",
    "title": "Disclaimer",
    "section": "Trabajo integrador",
    "text": "Trabajo integrador\n\nEs requisito para aprobar el curso y obtener el certificado\nSe puede hacer en grupos de 2 personas\n2 opciones: informe o tutorial\nInstrucciones"
  },
  {
    "objectID": "unidad_1/disclaimer.html#ahora-sí-empecemos",
    "href": "unidad_1/disclaimer.html#ahora-sí-empecemos",
    "title": "Disclaimer",
    "section": "Ahora sí… empecemos!",
    "text": "Ahora sí… empecemos!"
  },
  {
    "objectID": "unidad_3/exercise_obia.html",
    "href": "unidad_3/exercise_obia.html",
    "title": "Ejercicio: OBIA en GRASS GIS",
    "section": "",
    "text": "En este ejercicio vamos a ejemplificar el flujo de trabajo para realizar una clasificación supervisada basada en objetos con datos SPOT.\nAntes de empezar y para ganar tiempo, conectamos nuestro drive e instalamos GRASS en Google Colab.\n# import drive from google colab\nfrom google.colab import drive\n# mount drive\ndrive.mount(\"/content/drive\")\n%%bash\nDEBIAN_FRONTEND=noninteractive \nsudo add-apt-repository ppa:ubuntugis/ubuntugis-unstable \napt update \napt install grass subversion grass-dev\napt remove libproj22\n!grass --config path\nLa función que usaremos en esta sesión para realizar clasificación supervisada de los objetos llama internamente a ciertas librerías de R. Para poder tenerlas de antemano en nuestro entorno, primero instalamos y cargamos en la notebook el paquete de python que nos permite hacer interfaz con R.\n!pip install rpy2==3.5.1\n%reload_ext rpy2.ipython\nChequeamos nuestra sesión de R.\n%R sessionInfo()\nInstalamos todos los paquetes necesarios para este ejercicio. This might take a while…\n%%R\ninstall.packages(\"caret\")\ninstall.packages(\"kernlab\")\ninstall.packages(\"e1071\")\ninstall.packages(\"randomForest\")\ninstall.packages(\"rpart\")\ninstall.packages(\"ggplot\")\ninstall.packages(\"lattice\")\ninstall.packages(\"doParallel\")"
  },
  {
    "objectID": "unidad_3/exercise_obia.html#iniciamos-grass-gis",
    "href": "unidad_3/exercise_obia.html#iniciamos-grass-gis",
    "title": "Ejercicio: OBIA en GRASS GIS",
    "section": "Iniciamos GRASS GIS",
    "text": "Iniciamos GRASS GIS\nIniciamos GRASS GIS en el proyecto posgar2007_4_cba y mapset PERMANENT.\n\nimport os\n\n# data directory\nhomedir = \"/content/drive/MyDrive/curso_grass_2023\"\n\n# GRASS GIS database variables\ngrassdata = os.path.join(homedir, \"grassdata\")\nproject = \"posgar2007_4_cba\"\nmapset = \"PERMANENT\"\n\n\n# import standard Python packages we need\nimport subprocess\nimport sys\n\n# ask GRASS GIS where its Python packages are to be able to start it from the notebook\nsys.path.append(\n    subprocess.check_output([\"grass\", \"--config\", \"python_path\"], text=True).strip()\n)\n\n\n# import the GRASS GIS packages we need\nimport grass.script as gs\nimport grass.jupyter as gj\n\n# start the GRASS GIS Session\nsession = gj.init(grassdata, project, mapset)\n\n\n\n\n\n\n\nTarea\n\n\n\n\nCrear un mapset llamado obia_spot e importar allí las bandas VIS-NIR y PAN de la imagen SPOT con reproyección al vuelo y resolución espacial de 1.5 m.\nAlinear la región computacional a la extensión y resolución de alguna de las bandas importadas.\nHacer una ecualización de histograma para mejorar el contraste de visualización.\nMostrar la combinación RGB color natural (1: azul, 2: verde, 3: rojo, 4: NIR)."
  },
  {
    "objectID": "unidad_3/exercise_obia.html#importar-datos-y-visualizar",
    "href": "unidad_3/exercise_obia.html#importar-datos-y-visualizar",
    "title": "Ejercicio: OBIA en GRASS GIS",
    "section": "Importar datos y visualizar",
    "text": "Importar datos y visualizar\nCreamos el mapset obia_spot.\n\n# Create a new mapset\ngs.run_command(\"g.mapset\",\n               mapset=\"obia_spot\",\n               flags=\"c\")\n\nUna vez creado el mapset, procedemos con la importación de datos. Empezamos por las bandas multi-espectrales.\n\nspot_data = os.path.join(homedir, \"gisdata\", \"spot_data\")\n\n\n# import pansharpened SPOT data\ngs.run_command(\"r.import\",\n               input=os.path.join(spot_data, \"SPOT_20180621_PANSHARP_p.tif\"),\n               output=\"SPOT_20180621_PANSHARP\",\n               resolution=\"value\",\n               resolution_value=1.5)\n\nImportamos también la banda pancromática.\n\n# import SPOT PAN band\ngs.run_command(\"r.import\",\n               input=os.path.join(spot_data, \"SPOT_20180621_PAN.tif\"),\n               output=\"SPOT_20180621_PAN\",\n               resolution=\"value\",\n               resolution_value=1.5)\n\nChequeamos la lista de mapas raster en el mapset.\n\nlista = gs.list_grouped(type=\"raster\")[\"obia_spot\"]\nlista\n\nEstablecemos la región computacional a una de las bandas importadas, de modo que límites y resolución de la región queden alineados a los datos importados.\n\n# align region to one of the raster bands\ngs.run_command(\"g.region\",\n               raster=\"SPOT_20180621_PANSHARP.1\",\n               flags=\"p\")\n\nEstablecemos grey como paleta de colores para las bandas RGB, para poder realizar la composición color natural posteriormente.\n\n# apply grey color to RGB bands\ngs.run_command(\"r.colors\", \n               map=lista,\n               color=\"grey\")\n\nPrimero, hacemos la ecualización de colores para mejorar la visualización.\n\n# perform color auto-balancing for RGB bands\ngs.run_command(\"i.colors.enhance\", \n               red=\"SPOT_20180621_PANSHARP.3\",\n               green=\"SPOT_20180621_PANSHARP.2\", \n               blue=\"SPOT_20180621_PANSHARP.1\",\n               strength=95)\n\nVisualizamos la composición RGB 321 color natural.\n\n# display the enhanced RGB combination\ncba_rgb = gj.Map(use_region=False)\ncba_rgb.d_rgb(red=\"SPOT_20180621_PANSHARP.3\",\n              green=\"SPOT_20180621_PANSHARP.2\",\n              blue=\"SPOT_20180621_PANSHARP.1\")\ncba_rgb.d_grid(size=2000, flags=\"b\")\ncba_rgb.show()"
  },
  {
    "objectID": "unidad_3/exercise_obia.html#hay-valores-nulos",
    "href": "unidad_3/exercise_obia.html#hay-valores-nulos",
    "title": "Ejercicio: OBIA en GRASS GIS",
    "section": "Hay valores nulos?",
    "text": "Hay valores nulos?\nEn la cadena de procesamiento que vamos a realizar, especialmente en los pasos de segmentación, no se admiten valores nulos en los mapas de entrada. Así que, como primer paso antes de proceder, chequeamos la estadística univariada para saber si hay valores nuelos en nuestros mapas.\n\n# one band\nprint(gs.read_command(\"r.univar\",\n                      map=\"SPOT_20180621_PANSHARP.2\"))\n\n\n# bands list\npansharp = gs.list_grouped(type=\"raster\",\n                           pattern=\"*PANSHARP*\")[\"obia_spot\"]\npansharp\n\n\n# joint stats for all the bands\nprint(gs.read_command(\"r.univar\",\n                      map=pansharp))\n\n\n\n\n\n\n\nImportante\n\n\n\nSi hubiera valores nulos, se deben rellenar antes de comenzar! Qué herramientas podríamos utilizar?"
  },
  {
    "objectID": "unidad_3/exercise_obia.html#índices-espectrales-y-texturas-glcm",
    "href": "unidad_3/exercise_obia.html#índices-espectrales-y-texturas-glcm",
    "title": "Ejercicio: OBIA en GRASS GIS",
    "section": "Índices espectrales y texturas GLCM",
    "text": "Índices espectrales y texturas GLCM\nComo ya hicimos en los ejercicios anteriores, estimamos índices espectrales de vegetación y agua.\n\n# estimate vegetation index\ngs.run_command(\"i.vi\", \n               red=\"SPOT_20180621_PANSHARP.3\", \n               nir=\"SPOT_20180621_PANSHARP.4\", \n               output=\"SPOT_20180621_NDVI\", \n               viname=\"ndvi\")\n\n\n# estimate water index\ngs.run_command(\"i.wi\", \n               green=\"SPOT_20180621_PANSHARP.2\", \n               nir=\"SPOT_20180621_PANSHARP.4\", \n               output=\"SPOT_20180621_NDWI\", \n               winame=\"ndwi_mf\")\n\n\n# set ndwi color palette\ngs.run_command(\"r.colors\", \n               map=\"SPOT_20180621_NDWI\", \n               color=\"ndwi\")\n\nPor otra parte, vamos a estimar medidas de textura con r.texture. En este caso, elegimos Inverse Difference Moment (IDM) y Angular Second Moment (ASM), pero hay muchas otras opciones. Este módulo puede ser muy lento si la región computacional es muy grande y si el tamaño de la ventana es grande también. Para agilizar los cálculos en estos casos, se puede usar la extensión r.texture.tiled.\n\n# estimate textures measures\ngs.run_command(\"r.texture\",\n               input=\"SPOT_20180621_PAN\",\n               output=\"SPOT_20180621\",\n               size=7,\n               distance=3,\n               method=\"idm,asm\")\n\n\n# set color table to grey for texture bands\ngs.run_command(\"r.colors\", \n               map=\"SPOT_20180621_IDM\", \n               color=\"grey\",\n               flags=\"e\")\ngs.run_command(\"r.colors\", \n               map=\"SPOT_20180621_ASM\", \n               color=\"grey\",\n               flags=\"e\")\n\nVisualizamos las bandas creadas.\n\nidx_map = gj.InteractiveMap(width = 400, use_region=False, tiles=\"OpenStreetMap\")\nidx_map.add_raster(\"SPOT_20180621_NDVI\", opacity=0.7)\nidx_map.add_raster(\"SPOT_20180621_NDWI\", opacity=0.7)\nidx_map.add_raster(\"SPOT_20180621_IDM\", opacity=0.7)\nidx_map.add_raster(\"SPOT_20180621_ASM\", opacity=0.7)\nidx_map.add_layer_control(position = \"bottomright\")\nidx_map.show()\n\n\n\n\n\n\n\nNota\n\n\n\nSobre qué banda calculamos las texturas? Si no contamos con una banda pancromática, podemos crearla promediando las bandas visibles\n\n# create pan-vis from RGB (if no pan available)\nR = \"SPOT_20180621_PANSHARP.3\"\nG = \"SPOT_20180621_PANSHARP.2\"\nB = \"SPOT_20180621_PANSHARP.1\"\n\ngs.mapcalc(exp=f\"PANVIS = round(({R} + {G} + {B}) / 3)\""
  },
  {
    "objectID": "unidad_3/exercise_obia.html#segmentación",
    "href": "unidad_3/exercise_obia.html#segmentación",
    "title": "Ejercicio: OBIA en GRASS GIS",
    "section": "Segmentación",
    "text": "Segmentación\n\nBúsqueda de umbrales de sub y sobre-segmentación\nComo vimos en el ejercicio anterior, usualmente, los módulos i.* toman un grupo de mapas como entrada. Antes de comenzar con la segmentación, entonces, creamos un grupo con las bandas multiespectrales únicamente.\n\n# create imagery group (only ms bands)\ngs.run_command(\"i.group\",\n               group=\"spot_bands\",\n               input=pansharp)\n\nAhora vamos a aprovechar una de las grandes ventajas de la región computacional, i.e., definir una región más pequeña para realizar unas pruebas :)\n\n# set smaller region\ngs.run_command(\"g.region\",\n               n=6525171,\n               s=6523179,\n               w=4390557,\n               e=4393257)\ngs.run_command(\"g.region\",\n               save=\"obia_subset\")\ngs.region()\n\nAhora sí, ejecutamos un par de segmentaciones para determinar niveles de sub- y sobre-segmentación. Empezamos con un umbral pequeño.\n\n# run segmentation - small threshold\ngs.run_command(\"i.segment\",\n               group=\"spot_bands\",\n               output=\"segment_001\",\n               threshold=0.01,\n               memory=2000)\n\n\n# convert output to vector\ngs.run_command(\"r.to.vect\",\n               input=\"segment_001\",\n               output=\"segment_001\",\n               type=\"area\",\n               flags=\"tv\")\n\n\n# display results\nsegs = gj.Map(use_region=True)\nsegs.d_rgb(red=\"SPOT_20180621_PANSHARP.3\",\n              green=\"SPOT_20180621_PANSHARP.2\",\n              blue=\"SPOT_20180621_PANSHARP.1\")\nsegs.d_vect(map=\"segment_001\", type=\"boundary\", color=\"yellow\")\nsegs.show()\n\nProbamos con un umbral más grande.\n\n# run segmentation - larger threshold\ngs.run_command(\"i.segment\",\n               group=\"spot_bands\",\n               output=\"segment_005\",\n               threshold=0.05,\n               memory=2000)\n\n\n# convert output to vector\ngs.run_command(\"r.to.vect\",\n               input=\"segment_005\",\n               output=\"segment_005\",\n               type=\"area\",\n               flags=\"tv\")\n\n\n# display results\nsegs = gj.Map(use_region=True)\nsegs.d_rgb(red=\"SPOT_20180621_PANSHARP.3\",\n              green=\"SPOT_20180621_PANSHARP.2\",\n              blue=\"SPOT_20180621_PANSHARP.1\")\nsegs.d_vect(map=\"segment_005\", type=\"boundary\", color=\"red\")\nsegs.show()\n\nHagamos zoom sobre los resultados para cada umbral.\n\n\nSobre-segmentado\n\n\nSub-segmentado\n\n\n\n\n\n\n\n\n\nTarea\n\n\n\nSe animan a probar con otros valores y en otras regiones?\n\n\n\n\nBúsqueda automática de umbrales por optimización\nTeniendo valores de umbrales de sub- y sobre-segmentación, podemos proceder a realizar la segmentación de manera autómatica, buscando el mejor umbral en una especie de grilla definida por umbral mínimo, umbral máximo y paso. Para ello, utilizamos la extensión: i.segment.uspo.\nEste procedimiento es computacionalmente intensivo para un área grande y muchas combinaciones de parámetros, pero siempre podemos:\n\nLimitar el tamaño de la región computacional o generar tiles con i.cutlines y paralelizar la USPO.\nLimitar el rango de los parámetros, o usar un paso relativamente grande.\nCrear superpixels con i.superpixels.slic para usarlos como semillas.\n\n\nGeneración de semillas\nLa extensión i.superpixels.slic\n\nTambién puede utilizarse para la segmentación per se, como vimos en el ejercicio anterior.\nEs muy rápida para reagrupar pequeñas cantidades de píxeles similares.\nSe puede usar para reducir el número de píxeles en un factor de 4-5 y acelerar i.segment.uspo, que ya no empieza por pixeles individuales, sino por pequeños grupos de pixeles similares.\nSe usa baja compactación para mantener la separación espectral (Ver el manual: A larger compactness value will cause spatially more compact, but spectrally more heterogeneous superpixels).\n\n\n\n\nUSPO con superpixels como semillas\nVamos a ejecutar entonces i.superpixels.slic con bajo valor de compactación para generar el semillero para i.segment.uspo.\n\n# run superpixel segmentation to use as seeds\ngs.run_command(\"i.superpixels.slic\",\n               input=\"spot_bands\",\n               output=\"superpixels\",\n               step=2,\n               compactness=0.7,\n               memory=2000)\n\nAcá podemos ver un recorte de la composición RGB y el resultado de la ejecución de i.superpixels.slic.\n\n\n\n\n\n\n\nTarea\n\n\n\nCuántas semillas se generaron? Qué factor de reducción se consigue en comparación a usar todos los pixeles?\nPara responder pueden dar una mirada a los manuales de r.info y g.region.\n\n\nInstalamos las extensiones y ejecutamos la segmentación con optimización.\n\n# install extensions\ngs.run_command(\"g.extension\", \n               extension=\"r.neighborhoodmatrix\")\ngs.run_command(\"g.extension\", \n               extension=\"i.segment.uspo\")\n\n\n# run segmentation with uspo\ngs.run_command(\"i.segment.uspo\",\n               group=\"spot_bands\",\n               output=\"uspo_parameters.csv\",\n               region=\"obia_subset\",\n               seeds=\"superpixels\",\n               segment_map=\"segs\",\n               threshold_start=0.005,\n               threshold_stop=0.05,\n               threshold_step=0.005,\n               minsizes=3, \n               number_best=5,\n               memory=2000,\n               processes=6)\n\n\n# explore results\ngs.list_grouped(type=\"raster\", \n                pattern=\"segs_*\")[\"obia_spot\"]\n\n\n!cat uspo_parameters.csv\n\nConvertimos el mejor resultado, i.e., *rank1 a vector para visualizar el resultado.\n\n# convert to vector the rank1\ngs.run_command(\"r.to.vect\",\n               input=\"segs_obia_subset_rank1\",\n               output=\"segs\",\n               type=\"area\",\n               flags=\"tv\")\n\nZoom al resultado de ejecutar la segmentación con USPO\n\n\n\n\n\n\n\nTarea\n\n\n\nCuántos segmentos obtuvieron?\nDar una mirada a v.info para responder."
  },
  {
    "objectID": "unidad_3/exercise_obia.html#estadísticas-de-segmentos-i.segment.stats",
    "href": "unidad_3/exercise_obia.html#estadísticas-de-segmentos-i.segment.stats",
    "title": "Ejercicio: OBIA en GRASS GIS",
    "section": "Estadísticas de segmentos: i.segment.stats",
    "text": "Estadísticas de segmentos: i.segment.stats\nInstalamos la extensión que nos permite extraer estadísticas para los segmentos obtenidos en el paso anterior.\n\n# install extensions\ngs.run_command(\"g.extension\", \n               extension=\"i.segment.stats\")\n\n\n# extract stats for all segments \n# Note: vectormap output does not work for this dataset, see loong workaround with csv output in further steps\ngs.run_command(\"i.segment.stats\",\n               map=\"segs_obia_subset_rank1\",\n               csvfile=\"segs_stats.csv\",\n               rasters=\"SPOT_20180621_ASM,SPOT_20180621_IDM,SPOT_20180621_NDVI,SPOT_20180621_NDWI,SPOT_20180621_PAN\",\n               raster_statistics=\"mean,stddev\",\n               area_measures=\"area,perimeter,compact_circle,compact_square\",\n               processes=4)\n\nVisualizamos el csv resultante con la estadística por segmentos.\n\n!cat segs_stats.csv | head\n\n\n\n\n\n\n\nTarea\n\n\n\nQué otras estadísticas se podrían obtener? Qué otro(s) módulo(s) podría(n) sustituir a i.segment.stats?"
  },
  {
    "objectID": "unidad_3/exercise_obia.html#datos-de-entrenamiento",
    "href": "unidad_3/exercise_obia.html#datos-de-entrenamiento",
    "title": "Ejercicio: OBIA en GRASS GIS",
    "section": "Datos de entrenamiento",
    "text": "Datos de entrenamiento\nTenemos nuestros segmentos caracterizados, pero nos falta un dato fundamental para poder realizar una clasificación supervisada… la verdad de terreno, i.e., a qué clase pertenece una muestra de todos los segmentos del área de estudio. Como etiquetar segmentos o puntos es una tarea tediosa, se provee dentro del mapset PERMANENT un conjunto de puntos con etiqueta para realizar el entrenamiento. Veamos cuántos puntos tenemos.\n\n# get info of labeled points\ngs.vector_info_topo(\"labeled_points\")\n\nComo el acceso a tablas de otros mapsets no está permitido, nos copiamos el vector con los puntos etiquetados al mapset obia_spot.\n\n# copy vector to current mapset (access to tables from different mapsets is not allowed)\ngs.run_command(\"g.copy\",\n               vector=\"labeled_points@PERMANENT,labeled_points\")\n\nCuántos puntos de cada clase tenemos?\n\n# get number of points per class\nprint(gs.read_command(\"db.select\",\n                      sql=\"SELECT train_class,COUNT(cat) as count_class FROM labeled_points GROUP BY train_class\"))\n\nSeleccionar segmentos sobre los cuales tenemos puntos de entrenamiento\n\n# select segments that are below labeled points\ngs.run_command(\"v.select\",\n               ainput=\"segs\",\n               binput=\"labeled_points\",\n               output=\"train_segments\",\n               operator=\"overlap\")\n\nCuántos segmentos contienen puntos de entrenamiento?\n\n# get info of segments\ngs.vector_info_topo(map=\"train_segments\")\n\nVeamos un zoom a la selección de segmentos con puntos de entrenamiento.\n\nAntes de asignar el atributo de los puntos a los segmentos, necesitamos agregar una tabla y una columna al vector con los segmentos.\n\n# add attr table to train segments\ngs.run_command(\"v.db.addtable\",\n               map=\"train_segments\")\n\n\n# add column to train segments\ngs.run_command(\"v.db.addcolumn\",\n               map=\"train_segments\",\n               column=\"class int\")\n\nAhora sí, usamos el módulo v.distance para transferir la etiqueta (clase de cobertura) desde los puntos a los segmentos\n\n# assign label from points to segments\ngs.run_command(\"v.distance\",\n               from_=\"train_segments\", \n               to=\"labeled_points\",\n               upload=\"to_attr\",\n               column=\"class\",\n               to_column=\"train_class\")\n\nCuántos segmentos de cada clase tenemos?\n\n# group training segments per class\n!db.select sql=\"SELECT class,COUNT(cat) as count_class FROM train_segments GROUP BY class\"\n\nComo, por alguna razón, para estos datos, no pudimos obtener un vector a partir de i.segment.stats, necesitamos hacer un “workaround” para obtener, en cambio, un csv con los segmentos de entrenamiento, sus estadísticas y sus etiquetas. Para eso, haremos lo siguiente:\n\nconvertir a raster el vector train_segments con las etiquetas para poder obtener las estadísticas con i.segment.stats,\nobtener las estadísticas para los segmentos de entrenamiento únicamente con i.segment.stats,\nimportar a GRASS la tabla csv resultante (Sí, podemos importar tablas a GRASS!),\nunir el vector de segmentos de entrenamiento que tiene las etiquetas con la tabla con las estadísticas,\neliminar la columna cat_ resultante de la unión, ya que no es un atributo para la clasificación, y\nexportar la nueva tabla de atributos como csv.\n\nSi, de i.segment.stats ustedes pueden obtener un vector, la tarea es mucho más sencilla:\n# select segments that are below labeled points\nv.select \\\n  ainput=segs_stats \\ # vector obtenido con i.segment.stats\n  binput=labeled_points \\\n  output=train_segments \\\n  operator=overlap\n\n# add column to train segments\nv.db.addcolumn train_segments column=\"class int\"\n\n# assign label from points to segments\nv.distance from=train_segments \\\n  to=labeled_points \\\n  upload=to_attr \\\n  column=class \\\n  to_column=train_class\nEmpecemos…\n\n# convert train_segments vector to raster\ngs.run_command(\"v.to.rast\",\n               input=\"train_segments\",\n               output=\"train_segments\",\n               use=\"cat\")\n\n\n# extract stats for training segments\ngs.run_command(\"i.segment.stats\",\n               map=\"train_segments\",\n               csvfile=\"train_segs_stats.csv\",\n               separator=\"comma\",\n               rasters=\"SPOT_20180621_ASM,SPOT_20180621_IDM,SPOT_20180621_NDVI,SPOT_20180621_NDWI,SPOT_20180621_PAN\",\n               raster_statistics=\"mean,stddev\",\n               area_measures=\"area,perimeter,compact_circle,compact_square\",\n               processes=4)\n\n\n!cat train_segs_stats.csv | head\n\n\n# import csv table\ngs.run_command(\"db.in.ogr\",\n               input=\"train_segs_stats.csv\",\n               output=\"train_segs_stats\") # name of the table within GRASS\n\n\nprint(gs.read_command(\"db.describe\",\n                      table=\"train_segs_stats\",\n                      flags=\"c\"))\n\n\n# paste column class from train_segments to train_segs_stats.csv\ngs.run_command(\"v.db.join\",\n               map=\"train_segments\",\n               column=\"cat\",\n               other_table=\"train_segs_stats\",\n               other_column=\"cat_\")\n\n\n# drop cat_ column\ngs.run_command(\"v.db.dropcolumn\",\n               map=\"train_segments\",\n               columns=\"cat_\")\n\n\n# save patched attr table as csv \ngs.run_command(\"v.db.select\",\n               map=\"train_segments\",\n               file=\"train_segs_stats_class.csv\")\n\n\n# check csv\n!cat train_segs_stats_class.csv | head\n\n\n# remove column cat_ and save fixed csv\n# !cut --complement -f3 -d\"|\" train_segs_stats_class.csv &gt; train_segs_stats_class_fix.csv\n\n\n\n\n\n\n\nUna forma de seleccionar y etiquetar datos de entrenamiento\n\n\n\n\nEjecutar una clasificación no supervisada con 10 clases\nExtraer una x cantidad de puntos por clase (r.sample.category)\nEtiquetar los puntos manualmente\nUsar puntos para transferir las etiquetas a los segmentos como ya vimos\n\n# Unsupervised classification\ni.group group=spot_all input=SPOT_20180621_ASM,SPOT_20180621_IDM,SPOT_20180621_NDVI,SPOT_20180621_NDWI,SPOT_20180621_PAN,SPOT_20180621_PANSHARP.1,SPOT_20180621_PANSHARP.2,SPOT_20180621_PANSHARP.3,SPOT_20180621_PANSHARP.4\ni.cluster group=spot_all signaturefile=sig classes=10\ni.maxlik group=spot_all signaturefile=sig output=uns_clas\n\n# install extension\ng.extension r.sample.category\n\n# get n points per class\nr.sample.category input=uns_clas output=uns_clas_points npoints=150\n\n# then, manually label points"
  },
  {
    "objectID": "unidad_3/exercise_obia.html#clasificación-con-machine-learning",
    "href": "unidad_3/exercise_obia.html#clasificación-con-machine-learning",
    "title": "Ejercicio: OBIA en GRASS GIS",
    "section": "Clasificación con Machine learning",
    "text": "Clasificación con Machine learning\nAhora sí, finalmente llegamos a la clasificación de los segmentos. Vamos a instalar la extensión v.class.mlR. Esta extensión usa paquetes de R para realizar la clasificación, por lo tanto necesitamos tener R y ciertos paquetes previamente instalados.\n\n# install extension\ngs.run_command(\"g.extension\", \n               extension=\"v.class.mlR\")\n\n\n# run classification\ngs.run_command(\"v.class.mlR\",\n               segments_file=\"segs_stats.csv\", # stats of all segments\n               training_file=\"train_segs_stats_class.csv\", # stats of training segs\n               train_class_column=\"class\",\n               classified_map=\"classification\",\n               raster_segments_map=\"segs_obia_subset_rank1\",\n               classifier=\"rf\",\n               folds=5,\n               partitions=10,\n               tunelength=10,\n               weighting_modes=\"smv\",\n               weighting_metric=\"accuracy\",\n               output_model_file=\"model\",\n               variable_importance_file=\"var_imp.txt\",\n               accuracy_file=\"accuracy.csv\",\n               model_details=\"classifier_runs.txt\",\n               r_script_file=\"Rscript_mlR.R\",\n               processes=2, # use more if available\n               flags=\"nf\")\n\n\n\n\n\n\n\nTarea\n\n\n\nCrear paleta de colores para las clases de cobertura urbana asignando colores interactivamente\n\nIr agregando valores\nSeleccionar colores\nPrevisualizar\nGuardar la paleta creada como obia_urban para reusar posteriormente\n\n\n\n\nAplicamos la paleta de colores que creamos.\n\n# set color table that we created interactively\ngs.run_command(\"r.colors\",\n               map=\"classification_rf\",\n               rules=\"obia_urban\")\n\nVisualizamos el resultado de la clasificación supervisada con Machine Learning basada en objetos\n\n# display results\nobia = gj.Map(use_region=True)\nobia.d_rast(map=\"classification_rf\")\nobia.show()\n\nRevisemos los archivos auxiliares que obtuvimos de la ejecución de la clasificación por random forest.\n\n!cat var_imp.txt\n\n\n!cat accuracy.csv\n\n\n!cat classifier_runs.txt\n\n\n\n\n\n\n\nImportante\n\n\n\nEl proceso de clasificación usualmente conlleva una serie de iteraciones que implican selección de variables más importantes, búsqueda de más/mejores datos de entrenamiento y validación"
  },
  {
    "objectID": "unidad_3/exercise_obia.html#validación",
    "href": "unidad_3/exercise_obia.html#validación",
    "title": "Ejercicio: OBIA en GRASS GIS",
    "section": "Validación",
    "text": "Validación\n\nSe usan datos independientes para validar las clasificaciones\nSe construye una matriz de confusión que permite visualizar los errores por clase en los elementos que están fuera de la diagonal\nSe estiman varias medidas relacionadas a la precisión, ej.: overall accuracy y kappa\n\nDistintas opciones: 1. Generar un nuevo set de puntos y etiquetarlos 2. Separar el set de puntos etiquetados en train y test de antemano\n\nOpción 1\n\n\n\n\n\n\nTarea\n\n\n\nGenerar un set de validación de al menos 50 segmentos. Una vez creado el vector de segmentos con etiquetas, testing, convertirlo a formato raster y ejecutar r.kappa.\n\n\nr.kappa necesita mapas raster como input, por lo tanto necesitamos transformar los segmentos de validación a formato raster usando la columna class como fuente de valores para los pixeles.\n\n# convert labeled test segments to raster\ngs.run_command(\"v.to.rast\",\n               map=\"testing\",\n               use=\"attr\",\n               attribute_column=\"class\",\n               output=\"testing\")\n\n\n# create confusion matrix and estimate precision measures\nprint(gs.read_command(\"r.kappa\",\n                      classification=\"classification_rf\",\n                      reference=\"testing\"))\n\n\n\nOpción 2\nAlternativamente, podemos separar el set de puntos etiquetados en train y test. Usemos la extensión v.divide.training_validation creada por mundialis.\n\n# install the extension\ngs.run_command(\"g.extension\",\n               extension=\"v.divide.training_validation\",\n               url=\"https://github.com/mundialis/v.divide.training_validation\")\n\n\n# divide our labeled segments into train and test\ngs.run_command(\"v.divide.training_validation\",\n               input=\"train_segments\",\n               column=\"class\", \n               training=\"training\", \n               validation=\"testing\", \n               training_percent=30)\n\n\n\n\n\n\n\nTarea\n\n\n\nEjecutar nuevamente la clasificación usando sólo el vector training. Recordar convertir a csv.\n\n\nAgregamos la columna pred_class al vector test\n\n# add column to test point map\ngs.run_command(\"v.db.addcolumn\",\n               map=\"testing\",\n               column=\"pred_class integer\")\n\nObtener las clases predichas para los segmentos de validación\n\n# query the classified map\ngs.run_command(\"v.what.rast\",\n               map=\"testing\",\n               column=\"pred_class\",\n               raster=\"classification_rf\")\n\n\n\n\n\n\n\nTarea\n\n\n\nCovertir a raster y ejecutar r.kappa."
  },
  {
    "objectID": "index.html#dia-1-ejecutamos-grass-localmente",
    "href": "index.html#dia-1-ejecutamos-grass-localmente",
    "title": "Procesamiento y análisis de series temporales con GRASS GIS",
    "section": "Dia 1: Ejecutamos GRASS localmente",
    "text": "Dia 1: Ejecutamos GRASS localmente\n\nSoftware necesario\nPara el primer día del curso, vamos a ejecutar GRASS GIS de manera local. Por lo tanto, necesitamos traer GRASS GIS versión &gt;= 8.2.0 y QGIS previamente instalados.\n\n\nDatos necesarios\n\nDescargar el archivo comprimido (~150 Mb) que incluye los datos de muestra para utilizar durante el primer día."
  },
  {
    "objectID": "index.html#día-2-al-5-ejecutamos-grass-online",
    "href": "index.html#día-2-al-5-ejecutamos-grass-online",
    "title": "Procesamiento y análisis de series temporales con GRASS GIS",
    "section": "Día 2 al 5: Ejecutamos GRASS online",
    "text": "Día 2 al 5: Ejecutamos GRASS online\nEl resto del curso se ejecutará con notebooks en línea dentro de la plataforma Google Colab. Podemos visitar la web de preguntas frecuentes para obtener mayor información sobre el funcionamiento y las prestaciones de esta plataforma.\nOtra opción es ejecutar las notebook dentro de la plataforma The Whole Tale. Whole Tale es una iniciativa de la Data Infrastructure Building Block (DIBBS) financiada por NSF para construir una plataforma escalable y multiusuario de código abierto, basada en la web para investigaciones reproducibles. Permite la creación, publicación y ejecución de tales: objetos de investigación ejecutables que capturan datos, código y el entorno de software completo utilizado para producir los resultados de la investigación. También es fantástico para enseñar, ya que los participantes no necesitan instalar todos los paquetes de software necesarios. ¡Solo necesitan registrarse con un correo electrónico institucional o personal y ya están listos para comenzar!\nCómo ejecutar Google Colab:\n\nOpen colab: https://colab.research.google.com/\nFile &gt;&gt; Open notebook\nSeleccionar “Github”\nEn Repositorios poner: veroandreo/curso-grass-gis\nseleccionar la notebook que se desea ejecutar\n\n\n\n\nAbrir el repo del curso en Colab\n\n\nEn Google Colab no tenemos preinstalado el software necesario, así que necesitaremos instalar en cada sesión. Para ello, tenemos una notebook con instrucciones que podemos luego copiar y pegar en cada notebook antes de comenzar.\nCómo ejecutar Whole Tale:\n\nIr a Curso GRASS 2023\nLog in (hay diferentes opciones)\nEjecutar la Tale (botón azul arriba a la derecha)\nConfirmar Copy y Run Tale\nSi sigue mostrando “Importing…”, recargar la página (F5)\nRun Tale\n\n\n\n\n\n\n\nImportante\n\n\n\nLas notebooks están preparadas por defecto para correr en el entorno de Colab conectado al Drive. Para ejecutar el curso en The Whole Tale, será necesario adecuar algunas rutas a carpetas y archivos, y para la sesión de GRASS y R, deberemos cambiar las celdas o chunks de python a r y borrar el comando mágico %%R.\n\n\n\nDatos necesarios\n\nUsaremos el siguiente archivo comprimido (~ 3.5 Gb) con diferentes datos para las sesiones y un proyecto de GRASS GIS listo para usar. Si van a usar Colab, pueden hacer una copia de esta carpeta directamente a su Google drive así queda todo listo para trabajar. En Whole Tale, los datos ya están subidos."
  },
  {
    "objectID": "index.html#sec-software",
    "href": "index.html#sec-software",
    "title": "Procesamiento y análisis de series temporales con GRASS GIS",
    "section": "Software necesario para ejecutar el curso completo localmente",
    "text": "Software necesario para ejecutar el curso completo localmente\n\nGRASS GIS &gt;= 8.2.0\nPython &gt;= 3.7 con los siguientes paquetes:\n\njupyterlab, numpy, matplotlib, seaborn, scikit-learn, scipy, pandas, folium, sentinelsat\n\nR &gt;= 4.2 con los siguientes paquetes:\n\nrgrass, sf, terra, raster, mapview, tmap, tmaptools, SDMtune, biomod2, dismo, usdm, zeallot, ggpubr, rJava, caret, kernlab, e1071, randomForest, rpart, doParallel\n\nQGIS\n\n\nNota para usuarios Ubuntu\nUsar el PPA inestable de ubuntugis para obtener la última versión de GRASS GIS:\nsudo add-apt-repository ppa:ubuntugis/ubuntugis-unstable\nsudo apt update\nsudo apt install grass grass-gui grass-dev"
  },
  {
    "objectID": "install_colab_and_mount_gdrive.html",
    "href": "install_colab_and_mount_gdrive.html",
    "title": "Instalar software en Colab",
    "section": "",
    "text": "Como primer paso, cada vez que iniciemos una nueva sesión, necesitaremos instalar GRASS GIS. Pueden copiar estas celdas a sus copias de las notebooks con las que trabajaremos.\n\n%%bash\nDEBIAN_FRONTEND=noninteractive \nsudo add-apt-repository ppa:ubuntugis/ubuntugis-unstable \napt update \napt install grass subversion grass-dev\napt remove libproj22\n\n\n\n\n\n\n\nNota\n\n\n\nSi al importar datos con reproyección al vuelo, se encuentran con errores del tipo: Flag -r requires GDAL library: No module named '_gdal', se recomienda instalar la librería pygdal:\n\npip install pygdal"
  },
  {
    "objectID": "install_colab_and_mount_gdrive.html#instalar-grass-gis",
    "href": "install_colab_and_mount_gdrive.html#instalar-grass-gis",
    "title": "Instalar software en Colab",
    "section": "",
    "text": "Como primer paso, cada vez que iniciemos una nueva sesión, necesitaremos instalar GRASS GIS. Pueden copiar estas celdas a sus copias de las notebooks con las que trabajaremos.\n\n%%bash\nDEBIAN_FRONTEND=noninteractive \nsudo add-apt-repository ppa:ubuntugis/ubuntugis-unstable \napt update \napt install grass subversion grass-dev\napt remove libproj22"
  },
  {
    "objectID": "install_colab_and_mount_gdrive.html#conectar-nuestro-gdrive",
    "href": "install_colab_and_mount_gdrive.html#conectar-nuestro-gdrive",
    "title": "Instalar software en Colab",
    "section": "Conectar nuestro GDrive",
    "text": "Conectar nuestro GDrive\nLuego, montamos nuestro drive donde tenemos la carpeta curso_grass_2023. Para eso importamos la librería drive.\n\n# import drive from google colab\nfrom google.colab import drive \n\nDefinimos un punto de montaje y montamos nuestro drive, esto es equivalente a enchufar y leer un pen drive o un disco externo. Nos va a pedir que le demos permisos para acceder.\n\n# define mounting point for drive\ndmp = \"/content/drive\"\n# mount drive\ndrive.mount(dmp)\n\nDefinimos la carpeta curso_grass_2023 como nuestro home, nos movemos allí y listamos su contenido para corrobar que estamos donde queremos estar.\n\nimport os\n\nhomedir = \"/content/drive/MyDrive/curso_grass_2023\"\nos.chdir(homedir)\nos.listdir()"
  },
  {
    "objectID": "install_colab_and_mount_gdrive.html#ejecutar-comandos-de-r-en-google-colab",
    "href": "install_colab_and_mount_gdrive.html#ejecutar-comandos-de-r-en-google-colab",
    "title": "Instalar software en Colab",
    "section": "Ejecutar comandos de R en Google Colab",
    "text": "Ejecutar comandos de R en Google Colab\nColab nos permite ejcutar comandos de python por defecto. Usando ciertos caracteres mágicos o shebangs como ! o %%bash podemos ejecutar comandos en bash, i.e., como en una terminal de Linux. En este caso, colab tiene Ubuntu.\nPara ejecutar comandos de R, tenemos dos opciones. Una es simplemente cambiar de runtime o entorno de ejecución. Para esto, vamos al menú principal Runtime &gt;&gt; Change runtime type y en el cuadro que se despliega elegimos R. La segunda opción es instalar un paquete de python que nos permite hacer interfaz con R. La ventaja de esta aproximación es que podemos montar nuestro drive, de la otra forma no se puede. La desventaja es que necesitamos escribir el shebang %%R en cada celda de código en R1.\n\n!pip install rpy2==3.5.1\n%reload_ext rpy2.ipython\n\nEsto será necesario para nuestra sesión de GRASS y R."
  },
  {
    "objectID": "install_colab_and_mount_gdrive.html#footnotes",
    "href": "install_colab_and_mount_gdrive.html#footnotes",
    "title": "Instalar software en Colab",
    "section": "Notas",
    "text": "Notas\n\n\nVer https://www.thediar.com/es/blog/google-colab-drive-r/ y https://blog.revolutionanalytics.com/2016/01/pipelining-r-python.html↩︎"
  },
  {
    "objectID": "install_colab_and_mount_gdrive.html#instalar-grass-gis-en-colab",
    "href": "install_colab_and_mount_gdrive.html#instalar-grass-gis-en-colab",
    "title": "Instalar software en Colab",
    "section": "",
    "text": "Como primer paso, cada vez que iniciemos una nueva sesión, necesitaremos instalar GRASS GIS. Pueden copiar estas celdas a sus copias de las notebooks con las que trabajaremos.\n\n%%bash\nDEBIAN_FRONTEND=noninteractive \nsudo add-apt-repository ppa:ubuntugis/ubuntugis-unstable \napt update \napt install grass subversion grass-dev\napt remove libproj22\n\n\n\n\n\n\n\nNota\n\n\n\nSi al importar datos con reproyección al vuelo, se encuentran con errores del tipo: Flag -r requires GDAL library: No module named '_gdal', se recomienda instalar la librería pygdal:\n\npip install pygdal"
  },
  {
    "objectID": "install_colab_and_mount_gdrive.html#conectar-nuestro-drive-a-la-sesión-de-colab",
    "href": "install_colab_and_mount_gdrive.html#conectar-nuestro-drive-a-la-sesión-de-colab",
    "title": "Instalar software en Colab",
    "section": "Conectar nuestro Drive a la sesión de Colab",
    "text": "Conectar nuestro Drive a la sesión de Colab\nLuego, montamos nuestro drive donde tenemos la carpeta curso_grass_2023. Para eso importamos la librería drive.\n\n# import drive from google colab\nfrom google.colab import drive \n\nDefinimos un punto de montaje y montamos nuestro drive, esto es equivalente a enchufar y leer un pen drive o un disco externo. Nos va a pedir que le demos permisos para acceder.\n\n# define mounting point and mount drive\ndrive.mount(\"/content/drive\")\n\nDefinimos la carpeta curso_grass_2023 como nuestro home, nos movemos allí y listamos su contenido para corrobar que estamos donde queremos estar.\n\nimport os\n\nhomedir = \"/content/drive/MyDrive/curso_grass_2023\"\nos.chdir(homedir)\nos.listdir()\n\nTambién podemos montar nuestro drive directamente desde la interfaz gráfica y ver allí el contenido de las carpetas:"
  },
  {
    "objectID": "install_colab_and_mount_gdrive.html#ejecutar-comandos-de-r-en-colab",
    "href": "install_colab_and_mount_gdrive.html#ejecutar-comandos-de-r-en-colab",
    "title": "Instalar software en Colab",
    "section": "Ejecutar comandos de R en Colab",
    "text": "Ejecutar comandos de R en Colab\nColab nos permite ejcutar comandos de python por defecto. Usando ciertos caracteres mágicos como ! o %%bash podemos ejecutar comandos en bash, i.e., como en una terminal de Linux. En este caso, colab tiene Ubuntu.\nPara ejecutar comandos de R, tenemos dos opciones. Una es simplemente cambiar de runtime o entorno de ejecución a R. Para esto, vamos al menú principal Runtime &gt;&gt; Change runtime type y en el cuadro que se despliega elegimos R. El problema con esta aproximación es que no hay una forma nativa de montar nuestro GDrive y acceder fácilmente a los archivos. Si bien existe un paquete de R googledrive que permite la conexión, éste no funciona para conectarnos a nuestro grassdata e iniciar una sesión de GRASS allí.\n\n# install and load googledrive library\ninstall.packages(\"googledrive\")\nlibrary(\"googledrive\")\n\n# authorize google drive\ndrive_auth(\n  email = gargle::gargle_oauth_email(),\n  path = NULL,\n  scopes = \"https://www.googleapis.com/auth/drive\",\n  cache = gargle::gargle_oauth_cache(),\n  use_oob = gargle::gargle_oob_default(),\n  token = NULL\n)\n\n# list content\ndrive_ls()\n\nLa segunda opción, que usaremos en este curso, es instalar y cargar en el entorno un paquete de python, rpy2, que nos permite hacer interfaz con R. La ventaja de esta aproximación es que podemos montar nuestro drive muy fácilmente e iniciar una sesión de GRASS allí sin problemas. La desventaja es que, como no cambiamos el entorno de ejecución, en cada celda donde ejecutemos comando de R necesitamos escribir el comando mágico %%R para varias líneas de código o %R cuando es una única línea de código en R1.\n\n!pip install rpy2==3.5.1\n%reload_ext rpy2.ipython\n\nEsto será necesario para nuestra sesión de OBIA, en que para la clasificación de los objetos la función llama a R internamente, y también para la sesión de modelado de nicho con GRASS y R."
  },
  {
    "objectID": "unidad_5/grass_and_r_sdm.html#cargamos-los-paquetes-de-r",
    "href": "unidad_5/grass_and_r_sdm.html#cargamos-los-paquetes-de-r",
    "title": "R y GRASS: Modelado de nicho",
    "section": "Cargamos los paquetes de R",
    "text": "Cargamos los paquetes de R\n\n%%R\nlibrary(rgrass)\nlibrary(sf)\nlibrary(terra)\nlibrary(biomod2)\nlibrary(dismo)\nlibrary(usdm)\nlibrary(SDMtune)\nlibrary(zeallot)\nlibrary(tmap)\nlibrary(tmaptools)"
  },
  {
    "objectID": "trabajo_final.html#consigna",
    "href": "trabajo_final.html#consigna",
    "title": "Trabajo Integrador",
    "section": "Consigna",
    "text": "Consigna\nSe proponen 3 modalidades diferentes:\n\nInforme y presentación de trabajo final abordando algún problema/pregunta de su interés utilizando herramientas de GRASS GIS.\nTutorial abordando algún problema/pregunta de interés utilizando herramientas de GRASS GIS o demostrando el uso/aplicación de algún conjunto de módulos de GRASS.\n[Para valientes!] Desarrollo de una extension para GRASS GIS con algún flujo de trabajo que podría ser de interés para un amplio grupo de personas.\n\nEn todos los casos, el trabajo puede realizarse individualmente o en grupos de 2 integrantes.\n\n1. Informe\nEl informe debe abordar algún problema/pregunta de su interés utilizando herramientas que aprendimos durante el curso u otras de su interés disponibles en GRASS (ver módulos core y addons). Los trabajos deben incluir al menos los siguientes ítems:\n\nTítulo\nIntegrantes del equipo\nIntroducción (descripción breve de problema, presentando la pregunta de investigación - máximo 2 párrafos)\nObjetivo claro (i.e., orientado a los resultados que se desean obtener)\nDescripción de datos empleados\nDescripción de la metodología (incluyendo el código, se pueden incluir diagramas de flujo para ilustrar la metodología seguida)\nResultados (comentar los resultados más relevantes presentando mapas de salida, tablas y/o gráficos; los mapas deben contener como mínimo leyenda y escala)\nDiscusión y conclusiones (máximo 2 párrafos).\n\nSe entregará un informe de un máximo de 10 páginas en formato odt o pdf (letra tamaño 12). Se valorará la calidad del trabajo técnico, la pertinencia de los métodos utilizados y la calidad/claridad general de la presentación.\n\n\n\n\n\n\n\n\n\n2. Tutorial\nEscribir un tutorial del estilo de Working with i.landsat. Se puede optar por alguna temática o grupo de módulos de interés incluyendo cosas que no se hayan visto durante el curso pero se deseen aprender.\nEl tutorial debe estar escrito en Inglés y en formato de Jupyter Notebook, incluir una breve introducción, descripción/link a datos, código explicado paso a paso, resultados parciales y finales en forma de mapas, tablas o gráficos, una mínima discusión y referencias. El tutorial debe ser completamente reproducible.\nPara este trabajo requerirán crear una cuenta en GitHub, y un repositorio donde alojar la notebook.\n\n\n3. Extensión de GRASS\nLa idea de esta propuesta es ir un paso más allá de lo aprrendido en el curso e implementar algún flujo de trabajo de interés o tarea específica como si fuera una extensión de GRASS GIS.\nEn este taller ofrecido en el FOSS4G 2022 pueden encontrar una guía from zero to hero para desarrollar un addon para GRASS: Developing custom GRASS tools.\nPara esta propuesta también requerirán contar con una cuenta en GitHub donde se creará un repositorio para la extensión. El mismo debe denominarse como la extensión y contar con la estructura típica de las extensiones, i.e., el código (archivo.py), la documentación (archivo.html) y un archivo Makefile para la compilación del módulo. La documentación del módulo debe contar con un ejemplo que sea reproducible con los datos de muestra del proyecto North Carolina.\n\n\nPremio a los mejores trabajos\nSe seleccionará un trabajo de cada tipo de propuesta y se creará una noticia para ser publicada en el sitio web y las redes sociales de GRASS GIS. Pueden ver la noticia publicada luego del taller de 2021: https://grass.osgeo.org/news/2021_04_23_new_tutorials_made_by_students/.\n\n\nFecha de entrega\nEl plazo límite para la entrega de los trabajos en cualquiera de sus formatos es el día 29/09/2023 a las 18:00 via email a la docente."
  },
  {
    "objectID": "install_colab_and_mount_gdrive.html#ejecutar-comandos-de-r-en-the-whole-tale",
    "href": "install_colab_and_mount_gdrive.html#ejecutar-comandos-de-r-en-the-whole-tale",
    "title": "Instalar software en Colab",
    "section": "Ejecutar comandos de R en The Whole Tale",
    "text": "Ejecutar comandos de R en The Whole Tale\nAbrir la notebook de la unidad 5 directamente en RStudio dentro del Tale. Como está preparada para Colab, será necesario, además de adecuar algunas rutas a carpetas y archivos, cambiar las celdas o chunks de python a r y borrar el comando mágico %%R pues no será necesario."
  }
]