{
  "hash": "ad96e9851c7632e8679111bb8ad8f444",
  "result": {
    "markdown": "---\ntitle: Datos raster en GRASS GIS\nauthor: Verónica Andreo\ndate: today\nformat:\n  html:\n    code-tools: true\n    code-copy: true\n    code-fold: false\nexecute:\n  eval: false\n  cache: false\n  keep-ipynb: true\n---\n\n## Definición \n\nUn *mapa raster* es un arreglo de celdas en forma de grilla. Tiene filas y \ncolumnas y en cada celda hay un dato o un indicador de no-data (valor nulo). \nEn GRASS, los mapas raster pueden ser arreglos 2D o 3D.\n\n- Los límites se describen en los campos norte (n), sur (s), este (e) y oeste (w). \n- La extensión se calcula a partir de los límites externos de todas las celdas \ndel mapa.\n\n\n::: {.callout-note}\nPara más info ver la página \n[raster intro](https://grass.osgeo.org/grass-stable/manuals/rasterintro.html)\n:::\n\n\n## Precisión de datos raster\n\nLa precisión de los datos raster en GRASS, se clasifica en:\n\n- **CELL DATA TYPE:** un mapa raster de tipo ENTERO (sólo números enteros)\n- **FCELL DATA TYPE:** un mapa raster de tipo FLOTANTE (4 bytes, 7-9 dígitos de precisión)\n- **DCELL DATA TYPE:** un mapa raster de tipo DOBLE (8 bytes, 15-17 dígitos de precisión)\n\n::: {.callout-note}\nPara más info ver la wiki sobre \n[semántica de rasters](https://grasswiki.osgeo.org/wiki/GRASS_raster_semantics)\n:::\n\n\n## Reglas generales para los datos raster en GRASS\n\n- Los mapas raster de **salida u output** tienen sus *límites y resolución iguales a los de la región computacional* establecida.\n- Los mapas raster de **entrada o input** son automáticamente *cortados y reajustados a la región computacional*.\n- Mapas raster de **entrada o input** se enmascaran automáticamente si existe un\nmapa raster llamado *MASK* en el mapset.\n\n:::{.callout-warning title=\"Excepción\"}\nTodos los módulos **r.in.\\*** leen los datos celda por celda sin \nremuestreo y con su resolución y extensión originales -a menos que se especifique\nlo contrario.\n:::\n\n\n## NULL: valores nulos en GRASS GIS\n\n- **NULL** representa \"sin dato\" en los mapas raster\n- Operaciones con celdas NULL producen celdas NULL\n- Los valores NULL son gestionados con \n[r.null](https://grass.osgeo.org/grass-stable/manuals/r.null.html)\n\n```bash\n# establecer el valor no-data\nr.null map=mapname setnull=-9999\n\n# reemplazar NULL por un número \nr.null map=mapname null=256\n```\n\n\n## Máscaras en GRASS GIS\n\n- Se puede crear un mapa raster llamado *MASK* para enmascarar ciertas áreas, \ncomo por ejemplo el mar, los lagos, o el área por fuera de un polígono de \ninterés.\n- Todas las celdas que sean NULL en el mapa MASK serán ignoradas, del mismo modo\nque son ignoradas todas las celdas por fuera de la región computacional.\n- Las máscaras se gestionan con \n[r.mask](https://grass.osgeo.org/grass-stable/manuals/r.mask.html) o creando un \nraster con el nombre *MASK* via álgebra de mapas. \n- Los mapas vectoriales también pueden usarse como máscaras y se pueden \nestablecer máscaras inversas.\n\n![a- Raster *elevation* y vector *lakes*. b- Sólo los datos raster dentro de la máscara son usados para análisis posteriores. c- Máscara inversa.](../assets/img/masks.png)\n\nVeamos algunos ejemplos de cómo aplicar máscaras\n\n```bash\n# usar un vector como máscara\nr.mask vector=lakes\n\n# usar un vector como máscara inversa\nr.mask -i vector=lakes\n\n# enmascarar solo algunos valores de un mapa raster \nr.mask raster=landclass96 maskcats=\"5 thru 7\"\n\n# crear un raster MASK\nr.mapcalc expression=\"MASK = if(elevation < 100, 1, null())\"\n\n# remover la máscara\nr.mask -r\n```\n\nUna máscara sólo se aplica realmente cuando se lee un mapa raster, \nes decir, cuando se usa como entrada en un módulo.\n\nVeamos un ejemplo:\n\n```bash\ng.region -p raster=elevation\nr.mask -i vector=lakes\nr.grow.distance -n input=elevation distance=distance\nr.mask -r\n```\n\n![a- Máscara activa. b- Máscara desactivada.](../assets/img/mask_applied_vs_mask_removed.png){width=70%}\n\n```bash\nr.mask -i vector=lakes\nr.out.gdal input=distance output=distance.tif\nqgis distance.tif\n```\n\n![Máscara leída al exportar](../assets/img/mask_read_when_exporting.png){width=70%}\n\n\n### Región computacional\n\n- La **región computacional** está definida en función de la extensión dada por \nlos límites norte, sur, este y oeste y una resolución espacial. \n*Aplica únicamente a las operaciones con datos raster.* \n- La **región de un mapa raster** está definida por la extensión del mapa y la \nresolución del mapa. Cada mapa raster tiene su región, pero la región computacional\ntiene precedencia. \n- La **región de visualizacion** es la extensión del *map display* independiente\nde la región computacional y la región del mapa raster. \n\n![](../assets/img/region.png)\n\nLa región computacional puede definirse y modificarse mediante el módulo <a href=\"https://grass.osgeo.org/grass-stable/manuals/g.region.html\">g.region</a> \na la extensión de un mapa vectorial, un raster o manualmente a alguna zona de \ninterés. También puede establecerse a la extensión de un vector y alinear la\nresolución a un determinado mapa raster. Por ejemplo:\n\n\n```{bash}\ng.region -p vector=lakes align=elevation\n```\n\n\nPor otra, es posible establecer la región computacional a partir de la región de \nvisualización y guardarla con un nombre para luego volver a aplicarla.\n\n![](../assets/img/save_region_from_display.png){width=60% fig-align=\"center\"}\n\n\n## Importar/exportar, máscara y región\n\n- **r.in.\\*** y **r.import** importan siempre el mapa completo (a menos que se \nestablezca el recorte a la región). Luego, es posible establecer la región a la \nresolución (y extensión) del mapa con `g.región -p raster=mapname`.\n- **r.out.\\*** exportan mapas raster según la definición de la región computacional \n(extensión y resolución) y respetan la máscara si está presente. Se aplica \ninterpolación por vecino más cercano por defecto.\n\n:::{.callout-important}\n**En la importación y la exportación, los mapas vectoriales se consideran siempre en toda su extensión.**\n:::\n\n\n## Reportes y estadísticas de mapas raster\n\nExisten diversos módulos que nos permiten generar reportes y estadísticas de \nlos mapas raster. Algunos de los más usados son:\n\n- [r.report](https://grass.osgeo.org/grass-stable/manuals/r.report.html): reporta área y número de celdas de un mapa raster\n- [r.coin](https://grass.osgeo.org/grass-stable/manuals/r.coin.html): reporta la matriz o tabla de coincidencia entre dos mapas raster\n- [r.univar](https://grass.osgeo.org/grass-stable/manuals/r.univar.html): calcula estadísticas descriptivas a partir de las celdas no nulas de un mapa raster\n- [r.stats](https://grass.osgeo.org/grass-stable/manuals/r.stats.html): calcula el área de cada una de las categorías o intervalos de un mapa raster\n- [r.statistics](https://grass.osgeo.org/grass-stable/manuals/r.statistics.html) y [r.stats.zonal](https://grass.osgeo.org/grass-stable/manuals/r.stats.zonal.html): estadística zonal\n- [r.neighbors](https://grass.osgeo.org/grass-stable/manuals/r.neighbors.html): estadística local basada en las celdas vecinas\n\nVeamos algunos ejemplos:\n\n```bash\n# reportes\nr.report map=zipcodes,landclass96 units=h,p\nr.coin first=zipcodes second=landclass96 units=p\n\n# estadísticas descriptivas\nr.univar map=elevation\n\n# estadística zonal: elevacion promedio por código postal\nr.stats.zonal base=zipcodes cover=elevation method=average output=zipcodes_elev_avg\n```\n\n\n## Álgebra de mapas raster\n\nEl módulo [r.mapcalc](https://grass.osgeo.org/grass-stable/manuals/r.mapcalc.html) \nnos permite realizar múltiples operaciones entre mapas. Así, podemos crear \nnuevos mapas ráster que sean expresiones aritméticas en las que intervengan \nmapas ráster existentes, constantes enteras o de punto flotante y funciones.\n\n![](../assets/img/r_mapcalc_gui.png){width=\"70%\" fig-align=\"center\"}\n\n\n### Operadores\n\nLos operadores se aplican de izquierda a derecha, aplicándose los de mayor \nprecedencia antes que los de menor precedencia. La división por 0 y el módulo \npor 0 son aceptables y dan un resultado NULL. Los operadores lógicos dan un \nresultado 1 si la comparación es verdadera, 0 en caso contrario.\n\n:::{style=\"font-size: 0.8em;\"}\n| Operator  | Meaning                   | Type        |\n|-----------|---------------------------|-------------|\n| -         | negation                  | Arithmetic  |\n| ~         | one's complement          | Bitwise     |\n| !         | not                       | Logical     |\n| ^         | exponentiation            | Arithmetic  |\n| %         | modulus                   | Arithmetic  |\n| /         | division                  | Arithmetic  |\n| *         | multiplication            | Arithmetic  |\n| +         | addition                  | Arithmetic  |\n| -         | subtraction               | Arithmetic  |\n| <<        | left shift                | Bitwise     |\n| >>        | right shift               | Bitwise     |\n| >>>       | right shift (unsigned)    | Bitwise     |\n| >         | greater than              | Logical     |\n| >=        | greater than or equal     | Logical     |\n| <         | less than                 | Logical     |\n| <=        | less than or equal        | Logical     |\n| ==        | equal                     | Logical     |\n| !=        | not equal                 | Logical     |\n| &         | bitwise and               | Bitwise     |\n| \\|        | bitwise or                | Bitwise     |\n| &&        | logical and               | Logical     |\n| &&&       | logical and[^1]           | Logical     |\n| \\|\\|      | logical or                | Logical     |\n| \\|\\|\\|    | logical or[^1]            | Logical     | \n|?:         | conditional               | Logical     |\n:::\n\n[^1]: The &&& and ||| operators handle null values differently to other operators. \nSee the section entitled \n[NULL support](https://grass.osgeo.org/grass83/manuals/r.mapcalc.html#null-support) \nin the manual for more details.\n\n\n### Operador vecinos o índices **[row,col]**\n\nLos mapas y las imágenes son matrices bidimensionales. En r.mapcalc, los mapas \npueden ir seguidos de un modificador de vecindad que especifica un desplazamiento\nrelativo desde la celda actual que se está evaluando. El formato es map[r,c], \ndonde r es el desplazamiento de fila y c es el desplazamiento de columna. Por\nejemplo, map[1,2] se refiere a la celda situada una fila por debajo y dos \ncolumnas a la derecha de la celda actual, map[-2,-1] se refiere a la celda \nsituada dos filas por encima y una columna a la izquierda de la celda actual, \ny map[0,1] se refiere a la celda situada una columna a la derecha de la celda \nactual. Esta sintaxis permite desarrollar filtros de vecindad dentro de un \nmismo mapa o en varios mapas.\n\n```bash\n# ejemplo filtro de paso bajo con operador de vecinos\nr.mapcalc \\\nexpression=\"lsat7_2002_10_smooth = (lsat7_2002_10[-1,-1] + \n\t\t\t\t\t\t\t\t\tlsat7_2002_10[-1,0] + \n\t\t\t\t\t\t\t\t\tlsat7_2002_10[1,1] + \n\t\t\t\t\t\t\t\t\tlsat7_2002_10[0,-1] + \n\t\t\t\t\t\t\t\t\tlsat7_2002_10[0,0] + \n\t\t\t\t\t\t\t\t\tlsat7_2002_10[0,1] + \n\t\t\t\t\t\t\t\t\tlsat7_2002_10[1,-1] + \n\t\t\t\t\t\t\t\t\tlsat7_2002_10[1,0] + \n\t\t\t\t\t\t\t\t\tlsat7_2002_10[1,1]) / 9\"\n```\n\nPodemos comparar con la herramienta mapswipe, por ejemplo: \n\n```bash\ng.gui.mapswipe first=lsat7_2002_10 second=lsat7_2002_10_smooth\n```\n\n![](../assets/img/neighbour_operator_mapswipe.png){width=\"75%\" fig-align=\"center\"}\n\n\n### Funciones\n\nLas funciones actualmente admitidas se enumeran en la tabla siguiente. \nEl tipo del resultado se indica en la última columna. F significa que las \nfunciones siempre dan como resultado un valor de coma flotante, I significa \nque la función da un resultado entero, y * indica que el resultado es flotante\nsi alguno de los argumentos de la función son valores de coma flotante y entero \nsi todos los argumentos son enteros.\n\n![](../assets/img/r_mapcalc_functions.png){width=\"60%\" fig-align=\"center\"}\n\n\n### Cláusula *if*\n\n```bash\n# Ejemplo: \n# Determinar las zonas forestales situadas por encima \n# de una cierta elevación\n\n# establecer la región computacional\ng.region rast=landclass96\n\n# reportar las clases de cobertura\nr.report map=landclass96 units=p\n\n# estadística univariada del mapa de elevacion\nr.univar map=elevation\n\n# seleccionar áreas > 120m y con bosque\nr.mapcalc expression=\"forest_high = if(elevation > 120 && landclass96 == 5, 1, null())\"\n```\n\n## Resampleo e interpolacion\n\nEl procesamiento de mapas raster de GRASS se realiza siempre en la configuración\nactual de la región, es decir, se utiliza la extensión y resolución actual de la\nregión. Si la resolución de la región difiere de la del mapa(s) raster de entrada,\nse realiza un remuestreo sobre la marcha (remuestreo del vecino más cercano). \nSi no se desea, los mapas de entrada deben remuestrearse previamente con uno de \nlos módulos específicos.\n\nLos siguientes módulos están disponibles para la reinterpolación de mapas raster \n\"rellenos\" (datos continuos) a una resolución diferente:\n\n- r.resample utiliza el remuestreo incorporado, por lo que debería producir \nresultados idénticos al remuestreo sobre la marcha realizado a través de los \nmódulos de importación raster.\n- r.resamp.interp remuestreo con el método del vecino más cercano, bilineal y \nbicúbico. Para r.resamp.interp method=bilinear y method=bicubic, los valores \nráster se tratan como muestras en el centro de cada celda ráster, definiendo \nuna superficie continua a trozos. Los valores raster resultantes se obtienen \nmuestreando la superficie en el centro de cada celda de la región. Como el \nalgoritmo sólo interpola, y no extrapola, se pierde un margen de 0,5 \n(para bilineal) o 1,5 (para bicúbica) celdas de la extensión de la trama \noriginal. Cualquier muestra tomada dentro de este margen será nula.\n- r.resamp.rst (Regularized Spline with Tension - RST): Se comporta de forma \nsimilar, es decir, calcula una superficie asumiendo que los valores son muestras\nen el centro de cada celda del raster, y muestrea la superficie en el centro \nde cada celda de la región.\n- r.resamp.bspline Interpolación spline bicúbica o bilineal con regularización \nTykhonov.\n- Para r.resamp.stats sin -w, el valor de cada celda de región es el agregado \nelegido de los valores de todas las celdas ráster cuyos centros caen dentro de \nlos límites de la celda de región. Con -w, las muestras se ponderan de acuerdo \ncon la proporción de la celda ráster que cae dentro de los límites de la celda \nde la región, por lo que el resultado normalmente no se ve afectado por el error\nde redondeo.\n- r.fillnulls para el relleno de agujeros (por ejemplo, SRTM DEM).\n\nAdemás, hay módulos disponibles para la reinterpolación de mapas \"dispersos\" \n(puntos o líneas dispersos):\n\n- Interpolación de la media ponderada de la distancia inversa (IDW) (r.surf.idw)\n- Interpolación a partir de curvas de nivel (r.contour)\n- Varios módulos vectoriales para la interpolación: v.surf.*\n- Para datos Lidar y similares, r.in.pdal y r.in.xyz permiten cargar y agrupar \ndatos ASCII x,y,z sin cuadricular en un nuevo mapa ráster. El usuario puede \nelegir entre diversos métodos estadísticos para crear el nuevo mapa de trama.\n\n\n## Parcheo y agregaciones temporales\n\n- [r.patch](https://grass.osgeo.org/grass-stable/manuals/r.patch.html): Crea un \nmapa raster utilizando los valores de las categorías de uno (o más) mapa(s) para\nrellenar las áreas \"sin datos\" en otro mapa\n\n![Parcheo de mapas raster](../assets/img/r_patch.png){width=80%}\n\n- [r.series](https://grass.osgeo.org/grass-stable/manuals/r.series.html): \nPermite agregar una lista de mapas con diferentes métodos como promedio, mínimo,\nmáximo, etc.\n\n![Operaciones con varios mapas raster](https://grass.osgeo.org/grass83/manuals/r_series.png)\n\n\n## Correlación, regresión simple y múltiple\n\n- [r.covar](https://grass.osgeo.org/grass-stable/manuals/r.covar.html): matriz \nde covarianza o correlación entre mapas raster\n- [r.regression.line](https://grass.osgeo.org/grass-stable/manuals/r.regression.line.html): \nregresión lineal simple\n- [r.regression.multi](https://grass.osgeo.org/grass-stable/manuals/r.regression.multi.html): \nregresión lineal múltiple\n\n\n```bash\n# correlación\ng.region raster=elevation\nr.covar -r map=elevation,aspect,slope\n\n# regresión simple\ng.region raster=elev_srtm_30m -p\nr.regression.line mapx=elev_ned_30m mapy=elev_srtm_30m \n\n# regresión múltiple\ng.region raster=soils_Kfactor -p\nr.regression.multi mapx=elevation,aspect,slope mapy=soils_Kfactor \\\n  residuals=soils_Kfactor.resid estimates=soils_Kfactor.estim\n```\n\n## Compresión de datos\n\nTodos los tipos de mapas raster de GRASS GIS están por defecto comprimidos con \nZSTD si la librería está disponible, de lo contrario se usa ZLIB. \nEl método de compresión se establece a través de la variable de ambiente \n`GRASS_COMPRESSOR`. Los métodos disponibles son: RLE, ZLIB, LZ4, BZIP2, o ZSTD.\n\nImportante: la compresión de archivos NULL puede ser desactivada con export \nGRASS_COMPRESS_NULLS=0. La compresión de archivos NULL para un mapa raster en\nparticular puede ser manejada con `r.null -z`.\n\nLos mapas raster de punto flotante (FCELL, DCELL) nunca usan compresión RLE; \nson comprimidos con ZLIB, LZ4, BZIP2, ZSTD o sin compresión.\n\nLa descompresión está controlada por el módulo \n[r.compress](https://grass.osgeo.org/grass-stable/manuals/r.compress.html), \nno por la variable de entorno.\n\n",
    "supporting": [
      "raster_data_in_grass_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}