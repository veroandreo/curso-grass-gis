{
  "hash": "749e5b13f7005e5c2c34704b8802c243",
  "result": {
    "markdown": "---\ntitle: Python y GRASS GIS\nauthor: Verónica Andreo\ndate: today\nformat:\n  html:\n    code-tools: true\n    code-copy: true\n    code-fold: false\nexecute:\n  eval: false\n  cache: false\n  keep-ipynb: true\n---\n\nEn esta notebook, nos vamos a introducir en el uso de GRASS GIS con Python. Para \nello, primero vamos a recorrer brevemente los principales paquetes/librerías de \npython que son parte de GRASS y nos permiten ejcutar sus funciones, a la vez que\npodemos combinar las salidas con otras librerías más tradicionales de python.\n\n\n### ¿Por qué Jupyter Notebooks y cómo usarlas?\n\nLas Jupyter Notebook son aplicaciones servidor-cliente que permiten que el \ncódigo escrito en un documento de cuaderno sea\n**editado y ejecutado a través de un navegador web**. \nPueden ejecutarse en un ordenador local (sin necesidad de acceso a Internet) o \nutilizarse para controlar cálculos en un servidor remoto al que se accede a \ntravés de Internet ([véase la documentación](https://jupyter-notebook-beginner-guide.readthedocs.io/en/latest/what_is_jupyter.html)).\n\nLas Jupyter Notebooks pueden ser interactivas y permiten combinar código, texto \nexplicativo y resultados computacionales en un único documento. En general, son:\n\n* convenientes para el desarrollo inicial de código (prototipado)\n* ideales para la segmentación de código, con la posibilidad de volver a \nejecutar celdas\n* capaces de almacenar valores de variables de celdas ya ejecutadas\n\nLa notebook puede guardarse como un script ejecutable de Python además del \nformato nativo `.ipynb`, o exportarse a varios formatos de documentación \ncomo PDF o Sphinx RST con un bonito estilo.\n\n#### Edición y uso interactivo\n\nEditar una Jupyter Notebook es muy fácil: en el navegador web, puedes navegar \nentre celdas de texto o código utilizando el ratón o atajos de teclado (ver \nMenú > Ayuda > Atajos de teclado). Se pueden ejecutar pequeños fragmentos de \ncódigo celda por celda, guardar la notebook en su estado actual, o \nmodificar y recalcular celdas o devolverlas a su estado anterior. \nAdemás de las celdas de código ejecutables, se puede utilizar Markdown en las \nceldas de documentación para hacerlas presentables a los demás.\n\n# Paquetes de Python en GRASS\n\n## `grass.script`\n\nEl paquete **grass.script** o *GRASS GIS Python Scripting Library* provee \nfunciones para llamar módulos de GRASS dentro de scripts o rutinas Python. \nLas funciones más comúnmente usadas incluyen:\n\n- `run_command`: usada cuando la salida de los módulos es un raster o vector, \nno se espera una salida de tipo texto.\n- `read_command`: se utiliza cuando la salida de los módulos es de tipo texto.\n- `parse_command`: se utiliza con módulos cuya salida puede convertirse en \npares `key=value` o diccionarios.\n- `write_command`: se utiliza con módulos que esperan una entrada de texto, \nya sea en forma de archivo o desde stdin.\n\nEste paquete también proporciona varias funciones de *wrapping* para módulos de \nuso muy frecuente en GRASS, por ejemplo:\n\n- Para obtener información de un raster, se utiliza \nscript.raster.raster_info(): `gs.raster_info('elevation')`\n- Para obtener información de un vector, se utiliza \nscript.vector.vector_info(): `gs.vector_info('roadsmajor')`\n- Para listar mapas de diferente tipo en un mapset, se utiliza \nscript.core.list_grouped(): `gs.list_grouped(type=['raster'])`\n- Para obtener la región computacional, se utiliza script.core.region():\n`gs.region()`\n\n:::{.callout-note}\nPara más detalles, ver la documentación del paquete en: \n<https://grass.osgeo.org/grass-stable/manuals/libpython/script_intro.html>\n:::\n\n## `grass.jupyter`\n\nLa librería **grass.jupyter** mejora la integración de GRASS y Jupyter, y \nproporciona diferentes clases para facilitar la visualización de mapas de GRASS\nen el entorno Jupyter. Este paquete fue desarrollado por @haedrich_grass_jupyter \ncomo parte de su proyecto para \n[Google Summer of Code](https://summerofcode.withgoogle.com/) y con una \n[student grant](https://grasswiki.osgeo.org/wiki/Student_Grants) de GRASS. \n\nLas classes más importantes son:\n\n- `init`: inicia una sesión de GRASS y configura todas las variables de entorno\nnecesarias para ejecutar GRASS desde Python y dentro de una Notebook.\n- `Map`: renderiza mapas 2D\n- `Map3D`: renderiza mapas 3D\n- `InteractiveMap`: permite la visualización interactiva utilizando la librería\n[`folium`](https://python-visualization.github.io/folium/)\n- `TimeSeriesMap`: permite la visualización de datos espacio-temporales\n\n:::{.callout-note}\nPara más detalles, ver la documentación del paquete en: \n<https://grass.osgeo.org/grass-stable/manuals/libpython/grass.jupyter.html>\n:::\n\n## `grass.pygrass`\n\nPyGRASS es una interfaz de programación de aplicaciones (API) de Python \norientada a objetos para GRASS GIS desarrollada por @zambelli_pygrass_2013. \nPyGRASS ofrece interfaces a los módulos y funcionalidades de GRASS, así como\na los datos vectoriales y ráster, de modo que permite acceder a cada minima \nunidad y desarrollar nuevos módulos con funciones de más bajo nivel. \nPyGRASS mejora la integración entre GRASS GIS y Python, haciendo el uso de \nPython bajo GRASS más consistente con el lenguaje mismo. \nAdemás, simplifica el scripting y la programación de GRASS y lo hace más \nnatural para el usuario.\n\nDentro de esta librería, vamos a usar especialmente \n`grass.pygrass.modules.shorcuts` que nos permite llamar a los módulos\no funciones de GRASS de forma muy parecida a cómo lo haríamos en la consola de \nGRASS.\n\n:::{.callout-note}\nPara más detalles, ver la documentación del paquete en: \n<https://grass.osgeo.org/grass-stable/manuals/libpython/pygrass_index.html>\n:::\n\n## Otras librerías Python en GRASS GIS\n\n### Temporal framework\n\nEl *GRASS GIS Temporal Framework* implementa la funcionalidad SIG temporal de \nGRASS GIS y proporciona una API para implementar módulos de procesamiento \nespacio-temporal. El framework introduce conjuntos de datos espacio-temporales\nque representan series temporales de mapas raster, raster 3D o vectoriales. \nEste marco proporciona las siguientes funcionalidades:\n\n- Asignación de marcas de tiempo a mapas y registro de mapas en la base de datos temporal\n- Modificación de marcas de tiempo\n- Creación, cambio de nombre y supresión de conjuntos de datos espacio-temporales\n- Registro y anulación del registro de mapas en conjuntos de datos espacio-temporales\n- Consulta de mapas registrados en conjuntos de datos espacio-temporales mediante SQL\n- Análisis de la topología espacio-temporal de los conjuntos de datos espacio-temporales\n- Muestreo de conjuntos de datos espacio-temporales\n- Cálculo de las relaciones temporales y espaciales entre los mapas registrados\n- Funciones de nivel superior compartidas entre módulos\n\n:::{.callout-note}\nPara más detalles, ver la documentación de la librería en: \n<https://grass.osgeo.org/grass-stable/manuals/libpython/temporal_framework.html>\n:::\n\n### Testing framework\n\nEl *GRASS GIS Testing framework* está basado en el paquete `unittest` de Python \ncon un gran número de mejoras, extensiones y cambios específicos ajustados a \nGRASS. Estos cambios incluyen la creación de reportes de pruebas HTML compatibles\ncon GRASS, o la ejecución de pruebas de manera que las terminaciones de procesos\npotencialmente causadas por funciones de la librería C no influyan en el proceso\nprincipal de pruebas.\n\nAlgunas pruebas se ejecutarán sin ningún dato, pero muchas pruebas requieren \nla versión básica de los [datos de muestra](https://grass.osgeo.org/sampledata/north_carolina/nc_basic_spm_grass7.zip) \npara Carolina del Norte.\n\n:::{.callout-note}\nPara más detalles, ver la documentación de la librería en: \n<https://grass.osgeo.org/grass-stable/manuals/libpython/gunittest_testing.html>\n:::\n\n# Ejemplos con cada paquete\n\nPrimero, iniciemos una sesión de GRASS GIS. Necesitamos definir la ruta hasta \nun mapset, por lo tanto vamos a usar los datos de muestra de GRASS, i.e., el \nsample dataset de North Carolina. \n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport os\n\n# data directory\nhomedir = os.path.expanduser('~')\n\n# GRASS GIS database variables\ngrassdata = os.path.join(homedir, \"grassdata\")\nproject = \"nc_spm_08_grass7\"\nmapset = \"PERMANENT\"\n```\n:::\n\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\n# import standard Python packages we need\nimport sys\nimport subprocess\n\n# ask GRASS GIS where its Python packages are to be able to run it from the notebook\nsys.path.append(\n    subprocess.check_output([\"grass\", \"--config\", \"python_path\"], text=True).strip()\n)\n```\n:::\n\n\nAhora sí, estamos listos para importar los paquetes de GRASS e iniciar una\nsesión:\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\n# import the GRASS GIS packages we need\nimport grass.script as gs\nimport grass.jupyter as gj\n\n# Start the GRASS GIS Session\nsession = gj.init(grassdata, project, mapset)\n```\n:::\n\n\nNotar que iniciamos sesión con `gj.init()`. No obstante, también podríamos usar\n`session = gs.setup.init(\"~/grassdata/nc_spm_08_grass7/PERMANENT\")`.\n\nCorroboramos que GRASS inició correctamente:\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\n# show current GRASS GIS settings, this also checks if the session works\ngs.gisenv()\n```\n:::\n\n\n## Ejemplos con `grass.script`\n\nListamos los mapas raster del mapset PERMANENT:\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nlista = gs.list_grouped(type = \"raster\")[\"PERMANENT\"]\nlista[:5]\n```\n:::\n\n\nObtenemos info de un mapa raster:\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\ngs.raster_info(\"aspect\")[\"cols\"]\n```\n:::\n\n\n:::{.callout-caution title=\"Tarea\"}\nAhora, hagamos lo mismo pero para los mapas de tipo vectorial.\n:::\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\n# gs.list_grouped(type = \"vector\")\n```\n:::\n\n\nImprimimos la region computacional actual:\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\ngs.region()\n```\n:::\n\n\nCambiamos la región computacional al vector `urbanarea`:\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\ngs.region_env(vector=\"urbanarea\")\n```\n:::\n\n\nVerificamos los atributos del vector seleccionado:\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\ngs.vector_db_select('urbanarea').values()\n```\n:::\n\n\nExtraemos el área urbana de Raleigh:\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\ngs.run_command(\"v.extract\", \n               input=\"urbanarea\", \n               where=\"NAME == 'Raleigh'\", \n               output=\"urban_area_raleigh\")\n```\n:::\n\n\nListamos los vectores por un patrón:\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\ngs.list_grouped(type=\"vector\", pattern=\"urban*\")\n```\n:::\n\n\nVerificamos los atributos del nuevo vector creado:\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\ngs.vector_db_select(\"urban_area_raleigh\")\n```\n:::\n\n\ny obtenemos información sobre el mismo. Notar que podemos seleccionar qué \ninformación queremos extraer, i.e., la salida es un diccionario.\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\n# show attributes\ngs.vector_info(\"urban_area_raleigh\")\n```\n:::\n\n\nUsamos otra manera de establecer la región computacional:\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\nregion = gs.parse_command(\"g.region\", \n                          vector=\"urban_area_raleigh\", \n                          flags=\"g\")\nregion\n```\n:::\n\n\n## Ejemplos con `grass.jupyter`\n\nAhora vamos a demostrar el uso de las dos clases más comunes del paquete \n`grass.jupyter` para graficar mapas. Usamos primeramente la clase interactiva\nque nos permite mostrar nuestras salidas sobre mapas base como el de\nOpenStreetMap, por ejemplo.\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\nraleigh_map = gj.InteractiveMap(width = 500, use_region=True, tiles=\"OpenStreetMap\")\nraleigh_map.add_raster(\"elevation\")\nraleigh_map.add_vector(\"urban_area_raleigh\")\nraleigh_map.add_layer_control(position = \"bottomright\")\nraleigh_map.show()\n```\n:::\n\n\nA continuación, creamos una salida estática, utilizando la clase `Map`. Esta \nsalida es similar a utilizar el Map Display en la GUI y exportar el resultado.\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\nraleigh_map = gj.Map(width=500)\nraleigh_map.d_rast(map=\"elevation\")\nraleigh_map.d_vect(map=\"lakes\")\nraleigh_map.d_legend(raster=\"elevation\", \n                     title=\"Height (m)\", \n                     fontsize=10, \n                     at=(70, 90, 80, 90), \n                     flags=\"b\")\nraleigh_map.d_barscale()\nraleigh_map.show()\n```\n:::\n\n\n## Ejemplos con `grass.pygrass`\n\nFinalmente, vamos a ejemplificar el uso de la interfaz `modules` dentro de \n`grass.pygrass`. Si bien esta interfaz nos permite ejecutar comandos de GRASS\ncasi como si los ejecutásemos en la terminal, las salidas no están optimizadas\npara ser usadas como entrada para otros comandos. Para ello, es más conveniente\nusar `grass.script` o funciones de más bajo nivel de `grass.pygrass` que permiten\nacceder a los componentes básicos de los objetos dentro de GRASS. \n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\nfrom grass.pygrass.modules.shortcuts import general as g\nfrom grass.pygrass.modules.shortcuts import raster as r\nfrom grass.pygrass.modules.shortcuts import vector as v\n```\n:::\n\n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\ng.region(flags=\"p\")\n```\n:::\n\n\n::: {.cell execution_count=20}\n``` {.python .cell-code}\nv.info(map=\"roadsmajor\")\n```\n:::\n\n\n::: {.cell execution_count=21}\n``` {.python .cell-code}\nr.report(map=\"elevation\", nsteps=\"10\", quiet=True)\n```\n:::\n\n\n# Otras notebooks demostrando el uso de GRASS con Python\n\n- <https://github.com/OSGeo/grass/tree/main/doc/notebooks>\n- <https://grasswiki.osgeo.org/wiki/GRASS_GIS_Jupyter_notebooks>\n\n\n# Referencias\n\n::: {#refs}\n:::\n\n",
    "supporting": [
      "python_and_grass_files"
    ],
    "filters": [],
    "includes": {}
  }
}