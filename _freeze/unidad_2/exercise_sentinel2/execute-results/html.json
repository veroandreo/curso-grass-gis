{
  "hash": "b041553a461720bd40ad8a417663b31a",
  "result": {
    "markdown": "---\ntitle: 'Ejercicio: Datos satelitales en GRASS GIS'\nauthor: Verónica Andreo\ndate: today\nformat:\n  html:\n    code-tools: true\n    code-copy: true\n    code-fold: false\nexecute:\n  eval: false\n  cache: false\n  keep-ipynb: true\n---\n\nEn este ejercicio, trabajaremos con imágenes del satélite Sentinel 2 en GRASS\nGIS.\nVamos a recorrer algunos módulos específicos para la búsqueda, descarga e\nimportación de datos Sentinel, abordar los diferentes pasos a seguir en\nfunción del nivel de procesamiento, enmascarar nubes y sombras de nubes,\nrealizar segmentaciones y clasificaciones supervisadas.\n\nAntes de empezar y para ganar tiempo, conectamos nuestro drive e instalamos \nGRASS en Google Colab.\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\n# import drive from google colab\nfrom google.colab import drive\n# mount drive\ndrive.mount(\"/content/drive\")\n```\n:::\n\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\n%%bash\nDEBIAN_FRONTEND=noninteractive \nsudo add-apt-repository ppa:ubuntugis/ubuntugis-unstable \napt update \napt install grass subversion grass-dev\napt remove libproj22\n```\n:::\n\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\n!grass --config path\n```\n:::\n\n\n## Datos Sentinel 2\n\n:::: columns\n:::{.column width=\"55%\"}\n- Lanzamiento: Sentinel-2A en 2015, Sentinel-2B en 2017\n- Tiempo de revisita: ~5 días\n- Cobertura sistemática de áreas terrestres y costeras entre los 84°N y 56°S\n- 13 bandas espectrales con resolución espacial de 10 m (VIS y NIR), 20 m (red-edge y SWIR) y 60 m (otras)\n:::\n\n:::{.column width=\"5%\"}\n:::\n\n:::{.column width=\"40%\"}\n![](../assets/img/sentinel2.jpg)\n:::\n::::\n\n![ESA - Satélites Copernicus Sentinel. Más información en: \n<https://www.copernicus.eu/en/about-copernicus/infrastructure/discover-our-satellites>](../assets/img/sentinel_satellites.jpg)\n\n\n![Distribución de bandas de Sentinel 2 comparadas con Landsat](../assets/img/landsat_and_sentinel_bands.png)\n\n### Niveles de procesamiento Sentinel 2\n\n- **L1C**: Reflectancia a tope de atmósfera o Top of Atmosphere (TOA). \nDisponibles desde el lanzamiento.\n- **L2A**: Reflectancia Superficial o Bottom of Atmosphere (BOA), i.e., los \ndatos han sido corregidos para remover los efectos de la atmósfera. Sólo desde 2019.\n\n:::{.callout-important}\n**Long Term Archive (LTA)**\n\nTodos los productos (1C o 2A) de más de un año son movidos fuera de línea \ny se requiere un tiempo de espera para ponerlos a disposición del usuario. \nEsto dificulta la automatización de tareas con productos de más de 12 \nmeses de antigüedad. \n:::\n\n## Extensiones de GRASS para datos Sentinel\n\n- [i.sentinel.download](https://grass.osgeo.org/grass7/manuals/addons/i.sentinel.download.html): descarga productos Copernicus Sentinel de Copernicus Open Access Hub\n- [i.sentinel.import](https://grass.osgeo.org/grass7/manuals/addons/i.sentinel.import.html): importa datos Sentinel descargados de Copernicus Open Access Hub\n- [i.sentinel.preproc](https://grass.osgeo.org/grass7/manuals/addons/i.sentinel.preproc.html): importa y realiza corrección atmosférica y topográfica de imágenes S2\n- [i.sentinel.mask](https://grass.osgeo.org/grass7/manuals/addons/i.sentinel.mask.html): crea máscaras de nubes y sombras para imágenes S2\n- [i.sentinel.coverage](https://grass.osgeo.org/grass-stable/manuals/addons/i.sentinel.coverage.html): comprueba la cobertura de área de las escenas de S1 o S2 seleccionadas\n- [i.sentinel.parallel.download](https://grass.osgeo.org/grass-stable/manuals/addons/i.sentinel.parallel.download.html): descarga imagenes Sentinel en paralelo\n\nPara conectarse al [Copernicus Open Access Hub](https://scihub.copernicus.eu/) \na través de \n[i.sentinel.download](https://grass.osgeo.org/grass7/manuals/addons/i.sentinel.download.html), \nse necesita ser usuario \n[registrado](https://scihub.copernicus.eu/dhus/#/self-registration).\n\nCada participante necesita registrarse y crear el archivo *`SENTINEL_SETTING.txt`* \nen el directorio *`$HOME/gisdata/`* con el siguiente contenido:\n\n```\nyour_username\nyour_password\n```\n\n## Manos a la obra\n\n### Iniciamos GRASS\n\nIniciar GRASS GIS, crear nuevo mapset y establecer región computacional\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nimport os\n\n# data directory\nhomedir = \"/content/drive/MyDrive/curso_grass_2023\"\n\n# GRASS GIS database variables\ngrassdata = os.path.join(homedir, \"grassdata\")\nproject = \"posgar2007_4_cba\"\nmapset = \"PERMANENT\"\n```\n:::\n\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nimport subprocess\nimport sys\n\n# Ask GRASS GIS where its Python packages are to be able to start it from the notebook\nsys.path.append(\n    subprocess.check_output([\"grass\", \"--config\", \"python_path\"], text=True).strip()\n)\n```\n:::\n\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\n# Importar los paquetes python de GRASS\nimport grass.script as gs\nimport grass.jupyter as gj\n\n# Iniciar GRASS\nsession = gj.init(grassdata, project, mapset)\n```\n:::\n\n\nPara trabajar con los datos de Sentinel 2 en esta sesión, creamos un nuevo mapset \ny lo llamamos **sentinel2**.\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\n# Create a new mapset\ngs.run_command(\"g.mapset\",\n               mapset=\"sentinel2\",\n               flags=\"c\")\n```\n:::\n\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\n# Check accessible mapsets\ngs.run_command(\"g.mapsets\",\n               flags=\"p\")\n```\n:::\n\n\nAl igual que en la sesión anterior y como haremos cada vez que iniciemos un \nproyecto, primero definimos la región computacional. En este caso, vamos a usar\nel radio urbano de Córdoba que extrajimos en la sesión anterior.\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\n# Add mapset landsat8 to the path\ngs.run_command(\"g.mapsets\",\n               mapset=\"landsat8\",\n               operation=\"add\")\n```\n:::\n\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\n# List vector maps\ngs.list_grouped(type=\"vector\")\n```\n:::\n\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\n# set the computational region to the extent of Cordoba urban area\ngs.run_command(\"g.region\",\n               vector=\"radio_urbano_cba\",\n               flags=\"p\")\n```\n:::\n\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\n# display radio_urbano_cba vector\ncba_map = gj.InteractiveMap(width = 500, use_region=True, tiles=\"OpenStreetMap\")\ncba_map.add_vector(\"radio_urbano_cba\")\ncba_map.add_layer_control(position = \"bottomright\")\ncba_map.show()\n```\n:::\n\n\n### Búsqueda y descarga de datos S2\n\nInstalamos la caja de herramientas `i.sentinel` que consta de varios módulos que \nfacilitan la búsqueda, filtrado, descarga, importación y pre-procesado de datos \nSentinel, especialmente Sentinel 2, desde una sesión de GRASS GIS. Ver\n[i.sentinel](https://grass.osgeo.org/grass-stable/manuals/addons/i.sentinel.html) \ny los links de cada módulo para más detalles.\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\n# install extension - run only once\ngs.run_command(\"g.extension\", \n               extension=\"i.sentinel\")\n```\n:::\n\n\nUsamos el módulo `i.sentinel.download` que internamente utiliza la librería \n`sentinelsat` para buscar y filtrar escenas que contengan la región definida \na partir del área urbana de la ciudad de Córdoba. Para esto necesitamos estar \nregistrados en el [Copernicus hub](https://scihub.copernicus.eu/dhus/#/self-registration) \ny tener nuestras credenciales en un archivo de texto. Para más detalles sobre \nla función y sus usos, visitar el\n[manual](https://grass.osgeo.org/grass-stable/manuals/addons/i.sentinel.download.html).\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\n# list all available S2 level 2A scenes that meet the criteria specified\ns2_credentials = os.path.join(homedir, \"sentinel\")\nstart_date = \"2020-03-01\"\nend_date = \"2020-04-30\"\n\nlist_prod = gs.read_command(\"i.sentinel.download\", \n                            settings=s2_credentials, \n                            start=start_date, \n                            end=end_date, \n                            producttype=\"S2MSI2A\", \n                            clouds=30, \n                            area_relation=\"Contains\", \n                            footprints=\"s2_footprints\", \n                            flags=\"l\")\n```\n:::\n\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\n# print plain list\nlist_prod\n```\n:::\n\n\nSi con los criterios de búsqueda se encuentra una larga lista de productos, se\npuede usar la opción `limit` para controlar el número de escenas listadas.\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\nimport pandas as pd\nfrom io import StringIO\n\npd.read_csv(StringIO(list_prod), delimiter=\" \", usecols=[0, 1, 2, 4, 5, 6, 7],\n            names=['uuid', 'scene', 'date', 'cloud', 'product', 'size', 'unit'])\n```\n:::\n\n\nMostramos los footprints de las escenas que encontramos según los criterios de\nbúsqueda:\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\n# diplay footprints\ncba_map = gj.InteractiveMap(width = 400, use_region=True, tiles=\"OpenStreetMap\")\ncba_map.add_vector(\"s2_footprints\")\ncba_map.add_layer_control(position = \"bottomright\")\ncba_map.show()\n```\n:::\n\n\nSe observan 2 tipos de footprints: uno cuadrado y otro una pasada inclinada. \nEncontramos solo estos dos porque establecimos que nuestro *bounding box* \n(región computacional) debía estar **contenido** en la escena.\n\nEl próximo paso es descargar la escena o las escenas de interés. Para eso usamos\nnuevamente el módulo `i.sentinel.download`, pero sin el flag `l` de listar. \nElegimos una imagen con nubes para demostrar posteriormente el uso de otro \nmódulo del set de herramientas.\n\nComo la descarga puede llevar bastante tiempo, **nos saltaremos esta parte** y \nutilizaremos directamente una escena ya descargada. Aún así, dejamos un ejemplo\na continuación para referencia futura :)\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\n# download selected scene - esto toma tiempo y las escenas ya estan descargadas en la carpeta`s2_data`\ns2_data = os.path.join(homedir, \"gisdata\", \"s2_data\")\n\n# gs.run_command(\"i.sentinel.download\", \n#               settings=s2_credentials, \n#               uuid=\"9a1ea49c-0561-4aa5-ba7a-dc820dc1a316\", \n#               output=s2_data)\n```\n:::\n\n\n### Importar datos Sentinel 2 a GRASS GIS\n\n![](../assets/img/sentinel_import_options.png)\n\n#### 1. Importar con corrección atmosférica\n\nSi queremos importar con corrección atmosférica productos de nivel 1C, podemos\nusar el módulo \n[i.sentinel.preproc](https://grass.osgeo.org/grass-stable/manuals/addons/i.sentinel.preproc.html). \nEste módulo utiliza [i.atcorr](https://grass.osgeo.org/grass-stable/manuals/i.atcorr.html) \ninternamente y necesita 2 inputs claves: un valor de aerosol optical depth (AOD) y\nun mapa de elevación.\n\n![](../assets/img/i_sentinel_preproc.png)\n\nPara una descripción más detallada del procedimiento para obtener los valores de \nAOD y mapas de elevación necesarios para la corrección atmosférica y topográfica, \nver [aquí](import_s2_with_atm_corr.html).\n\n\n#### 2. Importar sin corrección atmosférica\n\nUna vez descargada la escena deseada, se procede a importarla al mapset de trabajo. \nPara ello se usa el comando\n[i.sentinel.import](https://grass.osgeo.org/grass-stable/manuals/addons/i.sentinel.import.html) \nque permite subset, resampleo y reproyección al vuelo. Además, si en nuestra \ncarpeta existen varios zip nos permite seleccionar, por medio de un patrón, \ncuáles queremos importar; y también, elegir solo las bandas de interés. Entonces, \nvamos a imprimir información sobre las bandas\nantes de importarlas.\n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\n# print bands info before importing\n# (1 -proj match, 0 -no proj match)\ngs.run_command(\"i.sentinel.import\", \n               input=s2_data, \n               flags=\"p\")\n```\n:::\n\n\n::: {.cell execution_count=20}\n``` {.python .cell-code}\n# import only bands relevant for RGB, NDVI and NDWI\ngs.run_command(\"i.sentinel.import\", \n               input=s2_data, \n               pattern_file=\"*20200330T141049*\", # in case we have more s2 scenes in the s2_data folder \n               pattern=\"B(02_1|03_1|04_1|08_1|8A_2|11_2|12_2)0m\", # select bands and resolutions\n               extent=\"region\", # subset import to region extent\n               flags=\"rcsj\") # reproject, clouds, shadow, json metadata\n```\n:::\n\n\nListamos los mapas importados:\n\n::: {.cell execution_count=21}\n``` {.python .cell-code}\n# list raster maps\ngs.list_grouped(type=\"raster\")['sentinel2']\n```\n:::\n\n\nA continuación, chequeamos los metadatos de uno de los mapas o bandas. Notar que\ntodos los metadatos que vienen con la imagen original se agregan a la banda \ncorrespondiente en el momento de la importación. Esto es gracias al uso del \nflag `j` en el comando `i.sentinel.import`.\n\n::: {.cell execution_count=22}\n``` {.python .cell-code}\n# check metadata of some imported bands\ngs.raster_info(map=\"T20JLL_20200330T141049_B03_10m\")\n```\n:::\n\n\nVeamos los *semantic labels* de las bandas importadas:\n\n::: {.cell execution_count=23}\n``` {.python .cell-code}\n# print semantic labels of imported bands\nfor i in gs.list_grouped(type=\"raster\")['sentinel2']:\n    label = gs.raster_info(map=i)['semantic_label']\n    print('Mapa: {}, Semantic label: {}'.format(i,label))\n```\n:::\n\n\n### Balance de colores y composiciones\n\nA continuación, aplicamos la paleta de *grises* a las bandas R, G y B, mejoramos \nel contraste y las mostramos usando la clase `Map` de `grass.jupyter`.\n\n::: {.cell execution_count=24}\n``` {.python .cell-code}\n# apply grey color to RGB bands\ngs.run_command(\"r.colors\", \n               map=\"T20JLL_20200330T141049_B04_10m,T20JLL_20200330T141049_B03_10m,T20JLL_20200330T141049_B02_10m\",\n               color=\"grey\")\n```\n:::\n\n\n::: {.cell execution_count=25}\n``` {.python .cell-code}\n# perform color auto-balancing for RGB bands\ngs.run_command(\"i.colors.enhance\", \n               red=\"T20JLL_20200330T141049_B04_10m\",\n               green=\"T20JLL_20200330T141049_B03_10m\", \n               blue=\"T20JLL_20200330T141049_B02_10m\",\n               strength=90)\n```\n:::\n\n\n::: {.cell execution_count=26}\n``` {.python .cell-code}\n# display the enhanced RGB combination\ncba_rgb = gj.Map(use_region=True)\ncba_rgb.d_rgb(red=\"T20JLL_20200330T141049_B04_10m\", \n              green=\"T20JLL_20200330T141049_B03_10m\", \n              blue=\"T20JLL_20200330T141049_B02_10m\")\ncba_rgb.d_grid(size=5000, flags=\"b\")\ncba_rgb.show()\n```\n:::\n\n\n:::{.callout-warning title=\"Tarea\"}\nRealizar balance de colores y mostrar combinacion falso color NIR-RED-GREEN\n:::\n\n### Identificación y enmascarado de nubes\n\nComo empezaremos a generar mapas raster nuevos, es fundamental que establezcamos\nla región computacional a los límites y resolución de una de nuestras bandas. \nTambién podría ser que nos interesase un área más pequeña para hacer unas pruebas\niniciales. Esto es sumamente facil y evita que tengamos que cortar raster a \nraster físicamente.\n\n::: {.cell execution_count=27}\n``` {.python .cell-code}\n# set comp reg to a band - all subsequent output rasters will have this extension & resolution\ngs.parse_command(\"g.region\", \n                 raster=\"T20JLL_20200330T141049_B02_10m\", \n                 flags=\"g\")\n```\n:::\n\n\nAhora demostramos el uso del módulo\n[i.sentinel.mask](https://grass.osgeo.org/grass-stable/manuals/addons/i.sentinel.mask.html)\nque toma los metadatos registrados al importar las bandas para ejecutar la \nidentificacion de nubes y sus sombras.\n\n::: {.cell execution_count=28}\n``` {.python .cell-code}\n# identify and mask clouds and clouds shadows: i.sentinel.mask\ngs.run_command(\"i.sentinel.mask\",\n               blue=\"T20JLL_20200330T141049_B02_10m\",\n               green=\"T20JLL_20200330T141049_B03_10m\",\n               red=\"T20JLL_20200330T141049_B04_10m\", \n               nir=\"T20JLL_20200330T141049_B08_10m\",\n               nir8a=\"T20JLL_20200330T141049_B8A_20m\",\n               swir11=\"T20JLL_20200330T141049_B11_20m\",\n               swir12=\"T20JLL_20200330T141049_B12_20m\",\n               cloud_mask=\"cloud\", \n               shadow_mask=\"shadow\",\n               scale_fac=10000, \n               flags=\"s\", \n               overwrite=True)\n```\n:::\n\n\nPor defecto obtenemos un mapa vectorial con contornos de nubes y otro para las \nsombras de nubes:\n\n::: {.cell execution_count=29}\n``` {.python .cell-code}\n# list vector maps in the mapset\ngs.list_grouped(type=\"vector\")['sentinel2']\n```\n:::\n\n\nVeamos el resultado agregando \"capas\" al mapa anterior:\n\n::: {.cell execution_count=30}\n``` {.python .cell-code}\n# display output\ncba_rgb.d_vect(map=\"shadow\", color=\"red\", fill_color=\"red\")\ncba_rgb.d_vect(map=\"cloud\", color=\"blue\", fill_color=\"blue\")\ncba_rgb.show()\n```\n:::\n\n\nInspeccionamos el mapa de nubes descargado con la escena (a traves de los flags \n`c` y `s`) y establecemos la misma paleta de colores a los fines de comparar \nambos productos: la máscara de nubes y sombras obtenida con `i.sentinel.mask` \ny la provista por ESA junto con las imágenes.\n\n::: {.cell execution_count=31}\n``` {.python .cell-code}\n# utilizamos un comando de GRASS directamente\n!v.db.select T20JLL_20200330T141049_MSK_CLOUDS | head\n```\n:::\n\n\n::: {.cell execution_count=32}\n``` {.python .cell-code}\n# o su version dentro de la libreria grass.script\nvec_attr_table = gs.vector_db_select(\"T20JLL_20200330T141049_MSK_CLOUDS\")\n```\n:::\n\n\n::: {.cell execution_count=33}\n``` {.python .cell-code}\nvec_attr_table[\"values\"]\n```\n:::\n\n\nAsignamos la misma paleta de colores y visualizamos el resultado:\n\n::: {.cell execution_count=34}\n``` {.python .cell-code}\ns2_clouds = \"T20JLL_20200330T141049_MSK_CLOUDS\"\ncolours = [\"1 0:0:255\", \"2 255:0:0\"]\ncolourise = gs.feed_command(\"v.colors\", map=s2_clouds, use=\"attr\", column=\"value\", rules=\"-\", quiet=True)\ncolourise.stdin.write(\"\\n\".join(colours).encode())\ncolourise.stdin.close()\n```\n:::\n\n\n::: {.cell execution_count=35}\n``` {.python .cell-code}\ncba_rgb = gj.Map(use_region=True)\ncba_rgb.d_rgb(red=\"T20JLL_20200330T141049_B04_10m\", \n              green=\"T20JLL_20200330T141049_B03_10m\", \n              blue=\"T20JLL_20200330T141049_B02_10m\")\ncba_rgb.d_grid(size=5000, flags=\"b\")\ncba_rgb.d_vect(map=\"T20JLL_20200330T141049_MSK_CLOUDS\")\ncba_rgb.show()\n```\n:::\n\n\nLos resultados son bastante parecidos y en este último caso, no necesitariamos \nejecutar un segundo comando. No obstante, tanto `i.sentinel.mask` como la banda \nque viene con la escena, tienen opciones para ajustar el tamaño de nubes y sombras\nidentificadas que aquí se dejaron por defecto.\n\n### Indices espectrales de vegetación y agua\n\nAntes de proceder a calcular los índices, vamos a enmascarar las áreas identificadas\ncomo nubes y sombras. Para eso, primero pegamos los vectores en uno solo y luego \nlo aplicamos como máscara inversa. Para más detalles del funcionamiento de las \nmáscaras en GRASS ver [r.mask](https://grass.osgeo.org/grass-stable/manuals/r.mask.html).\n\n::: {.cell execution_count=36}\n``` {.python .cell-code}\n# set clouds mask\ngs.run_command(\"v.patch\", \n               input=\"cloud,shadow\", \n               output=\"cloud_shadow_mask\")\n\ngs.run_command(\"r.mask\", \n               vector=\"cloud_shadow_mask\", \n               flags=\"i\")\n```\n:::\n\n\nLuego utilizamos los módulos [i.vi](https://grass.osgeo.org/grass-stable/manuals/i.vi.html) \ne [i.wi](https://grass.osgeo.org/grass-stable/manuals/addons/i.wi.html) (addon) \npara estimar NDVI y NDWI. Ver los respectivos manuales para más detalles sobre \nlos índices disponibles.\n\n::: {.cell execution_count=37}\n``` {.python .cell-code}\n# estimate vegetation indices\ngs.run_command(\"i.vi\", \n               red=\"T20JLL_20200330T141049_B04_10m\", \n               nir=\"T20JLL_20200330T141049_B08_10m\", \n               output=\"T20JLL_20200330T141049_NDVI_10m\", \n               viname=\"ndvi\")\n\n# add semantic label\ngs.run_command(\"r.support\",\n               map=\"T20JLL_20200330T141049_NDVI_10m\", \n               semantic_label=\"NDVI\")\n```\n:::\n\n\n::: {.cell execution_count=38}\n``` {.python .cell-code}\n# install extension\ngs.run_command(\"g.extension\", \n               extension=\"i.wi\")\n```\n:::\n\n\n::: {.cell execution_count=39}\n``` {.python .cell-code}\n# estimate water indices and set color palette\ngs.run_command(\"i.wi\", \n               green=\"T20JLL_20200330T141049_B03_10m\",\n               nir=\"T20JLL_20200330T141049_B08_10m\",\n               output=\"T20JLL_20200330T141049_NDWI_10m\",\n               winame=\"ndwi_mf\")\n\n# add semantic label\ngs.run_command(\"r.support\", \n               map=\"T20JLL_20200330T141049_NDWI_10m\", \n               semantic_label=\"NDWI\")\n\n# set ndwi color table\ngs.run_command(\"r.colors\", \n               map=\"T20JLL_20200330T141049_NDWI_10m\", \n               color=\"ndwi\")\n```\n:::\n\n\n::: {.cell execution_count=40}\n``` {.python .cell-code}\n# interactive maps\nidx_map = gj.InteractiveMap(width = 400, use_region=True, tiles=\"OpenStreetMap\")\nidx_map.add_raster(\"T20JLL_20200330T141049_NDVI_10m\", opacity=0.7)\nidx_map.add_raster(\"T20JLL_20200330T141049_NDWI_10m\", opacity=0.7)\nidx_map.add_layer_control(position = \"bottomright\")\nidx_map.show()\n# ... use the layer selector in the corner to enable/disable the NDVI/NDWI layers\n```\n:::\n\n\n### Mapas de GRASS como arrays de Numpy\n\nLos mapas de GRASS pueden leerse como arrays de Numpy gracias a la funcion `array` \nde la librería *grass.script*. Esto facilita muchas operaciones posteriores con \nlibrerías de Python que requieren un array como input. En este caso, demostramos\nsu uso con un histograma.\n\n::: {.cell execution_count=41}\n``` {.python .cell-code}\n# Import required libraries\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nfrom grass.script import array as garray\n\n# Read NDVI as numpy array\nndvi = garray.array(mapname=\"T20JLL_20200330T141049_NDVI_10m\", null=\"nan\")\nndwi = garray.array(mapname=\"T20JLL_20200330T141049_NDWI_10m\", null=\"nan\")\nprint(ndvi.shape,ndwi.shape)\n```\n:::\n\n\n::: {.cell execution_count=42}\n``` {.python .cell-code}\n# Plot NDVI and NDWI\nsns.set_style('darkgrid')\nfig, axs = plt.subplots(1, 2, figsize=(7, 7))\nsns.histplot(ax=axs[0], data=ndvi.ravel(), kde=True, color=\"olive\")\nsns.histplot(ax=axs[1], data=ndwi.ravel(), kde=True, color=\"skyblue\")\nplt.show()\n```\n:::\n\n\n### Segmentación\n\nExisten varios módulos para relizar segmentación en GRASS GIS, los mas conocidos\nson [i.segment](https://grass.osgeo.org/grass80/manuals/i.segment.html) e\n[i.superpixels.slic](https://grass.osgeo.org/grass80/manuals/addons/i.superpixels.slic.html). \nVamos a demostrar su uso.\n\nPrimero, instalamos la extensión *i.superpixels.slic*.\n\n::: {.cell execution_count=43}\n``` {.python .cell-code}\n# install extension\ngs.run_command(\"g.extension\", \n               extension=\"i.superpixels.slic\")\n```\n:::\n\n\nLuego, listamos los mapas y crear el grupo con las bandas y los índices.\n\n::: {.cell execution_count=44}\n``` {.python .cell-code}\n# list maps\ns2_maps = gs.list_grouped(type=\"raster\", \n                          pattern=\"*20200330T141049*\")['sentinel2']\nprint(s2_maps)\n```\n:::\n\n\n::: {.cell execution_count=45}\n``` {.python .cell-code}\n# create group and subgroup with bands and indices\ngs.run_command(\"i.group\", \n               group=\"s2\", \n               subgroup=\"s2\", \n               input=s2_maps)\n\ngs.parse_command(\"i.group\", \n                 group=\"s2\", \n                 flags=\"l\")\n```\n:::\n\n\nEjecutar *i.superpixels.slic* y convertir el resultado a vector\n\n::: {.cell execution_count=46}\n``` {.python .cell-code}\n# run i.superpixels.slic\ngs.run_command(\"i.superpixels.slic\", \n               input=\"s2\", \n               output=\"superpixels\", \n               num_pixels=50)\n```\n:::\n\n\n::: {.cell execution_count=47}\n``` {.python .cell-code}\n# convert the resulting raster to vector\ngs.run_command(\"r.to.vect\", \n               input=\"superpixels\", \n               output=\"superpixels\", \n               type=\"area\")\n```\n:::\n\n\nEjecutar *i.segment* y convertir el resultado a vector\n\n::: {.cell execution_count=48}\n``` {.python .cell-code}\n# run i.segment (region growing)\ngs.run_command(\"i.segment\", \n               group=\"s2\", \n               output=\"segments\", \n               threshold=0.5, \n               minsize=50, \n               memory=500)\n```\n:::\n\n\n::: {.cell execution_count=49}\n``` {.python .cell-code}\n# convert the resulting raster to vector\ngs.run_command(\"r.to.vect\", \n               input=\"segments\", \n               output=\"segments\", \n               type=\"area\")\n```\n:::\n\n\nComparamos el número de segmentos obtenidos:\n\n::: {.cell execution_count=50}\n``` {.python .cell-code}\n# compare number of segments\nn1 = gs.vector_info(map=\"superpixels\")['areas']\nn2 = gs.vector_info(map=\"segments\")['areas']\n\nprint(\"Superpixels SLIC: {}\\nRegion growing: {}\".format(n1,n2))\n```\n:::\n\n\nMostrar NDVI junto con las 2 salidas de la segmentación\n\n::: {.cell execution_count=51}\n``` {.python .cell-code}\n# diplay results\nseg_map = gj.InteractiveMap(width = 600, use_region=True, tiles=\"OpenStreetMap\")\nseg_map.add_vector(\"superpixels\")\nseg_map.add_vector(\"segments\")\nseg_map.add_layer_control(position = \"bottomright\")\nseg_map.show()\n```\n:::\n\n\n:::{.callout-warning title=\"Tarea\"}\nEjecutar cualquiera de los 2 métodos de segmentación con diferentes parámetros \ny comparar los resultados\n:::\n\n### Clasificación supervisada\n\n#### Clasificación supervisada con Maximum Likelihood\n\nVamos a demostrar a continuacion el workflow para realizar una clasificacion \nsupervisada por máxima verosimilitud a partir de unos polígonos de entrenamiento\ndigitalizados en GRASS y que se encuentran en la carpeta `s2_data`.\n\nImportamos el vector y lo visualizamos.\n\n::: {.cell execution_count=52}\n``` {.python .cell-code}\ntrain_areas = os.path.join(homedir, s2_data, \"training.gpkg\")\n```\n:::\n\n\n::: {.cell execution_count=53}\n``` {.python .cell-code}\n# import gpkg with training areas\ngs.run_command(\"v.import\", \n               input=train_areas, \n               output=\"training\")\n```\n:::\n\n\n::: {.cell execution_count=54}\n``` {.python .cell-code}\n# use color column for classes\ngs.run_command(\"v.colors\", \n               map=\"training\", \n               rgb_column=\"color\", \n               flags=\"c\")\n```\n:::\n\n\n::: {.cell execution_count=55}\n``` {.python .cell-code}\n# map\ncba_rgb_train = gj.Map(width=300, use_region=True)\ncba_rgb_train.d_rgb(red=\"T20JLL_20200330T141049_B04_10m\", \n              green=\"T20JLL_20200330T141049_B03_10m\", \n              blue=\"T20JLL_20200330T141049_B02_10m\")\ncba_rgb_train.d_grid(size=5000, fontsize=7, flags=\"b\")\ncba_rgb_train.d_vect(map=\"training\")\ncba_rgb_train.show()\n```\n:::\n\n\nConvertimos el mapa vectorial con los polígonos de entrenamiento a mapa raster. \nPara ello, utilizamos la columna que contiene los números de clase.\n\n::: {.cell execution_count=56}\n``` {.python .cell-code}\n!v.db.select training | head\n```\n:::\n\n\n::: {.cell execution_count=57}\n``` {.python .cell-code}\n# convert to raster\ngs.run_command(\"v.to.rast\", \n               input=\"training\", \n               output=\"training\", \n               use=\"attr\", \n               attribute_column=\"cat_\", \n               label_column=\"class\")\n```\n:::\n\n\nA continuación, utilizamos el módulo\n[i.gensig](https://grass.osgeo.org/grass-stable/manuals/i.gensig.html) para \ngenerar las firmas espectrales de las clases de interés a partir de los polígonos\nconocidos/etiquetados.\n\n::: {.cell execution_count=58}\n``` {.python .cell-code}\n# obtain signature files\ngs.run_command(\"i.gensig\", \n               trainingmap=\"training\", \n               group=\"s2\", \n               subgroup=\"s2\", \n               signaturefile=\"sig_sentinel\")\n```\n:::\n\n\nEl archivo de firmas es un archivo de texto que se guarda automáticamente dentro\nde la carpeta `grassdata/posgar2007_4_cba/sentinel2/signatures/sig/sig_sentinel/`\ny tiene la siguiente forma: \n\n```\n1\n#\nS2_2 S2_3 S2_4 S2_8 S2_11 S2_12 S2_8A NDVI NDWI \n#class_1\n34976\n462.107 754.712 650.115 2652.12 2328.17 1354.23 2898.15 0.590024 -0.54825 \n3433.54 \n3439.85 13667.9 \n4587.72 3893.81 16344.2 \n-891.313 51917 -46133.6 508644 \n6381.57 8558.14 18795.3 -11728.6 64026.7 \n5455.05 4485.2 19848.3 -53771.7 37873.6 35044.9 \n-1286.3 52732.6 -45664.8 513310 -5531.12 -52538.1 526931 \n-1.76356 3.82015 -10.8837 64.4926 -9.11136 -12.7041 64.3455 0.0108229 \n1.38826 -0.0813683 6.12975 -29.5299 4.5855 6.97446 -29.4906 -0.00517479 0.00292289 \n#class_2\n37706\n1609.95 1825.69 1919.19 2607.13 2801.12 2369.91 2765.3 0.160587 -0.184169 \n234001 \n240075 251609 \n248408 260806 281060 \n151243 167006 169635 212669 \n123807 133556 145512 127378 164973 \n116139 123360 136440 90707.7 153127 163716 \n93815.4 104574 105790 153545 118673 82117.3 147388 \n-33.6194 -33.5942 -38.5054 -0.417204 -11.895 -16.7121 3.63643 0.0104315 \n33.4993 33.3665 35.3967 1.58334 9.64074 13.9172 -2.8798 -0.00928648 0.00896403 \n#class_3\n13363\n744.78 937.046 1247.71 1824.1 3187.07 2764.02 2009.06 0.191184 -0.325633 \n27636.3 \n34766.2 44710.3 \n42545.7 55127.4 70153.9 \n50592 65854 81541.4 102364 \n39674.6 49909.5 66588.2 79876.4 180631 \n38446.9 49209.5 64455.1 73554.7 120268 105226 \n49526.6 64512.1 80082.1 100116 81815.5 74146.1 99653.8 \n-3.37419 -4.24876 -5.95143 -4.94336 -5.45999 -6.25113 -5.00936 0.0010409 \n4.3353 5.42295 6.64764 6.64209 5.19235 6.46732 6.6178 -0.000876728 0.00103444\n```\n\ndonde:\n```\n    Line 1: version number (currently always 1)\n    Line 2: text label\n    Line 3: Space separated list of semantic labels\n    Line 4: text label of class\n    Line 5: number of points in class\n    Line 6: mean values per band of the class\n    Line 7-15: (semi)-matrix of band-band covariance \n```\n\nPara realizar la clasificación supervisada por máxima verosimilitud, el módulo\n[i.maxlik](https://grass.osgeo.org/grass-stable/manuals/i.maxlik.html) toma el \ngrupo y la firma como principales inputs:\n\n::: {.cell execution_count=59}\n``` {.python .cell-code}\n# perform ML supervised classification\ngs.run_command(\"i.maxlik\", \n               group=\"s2\", \n               subgroup=\"s2\", \n               signaturefile=\"sig_sentinel\", \n               output=\"sentinel_maxlik\")\n```\n:::\n\n\nAsignamos etiquetas a las clases y visualizamos el resultado.\n\n::: {.cell execution_count=60}\n``` {.python .cell-code}\n# label classes\nlabel_class = [\"1:vegetation\", \"2:urban\", \"3:bare soil\"]\ncategorise = gs.feed_command(\"r.category\", \n                             map=\"sentinel_maxlik\", \n                             separator=\":\", \n                             rules=\"-\", \n                             quiet=True)\ncategorise.stdin.write(\"\\n\".join(label_class).encode())\ncategorise.stdin.close()\n```\n:::\n\n\n::: {.cell execution_count=61}\n``` {.python .cell-code}\n# display results\ncba_sup_class = gj.Map(width=500, use_region=True)\ncba_sup_class.d_rast(map=\"sentinel_maxlik\")\ncba_sup_class.d_legend(raster=\"sentinel_maxlik\", title=\"Class\", fontsize=10, at=(80, 93, 80, 90), flags=\"b\")\ncba_sup_class.d_barscale()\ncba_sup_class.show()\n```\n:::\n\n\n#### Estadísticas por clase\n\nUtilizamos el comando \n[r.report](https://grass.osgeo.org/grass-stable/manuals/r.report.html) para \nobtener la proporción de cada clase, incluida la de celdas sin datos debido al \nenmascarado de nubes y sombras de nubes.\n\n::: {.cell execution_count=62}\n``` {.python .cell-code}\n# porcentaje de cada clase\ngs.parse_command(\"r.report\", \n                 map=\"sentinel_maxlik\", \n                 units=\"p\", \n                 flags=\"h\")\n```\n:::\n\n\nA continuación, usamos el módulo [r.univar](https://grass.osgeo.org/grass-stable/manuals/r.univar.html) para \nobtener estadísticas descriptivas por clase para la variable NDVI. Para esto, \nademás del raster de NDVI, se pasa la clasificación. Así, el módulo calcula \nlas estadísticas para cada clase.\n\n::: {.cell execution_count=63}\n``` {.python .cell-code}\n# estadisticas de las clases: NDVI\nclass_stats = gs.read_command(\"r.univar\", \n                              map=\"T20JLL_20200330T141049_NDVI_10m\", \n                              zones=\"sentinel_maxlik\", \n                              flags=\"t\")\nclass_stats_df = pd.DataFrame([line.split(\"|\") for line in class_stats.splitlines()])\nclass_stats_df.columns = class_stats_df.iloc[0]\n```\n:::\n\n\n::: {.cell execution_count=64}\n``` {.python .cell-code}\ndf2 = class_stats_df.loc[1:,['label', 'min', 'max', 'mean']] # selecciono unicamente min, max mean\ndf2\n```\n:::\n\n\n#### Clasificación supervisada con Machine Learning\n\nPrimero tenemos que instalar la extensión\n[r.learn.ml2](https://grass.osgeo.org/grass-stable/manuals/addons/r.learn.ml2.html) \nque consta de dos módulos: `r.learn.train` y `r.learn.predict`. Esta extensión \nutiliza la librería scikit-learn de Python y requiere que la misma esté instalada\nde antemano.\n\n::: {.cell execution_count=65}\n``` {.python .cell-code}\n# install ML extension\ngs.run_command(\"g.extension\", \n               extension=\"r.learn.ml2\")\n```\n:::\n\n\nAhora entrenamos el modelo ML usando\n[r.learn.train](https://grass.osgeo.org/grass-stable/manuals/addons/r.learn.train.html), \ncon el modelo \"RandomForestClassifier\".\n\n::: {.cell execution_count=66}\n``` {.python .cell-code}\n# train a random forest classification model using r.learn.train\ngs.run_command(\"r.learn.train\", \n               group=\"s2\", \n               training_map=\"training\",\n               model_name=\"RandomForestClassifier\",\n               n_estimators=\"500\", \n               save_model=os.path.join(homedir, \"rf_model.gz\"))\n```\n:::\n\n\nEl modelo se ha almacenado en el archivo `rf_model.gz` para su uso en el paso de\npredicción de la clasificación supervisada.\n\nAhora entonces aplicamos el modelo entrenado a todo el conjunto de datos.\n\n::: {.cell execution_count=67}\n``` {.python .cell-code}\n# Perform prediction using r.learn.predict\ngs.run_command(\"r.learn.predict\", \n               group=\"s2\", \n               load_model=os.path.join(homedir, \"rf_model.gz\"), \n               output=\"sentinel_rf\")\n```\n:::\n\n\n::: {.cell execution_count=68}\n``` {.python .cell-code}\n# label classes\nlabel_class = [\"1:vegetation\", \"2:urban\", \"3:bare soil\"]\ncategorise = gs.feed_command(\"r.category\", \n                             map=\"sentinel_rf\", \n                             separator=\":\", \n                             rules=\"-\", \n                             quiet=True)\ncategorise.stdin.write(\"\\n\".join(label_class).encode())\ncategorise.stdin.close()\n```\n:::\n\n\n::: {.cell execution_count=69}\n``` {.python .cell-code}\n# display results\ncba_sup_class = gj.Map(width=500, use_region=True)\ncba_sup_class.d_rast(map=\"sentinel_rf\")\ncba_sup_class.d_legend(raster=\"sentinel_rf\", title=\"Class\", fontsize=10, at=(80, 93, 80, 90), flags=\"b\")\ncba_sup_class.d_barscale()\ncba_sup_class.show()\n```\n:::\n\n\n:::{.callout-warning title=\"Tarea\"}\nEstimar estadísticas por clase al igual que hicimos para la clasificación por \nmaxíma verosimilitud.\n:::\n\nComparemos los resultados visualmente y con el módulo\n[r.coin](https://grass.osgeo.org/grass-stable/manuals/r.coin.html), que nos \npermite tabular la ocurrencia mutua o coincidencia entre las categorías de dos\nmapas ráster.\n\n::: {.cell execution_count=70}\n``` {.python .cell-code}\n# Display both classified maps together\nclas_maps = gj.InteractiveMap(width = 600, tiles=\"OpenStreetMap\")\nclas_maps.add_raster(\"sentinel_maxlik\", opacity=0.7)\nclas_maps.add_raster(\"sentinel_rf\", opacity=0.7)\nclas_maps.add_layer_control(position = \"bottomright\")\nclas_maps.show()\n```\n:::\n\n\n::: {.cell execution_count=71}\n``` {.python .cell-code}\nprint(gs.read_command(\"r.coin\",\n                      first=\"sentinel_maxlik\",\n                      second=\"sentinel_rf\",\n                      units=\"p\",\n                      flags=\"w\"))\n```\n:::\n\n\n:::{.callout-warning title=\"Tarea\"}\nComparar los resultados de ambos tipos de clasificación supervisada a través del\níndice Kappa.\n:::\n\n### Post-procesamiento y validación\n\n- [r.reclass.area](http://grass.osgeo.org/grass-stable/manuals/r.reclass.area.html) \npara eliminar pequeñas áreas, enmascarar nuevos valores y rellenar los huecos con [r.neighbors](http://grass.osgeo.org/grass-stable/manuals/r.neighbors.html) o [r.fillnulls](http://grass.osgeo.org/grass-stable/manuals/r.fillnulls.html)\n- convertir la salida en vector y ejecutar [v.clean](http://grass.osgeo.org/grass-stable/manuals/v.clean.html) con `tool=rmarea`\n- [r.kappa](https://grass.osgeo.org/grass-stable/manuals/r.kappa.html) para la \nvalidación (idealmente también digitalizar una muestra de prueba)\n\n",
    "supporting": [
      "exercise_sentinel2_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}