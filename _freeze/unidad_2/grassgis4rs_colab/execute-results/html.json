{
  "hash": "9cabd07bed63f75c8adf4342af1ca70f",
  "result": {
    "markdown": "---\ntitle: '**<span style=''color:Green''>GRASS GIS for remote sensing data processing and analysis</span>**'\nauthor: Ver√≥nica Andreo\ndate: today\nformat:\n  html:\n    code-tools: true\n    code-copy: true\n    code-fold: false\nexecute:\n  eval: false\n  cache: false\n  keep-ipynb: true\n---\n\n<a href=\"https://raw.githubusercontent.com/veroandreo/foss4g2022_grass4rs/main/assets/img/grass_and_satellites.png\">\n  <img src=\"https://raw.githubusercontent.com/veroandreo/foss4g2022_grass4rs/main/assets/img/grass_and_satellites.png\"\n   width=\"25%\" style=\"float:right\">\n</a>\n\n\n### Workshop at FOSS4G 2022, Florence (Italy)\n\n*Lecturers:* Veronica Andreo, Markus Neteler & Maris Nartiss\n\n*Date:* 2022-08-23\n\n\n### Foreword\n\nThis notebook will demonstrate the use of **GRASS GIS 8.2+** in combination with Python within a Jupyter Notebook environment in the [Google Colab](https://colab.research.google.com) environment. We will use GRASS modules and related python libraries that facilitate scripting (`grass.script`) and connection/interaction with Jupyter Notebooks (`grass.jupyter`). \n\nThe workflow that will be demonstrated on this notebook ranges from searching satellite data to time series building and supervised classification.\n\n### Table of contents\n\n1. Why Jupyter Notebooks and how to use them?\n2. GRASS GIS basics\n3. GRASS GIS & Python\n4. Getting ready: set variables and download sample data\n5. Initialization of GRASS GIS in the Jupyter notebook session\n6. Creating an area of interest map\n7. Importing geodata into GRASS GIS\n8. Sentinel-2 processing overview\n9. Computing NDVI\n10. Time series data processing\n11. Creating an image stack (imagery group)\n12. Object recognition with image segmentation\n13. Supervised Classification: Random Forest\n14. Supervised Classification: Maximum Likelihood and band references\n15. What's next?\n\n## 1. Why Jupyter Notebooks and how to use them?\n\nJupyter Notebooks are server-client applications that allow code written in a notebook document to be\n**edited and executed through a web browser**. They can be run on a local computer (no internet access required) or used to control computations on a remote server accessed via the Internet\n([see the documentation](https://jupyter-notebook-beginner-guide.readthedocs.io/en/latest/what_is_jupyter.html)).\n\nJupyter Notebooks can be interactive and they allow to combine live code, explanatory text, and computational results in a single document. In general, they are:\n\n* convenient for initial code development (prototyping)\n* ideal for code segmentation with the ability to re-run cells\n* able to store values of variables from already executed cells\n\nThe notebook can be saved as an executable Python script in addition to the native `.ipynb` format, \nor exported to various documentation formats such as PDF or Sphinx RST with nice styling.\n\n#### Editing and interactive use\n\nEditing a Jupyter Notebook is very easy: in the web browser, you can navigate between text or code\ncells using the mouse or keyboard shortcuts (see Menu > Help > Keyboard Shortcuts). You can\nexecute small code chunks cell by cell, save the notebook in its current state, or modify and \nrecalculate cells or return them to their previous state. In addition to executable code cells, you \ncan use Markdown in documentation cells to make them presentable to others.\n\n## 2. GRASS GIS basics\n\n\n### Open GRASS for the first time\n\nAs of version 8.0, GRASS has modified its startup to make it more user friendly:\n<br>\n<a href=\"https://raw.githubusercontent.com/veroandreo/foss4g2022_grass4rs/main/assets/img/grass_start.png\">\n  <img src=\"https://raw.githubusercontent.com/veroandreo/foss4g2022_grass4rs/main/assets/img/grass_start.png\"\n   alt=\"First time launching GRASS 8\"\n   title=\"First time launching GRASS 8\"\n   width=\"65%\">\n</a>\n\nFrom the **Data** catalog tab you can manage several actions and if you do not yet have imported data into the GRASS database, the software creates the directory structure or database automatically.\n\n### Database\n\n- **GRASS database** (directory with projects): When running GRASS GIS for the first time, a folder named \"grassdata\" is automatically created. Depending on the operating system, it can be found in `$HOME` (*nix) or `My Documents` (MS Windows).\n- **Location** (a project): A location is defined by its coordinate reference system (CRS). The location that is automatically created is in WGS84 (EPSG:4326). If you have data in another CRS, you should ideally create a new location.\n- **Mapset** (a subproject): Each location can have many mapsets to manage different aspects or sub-regions of a project. When creating a new location, GRASS GIS automatically creates a special mapset called *PERMANENT* where the central data of the project (e.g., base maps, road network, dem, etc.) can be stored. \n\n<a href=\"https://raw.githubusercontent.com/veroandreo/foss4g2022_grass4rs/main/assets/img/grass_database.png\">\n  <img src=\"https://raw.githubusercontent.com/veroandreo/foss4g2022_grass4rs/main/assets/img/grass_database.png\"\n   alt=\"GRASS GIS database\"\n   title=\"GRASS GIS database\"\n   width=\"50%\">\n</a>\n\n<div class=\"alert alert-info\">More info: <a href=\"https://grass.osgeo.org/grass-stable/manuals/grass_database.html\">https://grass.osgeo.org/grass-stable/manuals/grass_database.html</a>.</div>\n\n### Computational region\n\nAnother fundamental concept of GRASS GIS (and very useful when working with raster data) is that of the **computational region**. It refers to the boundary configuration of the analysis area and spatial resolution (raster). The **computational region** can be defined and modified with the command [g.region](https://grass.osgeo.org/grass-stable/manuals/g.region.html) to the extent of a vector map, a raster or manually to some area of interest. The *output raster maps will have an extent and spatial resolution equal to the computational region*, while vector maps are always processed at their original extent.\n\n<a href=\"https://raw.githubusercontent.com/veroandreo/foss4g2022_grass4rs/main/assets/img/region.png\">\n  <img src=\"https://raw.githubusercontent.com/veroandreo/foss4g2022_grass4rs/main/assets/img/region.png\"\n   alt=\"Computational region\"\n   title=\"Computational region\"\n   width=\"50%\">\n</a>\n\n<div class=\"alert alert-info\">For more details, see the wiki on <a href=\"https://grasswiki.osgeo.org/wiki/Computational_region\">Computational Region</a>.\n\n### Modules and extensions\n\nGRASS has more than [500 modules](https://grass.osgeo.org/grass-stable/manuals/full_index.html) for the most varied tasks:\n\n| Prefix                                                               | Function class   | Type of command                     | Example\n|--------------------------------------------------------------------- |:---------------- |:----------------------------------- |:-------------------------------------------------------------------------------------------------------------------\n| [g.\\*](https://grass.osgeo.org/grass-stable/manuals/full_index.html#g)    | general          | general data management             | [g.rename](https://grass.osgeo.org/grass-stable/manuals/g.rename.html): renames map\n| [d.\\*](https://grass.osgeo.org/grass-stable/manuals/full_index.html#d)    | display          | graphical output                    | [d.rast](https://grass.osgeo.org/grass-stable/manuals/d.rast.html): display raster map \n| [r.\\*](https://grass.osgeo.org/grass-stable/manuals/full_index.html#r)    | raster           | raster processing                   | [r.mapcalc](https://grass.osgeo.org/grass-stable/manuals/r.mapcalc.html): map algebra\n| [v.\\*](https://grass.osgeo.org/grass-stable/manuals/full_index.html#r)    | vector           | vector processing                   | [v.clean](https://grass.osgeo.org/grass-stable/manuals/v.clean.html): topological cleaning\n| [i.\\*](https://grass.osgeo.org/grass-stable/manuals/full_index.html#i)    | imagery          | imagery processing                  | [i.pca](https://grass.osgeo.org/grass-stable/manuals/i.pca.html): Principal Components Analysis on imagery group\n| [r3.\\*](https://grass.osgeo.org/grass-stable/manuals/full_index.html#r3)  | voxel            | 3D raster processing                | [r3.stats](https://grass.osgeo.org/grass-stable/manuals/r3.stats.html): voxel statistics\n| [db.\\*](https://grass.osgeo.org/grass-stable/manuals/full_index.html#db)  | database         | database management                 | [db.select](https://grass.osgeo.org/grass-stable/manuals/db.select.html): select value(s) from table\n| [ps.\\*](https://grass.osgeo.org/grass-stable/manuals/full_index.html#ps)  | postscript       | PostScript map creation             | [ps.map](https://grass.osgeo.org/grass-stable/manuals/ps.map.html): PostScript map creation\n| [t.\\*](https://grass.osgeo.org/grass-stable/manuals/full_index.html#t)    | temporal         | space-time datasets                 | [t.rast.aggregate](https://grass.osgeo.org/grass-stable/manuals/t.rast.aggregate.html): raster time series aggregation\n\nExtensions or **add-ons** can be installed from the\n[central GitHub repository](https://grass.osgeo.org/grass-stable/manuals/addons/) \nor from *other users' GitHub* (or similar repositories) using the command \n[g.extension](https://grass.osgeo.org/grass-stable/manuals/g.extension.html). For example:\n\n```bash\n # install an extension from the GRASS GIS repository\n g.extension extension=r.hants\n \n # install an extension from another GitHub repository\n g.extension extension=r.change.stats \\\n   url=https://github.com/mundialis/r.change.stats\n``` \n\n## 3. GRASS & Python\n\n### Python package `grass.script`\n\nThe **grass.script** or GRASS GIS Python Scripting Library provides functions for calling GRASS modules within Python scripts. The most commonly used functions include:\n\n- `run_command`: used when the output of the modules is a raster or vector, no text type output is expected\n- `read_command`: used when the output of the modules is of text type\n- `parse_command`: used with modules whose output can be converted to `key=value` pairs\n- `write_command`: used with modules that expect text input, either in the form of a file or from stdin\n\nIt also provides several wrapper functions for frequently used modules, for example:\n\n- To get info from a raster, script.raster.raster_info() is used: `gs.raster_info('dsm')`\n- To get info of a vector, script.vector.vector_info() is used: `gs.vector_info('roads')`\n- To list the raster in a location, script.core.list_grouped() is used: `gs.list_grouped(type=['raster'])`\n- To obtain the computational region, script.core.region() is used: `gs.region()`\n\n<div class=\"alert alert-info\">More info: <a href=\"https://grass.osgeo.org/grass-stable/manuals/libpython/script_intro.html\">https://grass.osgeo.org/grass-stable/manuals/libpython/script_intro.html</a>\n\n### Python package `grass.jupyter`\n\nThe **grass.jupyter** library improves the integration of GRASS and Jupyter, and provides different classes to facilitate GRASS maps visualization:\n\n- `init`: starts a GRASS session and sets up all necessary environment variables\n- `Map`: 2D rendering\n- `Map3D`: 3D rendering\n- `InteractiveMap`: interactive visualization with folium\n- `TimeSeriesMap`: visualization for spatio-temporal data\n\n<div class=\"alert alert-info\">More info: <a href=\"https://grass.osgeo.org/grass-stable/manuals/libpython/grass.jupyter.html\">https://grass.osgeo.org/grass-stable/manuals/libpython/grass.jupyter.html</a>\n\n## 4. Getting ready: set variables and download sample data\n\nGoogle Colab comes with a pretty old Ubuntu 18.04 installation. Since we want to work with GRASS GIS, we first have to install it in Colab. The procedure may take up to 3 minutes...\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\n# Google Colab setup\n# where are we? Print system description\n!lsb_release -a\n\n# register ubuntugis-experimental repo for download\n!add-apt-repository -y ppa:ubuntugis/ubuntugis-unstable\n!add-apt-repository -y ppa:ubuntugis/ubuntugis-experimental\n!apt update\n\n# enforce the correct GDAL version\n!apt-get install -y libgdal26 python3-gdal\n# install GRASS GIS 8\n!apt-get install -y grass-core grass-dev\n!pip install gdal==3.0.4 ply\nprint(\"INSTALLATION COMPLETED\")\n```\n:::\n\n\nSome Python dependencies are needed to run the proposed exercises of this notebook. Install as follows:\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\n!pip3 install sentinelsat notebook folium scikit-learn pandas numpy seaborn matplotlib\n```\n:::\n\n\nFor the ease of working in this notebook, we define some session variables.\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nimport os\n\n# data directory\nhomedir = os.path.join(os.path.expanduser('~'), \"foss4g_grass4rs\")\n\n# GRASS GIS database variables\n#grassbin = \"grassdev\"\ngrassbin = \"grass\"\ngrassdata = os.path.join(homedir, \"grassdata\")\nlocation = \"nc_spm_08_grass7\"\nmapset = \"PERMANENT\"\n```\n:::\n\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\n# Sentinel-2 related directories\ns2_data = os.path.join(homedir, \"sentinel\")\ns2_timestamps = os.path.join(homedir, s2_data, \"sentinel-timestamps.txt\")\n\n# create directories if not already existing\nos.makedirs(grassdata, exist_ok=True)\nos.makedirs(s2_data, exist_ok=True)\n\n# the variables are also accessible via Python\nprint(homedir)\n\n# list content\nos.listdir(homedir)\n```\n:::\n\n\nNext we check the GRASS GIS installation:\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nimport subprocess\nprint(subprocess.check_output([grassbin, \"--config\", \"version\"], text=True))\n```\n:::\n\n\nNext, if not already there, we download **North Carolina location** and unpack it within the above defined `homedir`.\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\n# download NC sample data into target directory homedir (we use `wget` on command line here)\n!wget -c https://grass.osgeo.org/sampledata/north_carolina/nc_spm_08_grass7.zip -O $homedir/nc.zip\n```\n:::\n\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\n# unpack sample dataset into target directory homedir\n!unzip -o -q -d $grassdata $homedir/nc.zip\n\nprint(\"List uploaded file(s) in target directory \"+homedir+\":\")\nos.listdir(homedir)\n```\n:::\n\n\nDownload and unzip Sentinel-2 scenes:\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\n# download Sentinel-2 data into target directory homedir\n!wget -c https://data.neteler.org/foss4g2022/sentinel.zip -O $homedir/sentinel.zip\n\n# unpack into target directory homedir\n!unzip -o -q -d $homedir $homedir/sentinel.zip\n```\n:::\n\n\nDownload landuse map:\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\n# get NC landuse map 2019 in GRASS GIS format, to be used later as classification training map\n!wget -c https://data.neteler.org/foss4g2022/nc_nlcd2019.pack -O $homedir/nc_nlcd2019.pack\n```\n:::\n\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\nprint(\"List uploaded file(s) in target directory \"+homedir+\":\")\nos.listdir(homedir)\n```\n:::\n\n\n## 5. Imports and initialization of GRASS GIS\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\n# Import standard Python packages we need\nimport sys\n\n# Ask GRASS GIS where its Python packages are to be able to run it from the notebook\nsys.path.append(\n    subprocess.check_output([grassbin, \"--config\", \"python_path\"], text=True).strip()\n)\n```\n:::\n\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\n# Import the GRASS GIS packages we need\nimport grass.script as gs\nimport grass.jupyter as gj\n\n# Start the GRASS GIS Session\nsession = gj.init(grassdata, location, mapset)\n```\n:::\n\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\n# Show current GRASS GIS settings, this also checks if the session works\ngs.gisenv()\n```\n:::\n\n\nBefore we start, we list the elements in the mapset `PERMANENT`. If you only want to see the raster or vector type elements, just change the `type` option in the following command. As you can see, since the output is of text type, we use `read_command()`.\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\n# List vector elements in the PERMANENT mapset\ngs.list_grouped(type=\"vector\")\n```\n:::\n\n\nNow we import the landuse map into the PERMANENT mapset (so it is visible in all other mapsets).\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\n## Import of the North Carolina NLCD2019 raster map (subset; resampled to 10m)\ngs.run_command(\"r.unpack\", input=os.path.join(homedir, \"nc_nlcd2019.pack\"))\n```\n:::\n\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\n# show metadata\nprint(gs.read_command(\"r.report\", map=\"nc_nlcd2019\"))\n```\n:::\n\n\nNext, we create a new mapset or project, where we will work with this notebook and import Sentinel-2 data.\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\n# Create a new mapset and switch to it\ngs.run_command(\"g.mapset\", mapset=\"sentinel2\", flags=\"c\")\n```\n:::\n\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\n# Another way would be to use the grass.grassdb functions:\n\n# import grass.grassdb.create as gsdb\n# gsdb.create_mapset(grassdata, location, \"sentinel2\")\n# session.switch_mapset(\"sentinel2\")\n```\n:::\n\n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\n# Check current mapset\nprint(gs.read_command(\"g.mapset\", flags=\"p\"))\n```\n:::\n\n\n::: {.cell execution_count=20}\n``` {.python .cell-code}\n# Print accessible mapsets within the location\nprint(gs.read_command(\"g.mapsets\", flags=\"p\"))\n```\n:::\n\n\n## 6. Creating an area of interest map\n\nTo search for Sentinel 2 images, we need an area of interest. This area can be defined by a vector map or the computational region. Here, will use a map of urban areas that we already have in the PERMANENT mapset to define the region. Since we are interested in the city of Raleigh, we use the function [v.extract](https://grass.osgeo.org/grass-stable/manuals/v.extract.html) to create a new polygon corresponding to that urban area only. Note that in this case we use `run_command()`.\n\n::: {.cell execution_count=21}\n``` {.python .cell-code}\n# Check `urbanarea` vector attributes\ngs.vector_db_select('urbanarea')['values']\n```\n:::\n\n\n::: {.cell execution_count=22}\n``` {.python .cell-code}\n# Extract Raleigh urban area from `urbanarea` vector map\ngs.run_command(\"v.extract\", \n               input=\"urbanarea\", \n               where=\"NAME == 'Raleigh'\", \n               output=\"urban_area_raleigh\")\n```\n:::\n\n\n::: {.cell execution_count=23}\n``` {.python .cell-code}\n# show attributes\ngs.vector_db_select('urban_area_raleigh')['values']\n```\n:::\n\n\nWe set the computational region to the boundaries of the newly created vector. This will be the bounding box we'll use for the Sentinel scenes search.\n\n::: {.cell execution_count=24}\n``` {.python .cell-code}\n# Set the computational region to the extent of Cordoba urban area\nregion = gs.parse_command(\"g.region\", vector=\"urban_area_raleigh\", flags=\"g\")\nregion\n```\n:::\n\n\nWe now use the `grass.jupyter` functions to display the newly obtained vector over the OpenStreetMap basemap.\n\n::: {.cell execution_count=25}\n``` {.python .cell-code}\n# Display newly created vector\nraleigh_map = gj.InteractiveMap(width = 500, use_region=True, tiles=\"OpenStreetMap\")\nraleigh_map.add_vector(\"urban_area_raleigh\")\nraleigh_map.add_layer_control(position = \"bottomright\")\nraleigh_map.show()\n```\n:::\n\n\n## 7. Sentinel-2 processing overview\n\nThere are plenty of libraries or tools which allow downloading\nSentinel products from [Copernicus Open Access Hub](https://scihub.copernicus.eu/).\n\nFor GRASS GIS there is the [i.sentinel](https://grass.osgeo.org/grass-stable/manuals/addons/i.sentinel.html) toolbox that facilitates searching, filtering, downloading, importing and pre-processing Sentinel data, especially Sentinel 2, from a GRASS GIS session. The toolbox consists of six GRASS addon modules:\n\n* [i.sentinel.download](https://grass.osgeo.org/grass-stable/manuals/addons/i.sentinel.download.html)\n* [i.sentinel.import](https://grass.osgeo.org/grass-stable/manuals/addons/i.sentinel.import.html)\n* [i.sentinel.preproc](https://grass.osgeo.org/grass-stable/manuals/addons/i.sentinel.preproc.html)\n* [i.sentinel.mask](https://grass.osgeo.org/grass-stable/manuals/addons/i.sentinel.mask.html)\n* [i.sentinel.coverage](https://grass.osgeo.org/grass-stable/manuals/addons/i.sentinel.coverage.html)\n* [i.sentinel.parallel.download](https://grass.osgeo.org/grass-stable/manuals/addons/i.sentinel.parallel.download.html)\n\nLet's install it:\n\n::: {.cell execution_count=26}\n``` {.python .cell-code}\ngs.run_command(\"g.extension\", extension=\"i.sentinel\")\n```\n:::\n\n\nCheck if the module is there by running it with optional arguments:\n\n::: {.cell execution_count=27}\n``` {.python .cell-code}\ngs.core.find_program(\"i.sentinel.download\", \"--help\")\n```\n:::\n\n\n### Sentinel 2 data search and download\n\n[Sentinel-2 L2A products](https://sentinels.copernicus.eu/de/web/sentinel/user-guides/sentinel-2-msi/product-types/level-2a) will be used to avoid the need of computing atmospheric corrections. \n\nLet‚Äôs search for the latest available product by means of [i.sentinel.download](https://grass.osgeo.org/grass-stable/manuals/addons/i.sentinel.download.html). Setting the `-l` flag, the result will only\nbe printed. The download procedure will be demonstrated later. \n\nIn order to search and download Sentinel products from the Copernicus Open Access Hub, you have to create an account first (see below). See the manual page of [i.sentinel.download](https://grass.osgeo.org/grass-stable/manuals/addons/i.sentinel.download.html) module for details. Upload or create a new text\nfile in the data directory (`homedir`) named `esa_credentials.txt` containing two lines: username and password.\n\n#### Note\n\nTo get username and password you need to register at the [Copernicus Open Access Hub](https://scihub.copernicus.eu/), see the [register new account](https://scihub.copernicus.eu/dhus/#/self-registration) page for signing up. Once you registered, create a text file named `esa_credentials.txt` \nwith the following content:\n```\n    username\n    password\n```\nand move it within your working directory\n\n::: {.cell execution_count=28}\n``` {.python .cell-code}\n# We will simply upload the file to Colab\n# Next code will generate a \"Browse\" button for data upload to Colab\nfrom google.colab import files\nuploaded = files.upload()\n\n!mv \"esa_credentials.txt\" $homedir\n!ls $homedir\n```\n:::\n\n\n::: {.cell execution_count=29}\n``` {.python .cell-code}\n# list available Sentinel-2 L2A scenes for AOI\n# note that we use parse_command() in order to intercept the output\ngs.parse_command(\"i.sentinel.download\", \n                 flags=\"l\", \n                 producttype=\"S2MSI2A\",\n                 map=\"urban_area_raleigh\",\n                 settings=os.path.join(homedir, \"esa_credentials.txt\"))\n```\n:::\n\n\nBy default, the module returns all the products meeting the defined criteria for the last 60 days. Let‚Äôs change\nthe search period setting `start` and `end` options. We will also limit products by `clouds` coverage percentage \nthreshold and `sort` them by ingestion date.\n\n::: {.cell execution_count=30}\n``` {.python .cell-code}\ngs.parse_command(\"i.sentinel.download\", \n                 flags=\"l\", \n                 producttype=\"S2MSI2A\", \n                 map=\"urban_area_raleigh\",\n                 settings=os.path.join(homedir, \"esa_credentials.txt\"),\n                 start=\"2022-02-01\", \n                 end=\"2022-05-31\", \n                 clouds=\"5\",\n                 sort=\"ingestiondate\",\n                 limit=10)\n```\n:::\n\n\n<div class=\"alert alert-info\"> If a long list of products have been found, you can limit the amount with the <code>limit</code> option as we did above.\n\nLet's save the output of the search into a list and then beautify the display by creating a pandas table.\n\n::: {.cell execution_count=31}\n``` {.python .cell-code}\nlist_prod = gs.read_command(\"i.sentinel.download\", \n                            flags=\"l\", \n                            producttype=\"S2MSI2A\", \n                            map=\"urban_area_raleigh\",\n                            settings=os.path.join(homedir, \"esa_credentials.txt\"), \n                            footprints=\"s2_footprints\", # we save the footprints in a vector file\n                            start=\"2022-02-01\", \n                            end=\"2022-05-31\", \n                            clouds=\"5\",\n                            sort=\"ingestiondate\",\n                            limit=10)\n```\n:::\n\n\n::: {.cell execution_count=32}\n``` {.python .cell-code}\n# print plain list\nlist_prod\n```\n:::\n\n\n::: {.cell execution_count=33}\n``` {.python .cell-code}\nimport pandas as pd\nfrom io import StringIO\n\npd.read_csv(StringIO(list_prod), delimiter=\" \", usecols=[0, 1, 2, 4, 5, 6, 7],\n            names=['uuid', 'scene', 'date', 'cloud', 'product', 'size', 'unit'])\n```\n:::\n\n\n::: {.cell execution_count=34}\n``` {.python .cell-code}\n# list available vector maps in sentinel2\ngs.list_grouped(type=\"vector\")[\"sentinel2\"]\n```\n:::\n\n\n::: {.cell execution_count=35}\n``` {.python .cell-code}\n# diplay footprints (you may want to zoom out a bit)\nfp_map = gj.InteractiveMap(width = 400, use_region=True, tiles=\"OpenStreetMap\")\nfp_map.add_vector(\"s2_footprints\")\nfp_map.add_vector(\"urban_area_raleigh\")\nfp_map.add_layer_control(position = \"bottomright\")\nfp_map.show()\n```\n:::\n\n\nThe next step is to download the scene or scenes of interest. Just remove the `-l` flag and add the `output` option in order to define the path to the output directory where data should be saved. \n\nAs download might take quite some time, we'll **skip this part** and directly use an already prepared set of smaller, ready to import scenes which we downloaded above. Still, we leave an example below for future reference :)\n\nGo to section **\"Importing Sentinel 2 data\"**\n\n::: {.cell execution_count=36}\n``` {.python .cell-code}\n# Example: download of a selected scene (2022-06-17, T15:58:29Z)\n# gs.run_command(\"i.sentinel.download\", \n#               settings=s2_credentials, \n#               uuid=\"cfa30609-5627-4788-b7ff-768e2df99975\", \n#               output=s2_data)\n```\n:::\n\n\n### Importing Sentinel-2 data\n\nBefore importing or linking Sentinel-2 data we print a list of filtered raster files including projection match \n(1 for match, otherwise 0). If the CRS of the input data differs from that of the current location, you should \nconsider reprojection (`-r`flag) or creating a new location for import.\n\n*Important*: Data will be imported into the new location by means of the [i.sentinel.import](https://grass.osgeo.org/grass-stable/manuals/addons/i.sentinel.import.html) tool. \nThe command will, by default, import **all** Sentinel bands from `input` directory recursively. \nBefore importing the data, let‚Äôs check content of the input directory by means of the `-p` flag.\n\n::: {.cell execution_count=37}\n``` {.python .cell-code}\n# Check list of pre-downloaded Sentinel-2 scenes, with i.sentinel.import (-p: print)\ngs.parse_command(\"i.sentinel.import\", \n                 flags=\"p\", \n                 input=s2_data)\n```\n:::\n\n\nTo speed up things, we'll limit the S2 data import to the RGB and NIR bands (2, 3, 4, 8A) in 10 m spatial resolution using the `pattern` option. Let's first print the bands that will be imported:\n\n::: {.cell execution_count=38}\n``` {.python .cell-code}\n# print only to test band selection\ngs.parse_command(\"i.sentinel.import\", \n                 flags=\"p\", \n                 input=s2_data, \n                 pattern=\"B(02|03|04|08)_10m\")\n```\n:::\n\n\nBy default, input data are imported into GRASS and converted into GRASS native data format.\nAlternatively, data can be linked if the `-l` flag is provided. It is also\nuseful to import cloud mask vector features (`-c` flag). In addition, we'll use the \n`register_output` option to produce a timestamp plain text file\nwhich will be used later on to create a time series.\n\n::: {.cell execution_count=39}\n``` {.python .cell-code}\n# for S2 import, allow for using 2GB of RAM for faster operations.\n# (s2_data and s2_timestamps are defined above)\n# this may take a few minutes...\ngs.parse_command(\"i.sentinel.import\", \n                 flags=\"rcsj\", \n                 input=s2_data, \n                 pattern=\"B(02|03|04|08)_10m\", \n                 memory=4000, \n                 extent=\"input\",\n                 register_output=s2_timestamps)\n```\n:::\n\n\n::: {.cell execution_count=40}\n``` {.python .cell-code}\n# list selected raster maps\ngs.list_grouped(type=\"raster\")['sentinel2']\n```\n:::\n\n\n::: {.cell execution_count=41}\n``` {.python .cell-code}\n# check metadata of one of the imported bands\ngs.raster_info(map=\"T17SQV_20220617T155829_B03_10m\")[\"comments\"]\n```\n:::\n\n\n::: {.cell execution_count=42}\n``` {.python .cell-code}\n# print timestamp file for inspection\nwith open(s2_timestamps, 'r') as f:\n    content = f.read()\n    print(content)\n    f.close()\n```\n:::\n\n\n<div class=\"alert alert-success\">\n<b>Semantic labels</b><br>\nA fairly new concept within GRASS GIS is semantic labels. These are especially relevant for satellite imagery as they allow us to identify to which sensor and band a given raster corresponds to. These labels are particularly relevant when working with satellite image collections and also when classifying different scenes. We will see it later, but by generating a spectral signature for a given set of bands, it can be re-used to classify another scene as long as the semantic labels are the same. Be ware ‚Äì although it is possible to re-use spectral signatures to any scene with the same bands, temporal changes (seasons, weather impact) limit their applicability only to scenes obtained more or less at the same time.\n\n### Displaying maps with `grass.jupyter` functions\n\n::: {.cell execution_count=43}\n``` {.python .cell-code}\n# create Map instance\nb3_map = gj.Map(width=400)\n# add a raster, vector and legend to the map\nb3_map.d_rast(map=\"T17SQV_20220617T155829_B03_10m\")\nb3_map.d_vect(map=\"lakes\")\nb3_map.d_legend(raster=\"T17SQV_20220617T155829_B03_10m\", \n                title=\"Reflectance\", \n                fontsize=10, at=(70, 93, 80, 90), flags=\"b\")\nb3_map.d_barscale()\n# display map\nb3_map.show()\n```\n:::\n\n\n::: {.cell execution_count=44}\n``` {.python .cell-code}\n# set color table of bands 4, 3 and 2 to grey\ngs.run_command(\"r.colors\", \n               map=\"T17SQV_20220617T155829_B04_10m,T17SQV_20220617T155829_B03_10m,T17SQV_20220617T155829_B02_10m\", \n               color=\"grey\")\n```\n:::\n\n\n::: {.cell execution_count=45}\n``` {.python .cell-code}\n# color enhancing for RGB composition\ngs.run_command(\"i.colors.enhance\", \n               red=\"T17SQV_20220617T155829_B04_10m\",\n               green=\"T17SQV_20220617T155829_B03_10m\", \n               blue=\"T17SQV_20220617T155829_B02_10m\",\n               strength=92)\n```\n:::\n\n\n::: {.cell execution_count=46}\n``` {.python .cell-code}\n# set region to \"elevation\" map and align to the S2 data\ngs.run_command(\"g.region\", \n               raster=\"elevation\",\n               align=\"T17SQV_20220617T155829_B04_10m\",\n               flags=\"p\")\n```\n:::\n\n\n::: {.cell execution_count=47}\n``` {.python .cell-code}\n# display the enhanced RGB combination\nrgb = gj.Map(width=400, use_region=True)\nrgb.d_rgb(red=\"T17SQV_20220617T155829_B04_10m\",\n          green=\"T17SQV_20220617T155829_B03_10m\", \n          blue=\"T17SQV_20220617T155829_B02_10m\")\nrgb.show()\n```\n:::\n\n\n## 8. Spectral indices of vegetation and water\n\nWe will use i.vi and i.wi (addon) to estimate NDVI and NDWI vegetation and water indices. See [i.vi](https://grass.osgeo.org/grass-stable/manuals/i.vi.html) and [i.wi](https://grass.osgeo.org/grass-stable/manuals/addons/i.wi.html) for more other available indices.\n\n::: {.cell execution_count=48}\n``` {.python .cell-code}\n# estimate vegetation indices\ngs.run_command(\"i.vi\", \n               red=\"T17SQV_20220528T155819_B04_10m\", \n               nir=\"T17SQV_20220528T155819_B08_10m\", \n               output=\"T17SQV_20220528T155819_NDVI_10m\", \n               viname=\"ndvi\")\n\n# add semantic label\ngs.run_command(\"r.support\", \n               map=\"T17SQV_20220528T155819_NDVI_10m\", \n               semantic_label=\"S2_NDVI\")\n```\n:::\n\n\n::: {.cell execution_count=49}\n``` {.python .cell-code}\n# install extension\ngs.run_command(\"g.extension\", extension=\"i.wi\")\n```\n:::\n\n\n::: {.cell execution_count=50}\n``` {.python .cell-code}\n# estimate water indices\ngs.run_command(\"i.wi\", \n               green=\"T17SQV_20220528T155819_B03_10m\", \n               nir=\"T17SQV_20220528T155819_B08_10m\", \n               output=\"T17SQV_20220528T155819_NDWI_10m\", \n               winame=\"ndwi_mf\")\n\n# set ndwi color palette\ngs.run_command(\"r.colors\", map=\"T17SQV_20220528T155819_NDWI_10m\", color=\"ndwi\")\n\n# add semantic label\ngs.run_command(\"r.support\", \n               map=\"T17SQV_20220528T155819_NDWI_10m\", \n               semantic_label=\"S2_NDWI\")\n```\n:::\n\n\n::: {.cell execution_count=51}\n``` {.python .cell-code}\n# check metadata of NDVI\ngs.raster_info(map=\"T17SQV_20220528T155819_NDVI_10m\")\n```\n:::\n\n\n::: {.cell execution_count=52}\n``` {.python .cell-code}\n# interactive maps\nidx_map = gj.InteractiveMap(width = 400, use_region=True, tiles=\"OpenStreetMap\")\nidx_map.add_raster(\"T17SQV_20220528T155819_NDVI_10m\", opacity=0.7)\nidx_map.add_raster(\"T17SQV_20220528T155819_NDWI_10m\", opacity=0.7)\nidx_map.add_layer_control(position = \"bottomright\")\nidx_map.show()\n# ... use the layer selector in the corner to enable/disable the NDVI/NDWI layers\n```\n:::\n\n\n#### GRASS GIS maps as numpy arrays\n\nGRASS maps can be read as numpy arrays thanks to the array function of the grass.script library. This facilitates many operations with python libraries that require an array as input. In this case, we demonstrate its use plotting an histogram.\n\n::: {.cell execution_count=53}\n``` {.python .cell-code}\n# Import required libraries\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nfrom grass.script import array as garray\n\n# Read NDVI as numpy array\nndvi = garray.array(mapname=\"T17SQV_20220528T155819_NDVI_10m\", null=\"nan\")\nndwi = garray.array(mapname=\"T17SQV_20220528T155819_NDWI_10m\", null=\"nan\")\nprint(ndvi.shape,ndwi.shape)\n```\n:::\n\n\n::: {.cell execution_count=54}\n``` {.python .cell-code}\n# Plot NDVI and NDWI\nsns.set_style('darkgrid')\nfig, axs = plt.subplots(1, 2, figsize=(7, 7))\nsns.histplot(ax=axs[0], data=ndvi.ravel(), kde=True, color=\"olive\")\nsns.histplot(ax=axs[1], data=ndwi.ravel(), kde=True, color=\"skyblue\")\nplt.show()\n```\n:::\n\n\n## 10. NDVI time series data processing\n\n### A few concepts of time series data processing in GRASS GIS\n\nGRASS GIS offers specialized tools for spatio-temporal data\nprocessing, see GRASS documentation [temporalintro](https://grass.osgeo.org/grass-stable/manuals/temporalintro.html) for details and the [temporal data processing](https://grasswiki.osgeo.org/wiki/Temporal_data_processing) wiki for examples and a workflow tutorial.\n\nGRASS introduces three special data types that are designed to handle time-series:\n\n* *Space-time raster datasets* (`strds`) for managing raster map time series.\n\n* *Space-time 3D raster datasets* (`str3ds`) for managing 3D raster map time series.\n\n* *Space-time vector datasets* (`stvds`) for managing vector map time series.\n  \n<a href=\"https://raw.githubusercontent.com/veroandreo/foss4g2022_grass4rs/main/assets/img/tgrass_flowchart.png\">\n  <img src=\"https://raw.githubusercontent.com/veroandreo/foss4g2022_grass4rs/main/assets/img/tgrass_flowchart.png\"\n   alt=\"TGRASS flowchart\"\n   title=\"GRASS flowchart\"\n   width=\"65%\">\n</a>\n\n### Create space-time dataset\n\nAt this moment a new space-time dataset can be created by means of [t.create](https://grass.osgeo.org/grass-stable/manuals/t.create.html) and all imported Sentinel bands registered with [t.register](https://grass.osgeo.org/grass-stable/manuals/t.register.html) and the timestamps file we created when we imported S2 bands.\n\n::: {.cell execution_count=55}\n``` {.python .cell-code}\ngs.run_command(\"t.create\", \n               output=\"s2_nc\", \n               title=\"Sentinel L2A - North Carolina\", \n               desc=\"Tile T17SQV - 2022\")\n\ngs.run_command(\"t.register\", \n               input=\"s2_nc\", \n               file=s2_timestamps)\n```\n:::\n\n\nLet‚Äôs check basic metadata with [t.info](https://grass.osgeo.org/grass-stable/manuals/t.info.html) and list the registered maps with [t.rast.list](https://grass.osgeo.org/grass-stable/manuals/t.rast.list.html).\n\n::: {.cell execution_count=56}\n``` {.python .cell-code}\n# Print time series info\nprint(gs.read_command(\"t.info\", input=\"s2_nc\"))\n```\n:::\n\n\n::: {.cell execution_count=57}\n``` {.python .cell-code}\n# List registered bands in the space-time cube\nprint(gs.read_command(\"t.rast.list\", \n                      input=\"s2_nc\", \n                      columns=\"name,start_time,semantic_label\"))\n```\n:::\n\n\nWe'll now use a special syntaxis to list only band 4 raster maps withing the time series:\n\n::: {.cell execution_count=58}\n``` {.python .cell-code}\n# List only band 4 maps\nprint(gs.read_command(\"t.rast.list\", \n                      input=\"s2_nc.S2_4\", \n                      columns=\"name,start_time,semantic_label\"))\n```\n:::\n\n\n### NDVI Space-Time computation\n\nFor NDVI computation the 4th and 8th bands are required, as we saw above for a single map. \nNow, we will create a time series of NDVI maps. We will take advantage of the semantic labels syntax and use\n[t.rast.mapcalc](https://grass.osgeo.org/grass-stable/manuals/t.rast.mapcalc.html) to estimate NDVI for all the timestamps in the time series, using band 4 and 8 subsets.\n\n::: {.cell execution_count=59}\n``` {.python .cell-code}\ngs.run_command(\"t.rast.mapcalc\", \n               inputs=\"s2_nc.S2_8,s2_nc.S2_4\", \n               output=\"s2_ndvi\", \n               basename=\"s2_ndvi\",\n               expression=\"float(s2_nc.S2_8 - s2_nc.S2_4) / (s2_nc.S2_8 + s2_nc.S2_4)\")\n```\n:::\n\n\nWhen computation is finished, the *ndvi* color table can be set with [t.rast.colors](https://grass.osgeo.org/grass-stable/manuals/t.rast.colors.html):\n\n::: {.cell execution_count=60}\n``` {.python .cell-code}\ngs.run_command(\"t.rast.colors\", input=\"s2_ndvi\", color=\"ndvi\")\n```\n:::\n\n\n::: {.cell execution_count=61}\n``` {.python .cell-code}\nprint(gs.read_command(\"t.info\", input=\"s2_ndvi\"))\n```\n:::\n\n\n### Time series plots\n\nLet‚Äôs check content of the new dataset by means of [t.rast.list](https://grass.osgeo.org/grass-stable/manuals/t.rast.list.html):\n\n::: {.cell execution_count=62}\n``` {.python .cell-code}\nprint(gs.read_command(\"t.rast.list\", \n                      input=\"s2_ndvi\", \n                      columns=\"name,start_time,min,max\"))\n```\n:::\n\n\nIf we save the previous output to a file, we can then plot the min and max time series:\n\n::: {.cell execution_count=63}\n``` {.python .cell-code}\ngs.run_command(\"t.rast.list\", \n                input=\"s2_ndvi\", \n                columns=\"name,start_time,min,max\",\n                format=\"csv\",\n                separator=\"comma\",\n                output=os.path.join(homedir,\"ndvi.csv\"))\n```\n:::\n\n\n::: {.cell execution_count=64}\n``` {.python .cell-code}\n# Read the csv and plot\nndvi = pd.read_csv(os.path.join(homedir,\"ndvi.csv\"))\nndvi.plot(0, [2,3], subplots=False)\n```\n:::\n\n\nWe could also use [t.rast.univar](https://grass.osgeo.org/grass-stable/manuals/t.rast.univar.html) to obtain extended statistics:\n\n::: {.cell execution_count=65}\n``` {.python .cell-code}\n# Get extended univar stats and save them as a csv file\ngs.run_command(\"t.rast.univar\",\n                flags=\"e\",\n                input=\"s2_ndvi\",\n                output=os.path.join(homedir,\"ndvi_ext_stats.csv\"),\n                separator=\"comma\")\n```\n:::\n\n\n::: {.cell execution_count=66}\n``` {.python .cell-code}\n# Read the csv and plot\nndvi = pd.read_csv(os.path.join(homedir,\"ndvi_ext_stats.csv\"))\nndvi['start'] = pd.to_datetime(ndvi.start, format=\"%Y-%m-%d\", exact=False)\nndvi.plot.line(1, [3,4,5], subplots=False)\n```\n:::\n\n\n### Query time series in a single point\n\n`g.region` command allows us to get the coordinates of the center of the computational region, we'll use those to query the NDVI time series.\n\n::: {.cell execution_count=67}\n``` {.python .cell-code}\n# Get region center coordinates for query (center_easting, center_northing values)\ngs.region(complete=True)\n```\n:::\n\n\n::: {.cell execution_count=68}\n``` {.python .cell-code}\n# Query map at center coordinates\nprint(gs.read_command(\"t.rast.what\", \n                      strds=\"s2_ndvi\", \n                      coordinates=\"637500,221750\", \n                      layout=\"col\", \n                      flags=\"n\"))\n```\n:::\n\n\n### Time series animation\n\nNote: [TimeSeriesMap()](https://grass.osgeo.org/grass-stable/manuals/libpython/grass.jupyter.html?highlight=timeseriesmap#module-grass.jupyter.timeseriesmap) of `grass.jupyter` is still experimental and under development.\n\n::: {.cell execution_count=69}\n``` {.python .cell-code}\n### YET TO BE SKIPPED - in GRASS GIS 8.2.0 it takes \"forever\", bugfix pending.\n\n## reduce resolution for faster display of time series, save original first for later\n#gs.parse_command(\"g.region\", save=\"default_res\")\n#gs.parse_command(\"g.region\", flags=\"pa\", res=50)\n \n## Display newly created NDVI time series map\n#ndviseries = gj.TimeSeriesMap(use_region=True)\n#ndviseries.add_raster_series(\"s2_ndvi\", fill_gaps=False)\n#ndviseries.d_legend(color=\"black\", at=(10,40,2,6))\n#ndviseries.d_barscale()\n#ndviseries.show()  # Create TimeSlider\n\n# optionally, write out to animated GIF\n# ndviseries.save(\"image.gif\")\n```\n:::\n\n\n::: {.cell execution_count=70}\n``` {.python .cell-code}\n## restore original region\n#gs.parse_command(\"g.region\", region=\"default_res\")\n```\n:::\n\n\n## 11. Creating an image stack (imagery group)\n\n**Stack of maps = imagery group**\n\nWhen you work with a stack of raster maps (e.g., R-G-B channels or more) in GRASS GIS, you can best handle this stack by creating a raster group with [i.group](https://grass.osgeo.org/grass-stable/manuals/i.group.html). It is just based on metadata, so it does not take up more disk space.\n\n::: {.cell execution_count=71}\n``` {.python .cell-code}\n# Since imagery groups can not be overwritten, \n# we delete a potentially leftover \"s2\" group from a previous run\ngs.run_command(\"g.remove\", \n               type=\"group\", \n               name=\"s2\", \n               flags=\"f\")\n```\n:::\n\n\n::: {.cell execution_count=72}\n``` {.python .cell-code}\n# Generate list of selected S2 maps\ns2_maps = gs.list_grouped(type=\"raster\", pattern=\"*20220528T155819*\")['sentinel2']\nprint(s2_maps)\n```\n:::\n\n\n::: {.cell execution_count=73}\n``` {.python .cell-code}\n# Create group and subgroup with S2 bands\ngs.run_command(\"i.group\", group=\"s2\", subgroup=\"s2\", input=s2_maps)\nprint(gs.read_command(\"i.group\", group=\"s2\", flags=\"l\"))\n```\n:::\n\n\n## 12. Object recognition with image segmentation\n\nWe'll use [i.segment](https://grass.osgeo.org/grass-stable/manuals/i.segment.html) to perform image segmentation. The resulting map will be used together with S2 bands, NDVI and NDWI to perform supervised classification.\n\n::: {.cell execution_count=74}\n``` {.python .cell-code}\n# Threshold = 0 merges only identical segments; threshold = 1 merges all\ngs.run_command(\"i.segment\", \n               group=\"s2\", \n               threshold=\"0.05\", \n               minsize=\"100\", \n               output=\"sentinel_segments_min100\", \n               goodness=\"sentinel_segments_goodness_min100\",\n               memory=2000)\n```\n:::\n\n\n::: {.cell execution_count=75}\n``` {.python .cell-code}\n# Display newly created segments raster map\nsegments = gj.InteractiveMap(width = 400, use_region=True)\nsegments.add_raster(\"sentinel_segments_min100\", opacity=0.3)\nsegments.add_raster(\"s2_ndvi_4\", opacity=0.3)\nsegments.add_layer_control(position = \"bottomright\")\nsegments.show()\n```\n:::\n\n\n::: {.cell execution_count=76}\n``` {.python .cell-code}\n# Show univariate statistics of goodness-of-fit raster map, with extended statistics (quartiles)\nprint(gs.read_command(\"r.univar\",\n                      map=\"sentinel_segments_goodness_min100\", \n                      flags=\"ge\"))\n```\n:::\n\n\n::: {.cell execution_count=77}\n``` {.python .cell-code}\n# Assign color table (low fit values: blue; high fit values: green)\ngs.run_command(\"r.colors\", \n               map=\"sentinel_segments_goodness_min100\", \n               color=\"byg\", \n               flags=\"e\")\n```\n:::\n\n\n::: {.cell execution_count=78}\n``` {.python .cell-code}\n# Display newly created goodness-of-fit raster map\nsegments = gj.InteractiveMap(width = 400, use_region=True)\nsegments.add_raster(\"sentinel_segments_goodness_min100\", opacity=0.8)\nsegments.add_vector(\"urban_area_raleigh\")\nsegments.add_layer_control(position = \"bottomright\")\nsegments.show()\n```\n:::\n\n\n## 13. Supervised Classification: RandomForest\n\nWe will now demonstrate a very much simplified workflow to perform a supervised [Random Forest classification](https://en.wikipedia.org/wiki/Random_forest).\n\nWe will feed the following data into the model:\n\n- NDVI and NDWI maps (created above)\n- image segmentation (created above)\n- random training points extracted from landuse map\n\nFirst we inspect the raster maps available in the current mapset (i.e., `sentinel2`), just to recall their names.\n\n::: {.cell execution_count=79}\n``` {.python .cell-code}\ngs.list_grouped(type=\"raster\")[\"sentinel2\"]\n```\n:::\n\n\n### Creation of a classification training map by sampling from existing data\n\nIn order to generate training data for the Sentinel-2 image classification, we will use the [National Land Cover Database (NLCD) 2019](https://www.lib.ncsu.edu/gis/lulc). It is available for download (30m raster map) from [here](https://drive.google.com/open?id=18D99kuotQp_BkxBnkn8OS3qgCeLVwovb&authuser=0). However, we have already prepared the dataset (the `nc_nlcd2019` landuse map). We will use it to perform stratified sampling to retrieve training data.\n\n::: {.cell execution_count=80}\n``` {.python .cell-code}\n# Check raster categories of landuse map\nprint(gs.read_command(\"r.category\", \n                      map=\"nc_nlcd2019\", \n                      separator=\"comma\"))\n```\n:::\n\n\n::: {.cell execution_count=81}\n``` {.python .cell-code}\n# display nc_nlcd2019 landuse raster map\nlulc = gj.InteractiveMap(width = 400, use_region=True, tiles=\"OpenStreetMap\")\nlulc.add_raster(\"nc_nlcd2019\", opacity=0.6)\nlulc.add_layer_control(position = \"bottomright\")\nlulc.show()\n```\n:::\n\n\nWe already note differences between the underlying OpenStreetMap data and the 30m NLCD map.\n\n::: {.cell execution_count=82}\n``` {.python .cell-code}\n# show simple legend\nlegend = gj.Map(width=400, use_region=True)\n# at=bottom,top,left,right, percentage of screen coordinates (0,0 is lower left)\nlegend.d_legend(raster=\"nc_nlcd2019\", \n                title=\"Classes\",\n                fontsize=10, at=(10, 90, 50, 90), \n                flags=\"n\")\nlegend.show()\n```\n:::\n\n\n### Random sampling from rasterized simplified landuse map\n\nWe now perform stratified sampling, i.e. we extract for each land use class `n` sampling points, using the GRASS GIS addon [r.sample.category](https://grass.osgeo.org/grass-stable/manuals/addons/r.sample.category.html).\n\nFirst, we install this addon.\n\n::: {.cell execution_count=83}\n``` {.python .cell-code}\ngs.run_command(\"g.extension\", extension=\"r.sample.category\")\n```\n:::\n\n\n::: {.cell execution_count=84}\n``` {.python .cell-code}\n# Stratified random sampling, generated vector points\ngs.run_command(\"r.sample.category\", \n               input=\"nc_nlcd2019\", \n               output=\"landuse_train\", \n               n=\"100\")\n```\n:::\n\n\n::: {.cell execution_count=85}\n``` {.python .cell-code}\n# display newly created vector points map\ntrain = gj.InteractiveMap(width = 400, use_region=True)\ntrain.add_raster(\"nc_nlcd2019\", opacity=0.7)\ntrain.add_vector(\"landuse_train\")\ntrain.add_layer_control(position = \"bottomright\")\ntrain.show()\n```\n:::\n\n\n::: {.cell execution_count=86}\n``` {.python .cell-code}\n# List column names of vector points map\ngs.vector_columns(\"landuse_train\", \n                  getDict=False)\n```\n:::\n\n\n::: {.cell execution_count=87}\n``` {.python .cell-code}\n# Show vector attribute table\ngs.vector_db_select(\"landuse_train\")\n```\n:::\n\n\n::: {.cell execution_count=88}\n``` {.python .cell-code}\n# Check column data types\nprint(gs.read_command(\"v.info\", map=\"landuse_train\", flags=\"c\"))\n```\n:::\n\n\nSince the machine learning classifier expects raster points as input, we convert the vector sampling points accordingly using  [v.to.rast](https://grass.osgeo.org/grass-stable/manuals/v.to.rast.html).\n\n::: {.cell execution_count=89}\n``` {.python .cell-code}\n# Convert points from vector to raster model\ngs.run_command(\"v.to.rast\", \n               input=\"landuse_train\", \n               output=\"landuse_train\", \n               use=\"attr\", \n               attribute_column=\"nc_nlcd2019\", \n               label_column=\"label\")\n```\n:::\n\n\n::: {.cell execution_count=90}\n``` {.python .cell-code}\n# Check raster categories of new raster training map\n# Skip reporting on empty cells\nprint(gs.read_command(\"r.report\", \n                      map=\"landuse_train\",\n                      flags=\"n\"))\n```\n:::\n\n\n::: {.cell execution_count=91}\n``` {.python .cell-code}\n# Display newly created raster map - zoom in to better spot the raster sampling points\ntrain = gj.InteractiveMap(width = 400, use_region=True)\ntrain.add_raster(\"landuse_train\", opacity=0.8)\ntrain.add_layer_control(position = \"bottomright\")\ntrain.show()\n```\n:::\n\n\n### Perform machine learning model training (RandomForest)\n\nFirst we have to install the [r.learn.ml2](https://grass.osgeo.org/grass-stable/manuals/addons/r.learn.ml2.html) extention. It consists of two modules: `r.learn.train` and `r.learn.predict`.\n\n::: {.cell execution_count=92}\n``` {.python .cell-code}\n# Install ML extension\ngs.run_command(\"g.extension\", extension=\"r.learn.ml2\")\n```\n:::\n\n\n::: {.cell execution_count=93}\n``` {.python .cell-code}\n# Add segmentation map created above to group and subgroup already populated with S2 bands, NDWI and NDVI\ngs.run_command(\"i.group\", \n               group=\"s2\", \n               subgroup=\"s2\", \n               input=\"sentinel_segments_min100\")\n\n# List group content\nprint(gs.read_command(\"i.group\", group=\"s2\", flags=\"l\"))\n```\n:::\n\n\nWe now train the ML model using [r.learn.train](https://grass.osgeo.org/grass-stable/manuals/addons/r.learn.train.html), with model \"RandomForestClassifier\".\n\n::: {.cell execution_count=94}\n``` {.python .cell-code}\n# Train a random forest classification model using r.learn.train\ngs.run_command(\"r.learn.train\", \n               group=\"s2\", \n               training_map=\"landuse_train\",\n               model_name=\"RandomForestClassifier\",\n               n_estimators=\"500\", \n               save_model=os.path.join(homedir, \"rf_model.gz\"))\n```\n:::\n\n\n The model has been stored in the file `rf_model.gz` for use in the prediction step of the supervised classification.\n\n::: {.cell execution_count=95}\n``` {.python .cell-code}\nos.listdir(homedir)\n```\n:::\n\n\n### Perform ML supervised classification\n\nThe trained model will now be applied to the entire dataset.\n\n::: {.cell execution_count=96}\n``` {.python .cell-code}\n# Perform prediction using r.learn.predict\ngs.run_command(\"r.learn.predict\", \n               group=\"s2\", \n               load_model=os.path.join(homedir, \"rf_model.gz\"), \n               output=\"sentinel_rf\")\n```\n:::\n\n\n::: {.cell execution_count=97}\n``` {.python .cell-code}\n# Set color table, we transfer the colors from the original landuse map\ngs.run_command(\"r.colors\", map=\"sentinel_rf\", raster=\"nc_nlcd2019\")\n```\n:::\n\n\nWith this, the (oversimplified) supervised classification has been completed and we can display the result.\n\n### Reporting and display\n\n::: {.cell execution_count=98}\n``` {.python .cell-code}\n# Display newly created sentinel_rf map\nrfmap = gj.InteractiveMap(width = 600, tiles=\"OpenStreetMap\")\nrfmap.add_raster(\"sentinel_rf\", opacity=0.7)\n# rfmap.add_raster(\"nc_nlcd2019\", opacity=0.7)\nrfmap.add_layer_control(position = \"bottomright\")\nrfmap.show()\n```\n:::\n\n\n::: {.cell execution_count=99}\n``` {.python .cell-code}\n# Show legend\nlegend = gj.Map(width=400, use_region=True)\nlegend.d_legend(raster=\"sentinel_rf\", \n                title=\"Classes\",\n                fontsize=14, \n                at=(10, 80, 10, 40), \n                flags=\"n\")\nlegend.show()\n```\n:::\n\n\n::: {.cell execution_count=100}\n``` {.python .cell-code}\n# Show class distribution in percent\nprint(gs.read_command(\"r.report\", \n                      map=\"sentinel_rf\", \n                      units=\"p\", \n                      flags=\"h\"))\n```\n:::\n\n\n::: {.cell execution_count=101}\n``` {.python .cell-code}\n# export map to GTiff (COG requires GDAL 3.1)\ngs.run_command(\"r.out.gdal\", \n               flags=\"fmt\", #\n               input=\"sentinel_rf\", \n               output=os.path.join(homedir, \"nc_sentinel2_RF.tif\"),\n               format=\"GTiff\", \n               overviews=\"4\")\n```\n:::\n\n\nKeep in mind, this classification was just a simplified example to show how the procedure works.\n\nAt this moment you should use [r.kappa](https://grass.osgeo.org/grass-stable/manuals/r.kappa.html) to calculate accuracy of classification. As this step would require either field observation data or manual interpretation of the scene, we'll leave this as an exercise to do at home.\n\n## 14. Supervised Classification: Maximum Likelihood\n\nWe will now demonstrate the workflow to perform a supervised maximum likelihood classification which is integrated with the semantic labels metadata class, and hence allow us to use the same spectral signature to classify multiple scenes as long as the raster map order in the group is the same.\n\nLet's first check the semantic labels of the bands in our `s2` group:\n\n::: {.cell execution_count=102}\n``` {.python .cell-code}\nband_list = gs.read_command(\"i.group\", group=\"s2\", flags=\"lg\")\n```\n:::\n\n\n::: {.cell execution_count=103}\n``` {.python .cell-code}\n# Add semantic label to the segmentation\ngs.run_command(\"r.support\", \n               map=\"sentinel_segments_min100\", \n               semantic_label=\"S2_seg\")\n```\n:::\n\n\n::: {.cell execution_count=104}\n``` {.python .cell-code}\nfor m in band_list.split():\n    sl = gs.raster_info(m)['semantic_label']\n    print(m,sl)\n```\n:::\n\n\nNow, we generate the signature file based on the training sample that we obtained earlier, this will then be the input for the maximum likelihood classification\n\n::: {.cell execution_count=105}\n``` {.python .cell-code}\n# obtain signature files\ngs.run_command(\"i.gensig\", \n               trainingmap=\"landuse_train\", \n               group=\"s2\", \n               subgroup=\"s2\", \n               signaturefile=\"sig_sentinel\")\n```\n:::\n\n\n::: {.cell execution_count=106}\n``` {.python .cell-code}\n# perform ML supervised classification\ngs.run_command(\"i.maxlik\", \n               group=\"s2\", \n               subgroup=\"s2\", \n               signaturefile=\"sig_sentinel\", \n               output=\"sentinel_maxlik\")\n```\n:::\n\n\n::: {.cell execution_count=107}\n``` {.python .cell-code}\n# check classes\nprint(gs.read_command(\"r.category\", \n                      map=\"sentinel_maxlik\", \n                      separator=\"comma\"))\n```\n:::\n\n\nIn GRASS 8.2+, [i.maxlik](https://grass.osgeo.org/grass-stable/manuals/i.maxlik.html) classifier does not preserve the original class values in the output. Thus, here is a lookup-table for original class numbers and new category values:\n\nclass|nlcd_class|landuse|RGB\n--- | --- | --- | --- \n1|11|Open Water|072:109:162\n2|21|Developed, Open Space|225:205:206\n3|22|Developed, Low Intensity|220:152:129\n4|23|Developed, Medium Intensity|241:001:000\n5|24|Developed, High Intensity|171:001:001\n6|41|Deciduous Forest|108:169:102\n7|42|Evergreen Forest|029:101:051\n8|43|Mixed Forest|189:204:147\n9|81|Hay/Pasture|221:216:062\n10|90|Woody Wetlands|187:215:237\n\n::: {.cell execution_count=108}\n``` {.python .cell-code}\n# Set color table\ncolours = [\"1 072:109:162\", \"2 225:205:206\", \"3 220:152:129\", \"4 241:001:000\", \"5 171:001:001\", \"6 108:169:102\", \"7 029:101:051\", \"8 189:204:147\", \"9 221:216:062\", \"10 187:215:237\"]\ngs.write_command(\"r.colors\", map=\"sentinel_maxlik\", rules=\"-\", stdin=\"\\n\".join(colours))\n```\n:::\n\n\n::: {.cell execution_count=109}\n``` {.python .cell-code}\n# display results\nmaxlik_sup_class = gj.Map(width=500, use_region=True)\nmaxlik_sup_class.d_rast(map=\"sentinel_maxlik\")\nmaxlik_sup_class.d_legend(raster=\"sentinel_maxlik\", \n                          title=\"Class\", \n                          fontsize=12, \n                          at=(70, 95, 75, 90), \n                          flags=\"bn\")\nmaxlik_sup_class.d_barscale()\nmaxlik_sup_class.show()\n```\n:::\n\n\n::: {.cell execution_count=110}\n``` {.python .cell-code}\n# percentage of each class\nprint(gs.read_command(\"r.report\", \n                      map=\"sentinel_maxlik\", \n                      units=\"p\", \n                      flags=\"h\"))\n```\n:::\n\n\n::: {.cell execution_count=111}\n``` {.python .cell-code}\n# class statistics: NDVI\nclass_stats = gs.read_command(\"r.univar\", \n                              map=\"T17SQV_20220528T155819_NDVI_10m\", \n                              zones=\"sentinel_maxlik\", \n                              flags=\"t\")\n```\n:::\n\n\n::: {.cell execution_count=112}\n``` {.python .cell-code}\npd.read_csv(StringIO(class_stats), \n            delimiter=\"|\", \n            usecols=[1, 4, 5, 7])\n```\n:::\n\n\nNext, and to demonstrate the use of semantic labels, we will classify another sentinel scene with the same signature obtained earlier. To this aim, we need to:\n1. create a new imagery group for a different scene with the exact same band order\n1. estimate NDVI and NDWI and assign semantic labels\n1. run a segmentation and assign semantic labels\n1. check group and semantic labels\n1. run `i.maxlik`\n\n<div class=\"alert alert-warning\">Be ware ‚Äì changes over time (phenology, weather) will make spectral signatures to not fit well or at all. Do not use same signatures for a different season!\n\n::: {.cell execution_count=113}\n``` {.python .cell-code}\ns2_maps = gs.list_grouped(type=\"raster\", pattern=\"*20220617*\")['sentinel2']\ns2_maps\n```\n:::\n\n\n::: {.cell execution_count=114}\n``` {.python .cell-code}\n# Since imagery groups can not be overwritten, \n# we delete any leftover \"s2_new\" group from previous runs\ngs.run_command(\"g.remove\", \n               type=\"group\", \n               name=\"s2_new\", \n               flags=\"f\")\n```\n:::\n\n\n::: {.cell execution_count=115}\n``` {.python .cell-code}\ngs.run_command(\"i.group\", group=\"s2_new\", subgroup=\"s2_new\", input=s2_maps)\nprint(gs.read_command(\"i.group\", group=\"s2_new\", flags=\"l\"))\n```\n:::\n\n\n::: {.cell execution_count=116}\n``` {.python .cell-code}\n# estimate NDVI\ngs.run_command(\"i.vi\", \n               red=\"T17SQV_20220617T155829_B04_10m\", \n               nir=\"T17SQV_20220617T155829_B08_10m\", \n               output=\"T17SQV_20220617T155829_NDVI_10m\", \n               viname=\"ndvi\")\n\n# add semantic label\ngs.run_command(\"r.support\", \n               map=\"T17SQV_20220617T155829_NDVI_10m\", \n               semantic_label=\"S2_NDVI\")\n```\n:::\n\n\n::: {.cell execution_count=117}\n``` {.python .cell-code}\n# estimate NDWI\ngs.run_command(\"i.wi\", \n               green=\"T17SQV_20220617T155829_B03_10m\", \n               nir=\"T17SQV_20220617T155829_B08_10m\", \n               output=\"T17SQV_20220617T155829_NDWI_10m\", \n               winame=\"ndwi_mf\")\n\n# add semantic label\ngs.run_command(\"r.support\", \n               map=\"T17SQV_20220617T155829_NDWI_10m\", \n               semantic_label=\"S2_NDWI\")\n```\n:::\n\n\n::: {.cell execution_count=118}\n``` {.python .cell-code}\n# add NDVI and NDWI to s2_mew group\ngs.run_command(\"i.group\", \n               group=\"s2_new\", \n               subgroup=\"s2_new\", \n               input=\"T17SQV_20220617T155829_NDVI_10m,T17SQV_20220617T155829_NDWI_10m\")\n\n# print maps in the group\nprint(gs.read_command(\"i.group\", group=\"s2_new\", flags=\"l\"))\n```\n:::\n\n\n::: {.cell execution_count=119}\n``` {.python .cell-code}\n# Run segmentation\ngs.run_command(\"i.segment\", \n               group=\"s2_new\", \n               threshold=\"0.05\", \n               minsize=\"100\", \n               output=\"sentinel_new_segments_min100\", \n               goodness=\"sentinel_new_segments_goodness_min100\")\n```\n:::\n\n\n::: {.cell execution_count=120}\n``` {.python .cell-code}\n# Add semantic label to the segmentation\ngs.run_command(\"r.support\", \n               map=\"sentinel_new_segments_min100\", \n               semantic_label=\"S2_seg\")\n```\n:::\n\n\n::: {.cell execution_count=121}\n``` {.python .cell-code}\n# Add segmentation to the s2_new group\ngs.parse_command(\"i.group\", group=\"s2_new\", subgroup=\"s2_new\", input=\"sentinel_new_segments_min100\")\n```\n:::\n\n\n::: {.cell execution_count=122}\n``` {.python .cell-code}\n# Check\nprint(gs.read_command(\"i.group\", group=\"s2_new\", flags=\"l\"))\n```\n:::\n\n\n::: {.cell execution_count=123}\n``` {.python .cell-code}\n# Run the classification\ngs.run_command(\"i.maxlik\", \n               group=\"s2_new\", \n               subgroup=\"s2_new\", \n               signaturefile=\"sig_sentinel\", \n               output=\"sentinel_maxlik_new\")\n```\n:::\n\n\n::: {.cell execution_count=124}\n``` {.python .cell-code}\n# Set color table\ncolours = [\"1 072:109:162\", \"2 225:205:206\", \"3 220:152:129\", \"4 241:001:000\", \"5 171:001:001\", \"6 108:169:102\", \"7 029:101:051\", \"8 189:204:147\", \"9 221:216:062\", \"10 187:215:237\"]\ngs.write_command(\"r.colors\", map=\"sentinel_maxlik_new\", rules=\"-\", stdin=\"\\n\".join(colours))\n```\n:::\n\n\n::: {.cell execution_count=125}\n``` {.python .cell-code}\n# display results\nmaxlik_sup_class = gj.Map(width=500, use_region=True)\nmaxlik_sup_class.d_rast(map=\"sentinel_maxlik_new\")\nmaxlik_sup_class.d_legend(raster=\"sentinel_maxlik_new\", \n                          title=\"Class\", \n                          fontsize=12, \n                          at=(60, 95, 70, 90), \n                          flags=\"bn\")\nmaxlik_sup_class.d_barscale()\nmaxlik_sup_class.show()\n```\n:::\n\n\n## 15. What's next?\n\nYou may enjoy more Jupyter notebooks at: https://github.com/OSGeo/grass/tree/main/doc/notebooks\n\n### Talk to us\n\n- Veronica Andreo, PhD, https://veroandreo.gitlab.io/\n- Markus Neteler, PhD, https://www.mundialis.de/en/neteler/\n- MƒÅris Narti≈°s, PhD\n\n### References\n\n- [GRASS GIS 8.2.0 Reference Manual](https://grass.osgeo.org/grass-stable/manuals/)\n- [GRASS GIS Addons Reference Manuals](https://grass.osgeo.org/grass-stable/manuals/addons/)\n- [GRASS GIS Python library documentation](https://grass.osgeo.org/grass-stable/manuals/libpython/)\n- [Unleash the power of GRASS GIS with Jupyter](https://github.com/ncsu-geoforall-lab/grass-gis-workshop-foss4g-2022)\n- List of [Tutorials](https://grass.osgeo.org/learn/tutorials/) at the GRASS GIS website\n\n",
    "supporting": [
      "grassgis4rs_colab_files"
    ],
    "filters": [],
    "includes": {}
  }
}