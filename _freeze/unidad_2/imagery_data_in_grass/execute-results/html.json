{
  "hash": "5397797204700b70fc70aa55466e6ed3",
  "result": {
    "markdown": "---\ntitle: Datos satelitales en GRASS GIS\nauthor: Verónica Andreo\ndate: today\nformat:\n  html:\n    code-tools: true\n    code-copy: true\n    code-fold: false\nexecute:\n  eval: false\n  cache: false\n  keep-ipynb: true\n---\n\nLos datos satelitales en general vienen en formato raster, por lo tanto aplican\nlas mismas reglas que vimos anteriormente. \nLos comandos **i.\\*** se orientan explícitamente al procesamiento de datos \nsatelitales aunque algunos puedan usarse para otros datos raster.\n\nPara ejemplificar el flujo de trabajo para procesamiento de datos satelitales \nen GRASS GIS, en esta primer sesión vamos a trabajar con datos del satélite \nLandsat 8.\n\nAntes de empezar y para ganar tiempo, conectamos nuestro drive e instalamos \nGRASS en Google Colab.\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\n# import drive from google colab\nfrom google.colab import drive\n# mount drive\ndrive.mount(\"/content/drive\")\n```\n:::\n\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\n%%bash\nDEBIAN_FRONTEND=noninteractive \nsudo add-apt-repository ppa:ubuntugis/ubuntugis-unstable \napt update \napt install grass subversion grass-dev\napt remove libproj22\n```\n:::\n\n\nChequeamos el path de instalación de GRASS\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\n!grass --config path\n```\n:::\n\n\ne instalamos otras librerías de python que nos serán útiles.\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\n!pip install pygdal\n!pip install landsatxplore\n```\n:::\n\n\n# Datos para esta sesión\n\n:::: columns\n:::{.column width=\"40%\"}\nEscenas Landsat 8 (OLI)\n\n- Fechas: 14/01/2020 y 02/03/2020\n- Path/Row: 229/082 (Córdoba)\n- CRS: UTM zona 20 N (EPSG:32620)\n:::\n\n:::{.column width=\"60%\"}\n![](https://landsat.gsfc.nasa.gov/wp-content/uploads/2021/12/ldcm_2012_COL-300x168-1.png){fig-align=\"center\"}\n:::\n::::\n\n<!-- Descargar las escenas [L8 14/01/2020 (979Mb)](https://drive.google.com/file/d/1ytQp-xin1FQr_hqtDJRLgK6g4eXwK-WI/view?usp=sharing) y [L8 02/03/2020 (880Mb)](https://drive.google.com/file/d/1Gg8FbhwpIQR-GyYepM4uw_9IOjEnji_N/view?usp=sharing) y moverlas a `$HOME/gisdata/landsat_data`. **No descomprimir!** -->\n\n\n# Historia de la mision Landsat\n\n![Lanzamientos de satélites Lansat desde 1972](https://landsat.gsfc.nasa.gov/wp-content/uploads/2020-07/Landsat_timeline_20200318_title.gif)\n\nEl sistema de escáner multiespectral (MSS) a bordo del Landsats 1-5 disponía de \ncuatro bandas. El Thematic Mapper (TM) a bordo de Landsats 4 y 5 tenía siete \nbandas. El Enhanced Thematic Mapper Plus (ETM+) del Landsat 7 tiene 8 bandas y \nlos Landsats 8 y 9 tienen 11 bandas. Fuente: <https://landsat.gsfc.nasa.gov/satellites/landsat-9/landsat-9-bands/>. \n\n![Comparación entre las bandas de todos los satélites Landsat](https://landsat.gsfc.nasa.gov/wp-content/uploads/2021/12/all_Landsat_bands.png){width=\"90%\"}\n\n:::{.callout-note}\nMás detalles sobre las misiones Landsat pueden encontrarse en: \n<https://www.usgs.gov/landsat-missions>\n:::\n\n\n# Manos a la obra\n\n## Iniciamos GRASS GIS\n\nIniciamos GRASS GIS en el proyecto *posgar2007_4_cba* y mapset *PERMANENT*\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nimport os\n\n# data directory\nhomedir = \"/content/drive/MyDrive/curso_grass_2023\"\n\n# GRASS GIS database variables\ngrassdata = os.path.join(homedir, \"grassdata\")\nproject = \"posgar2007_4_cba\"\nmapset = \"PERMANENT\"\n```\n:::\n\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\n# import standard Python packages we need\nimport sys\nimport subprocess\n\n# ask GRASS GIS where its Python packages are to be able to run it from the notebook\nsys.path.append(\n    subprocess.check_output([\"grass\", \"--config\", \"python_path\"], text=True).strip()\n)\n```\n:::\n\n\nAhora sí, estamos listos para importar los paquetes de GRASS e iniciar una\nsesión:\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\n# import the GRASS GIS packages we need\nimport grass.script as gs\nimport grass.jupyter as gj\n\n# Start the GRASS GIS Session\nsession = gj.init(grassdata, project, mapset)\n```\n:::\n\n\nCorroboramos la proyección\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\n# check the CRS\nprint(gs.read_command(\"g.proj\", flags=\"p\"))\n```\n:::\n\n\n## Crear un nuevo mapset\n\nPara diferenciar sesiones dentro del curso, vamos a crear un nuevo mapset \nllamado *landsat8*:\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\n# Create a new mapset\ngs.run_command(\"g.mapset\", \n               mapset=\"landsat8\",\n               flags=\"c\")\n```\n:::\n\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\n# Check we are in the mapset just created\ngs.run_command(\"g.mapset\",\n               flags=\"p\")\n```\n:::\n\n\nListamos los mapsets accesibles para corroborar que tenemos acceso a *PERMANENT*\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\n# list all the mapsets in the search path\ngs.mapsets(search_path=True)\n```\n:::\n\n\n:::{.callout-note}\nDesde cualquier mapset en el que estemos trabajando, siempre vamos a tener\nacceso a *PERMANENT*.\n:::\n\nListemos los mapas vectoriales disponibles\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\n# list vector maps in all mapsets in the search path\ngs.list_grouped(type=\"vector\")\n```\n:::\n\n\n## Región de interés\n\nComo primer paso para trabajar con datos raster,necesitamos establecer la región \ncomputacional. Para ello, vamos a extraer el radio urbano de Córdoba del vector\nde radios urbanos y luego lo vamos a usar para establecer los límites de nuestra\nregion computacional.\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\n# extract Cordoba urban area from `radios_urbanos`\ngs.run_command(\"v.extract\", \n               input=\"radios_urbanos\", \n               where=\"nombre == 'CORDOBA'\", \n               output=\"radio_urbano_cba\")\n```\n:::\n\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\n# set the computational region to the extent of Cordoba urban area\ngs.run_command(\"g.region\", \n               flags=\"p\", \n               vector=\"radio_urbano_cba\")\n```\n:::\n\n\n## Descargar e importar los datos Landsat 8\n\nEntre las extensiones disponibles, hay una extensión \n[i.landsat](https://grass.osgeo.org/grass-stable/manuals/addons/i.landsat.html), \nque nos permite buscar, filtrar, descargar, importar y aplicar bandas de calidad\na imágenes Landsat.\nPara la busqueda y descarga de datos, esta extensión depende de una librería de\npython denominada [landsatxplore](https://github.com/yannforget/landsatxplore).\n\nDesafortunadamente, landsatxplore fue abandonada por su autor, y es difícil de \nmantener. Estamos considerando utilizar otras opciones, pero es un WIP. Por este\nmotivo, vamos a instalar la extensión igualmente porque nos sirve para la \nimportación y enmascarado de pixeles según la calidad.\n\n:::{.callout-note}\nVoluntari@s para actualizar y testear los pull request de landsatxplore o \nactualizar i.landsat.download para que use otro paquete distinto, son mas que \nbienvenid@s!!\n:::\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\n# install i.landsat toolset\ngs.run_command(\"g.extension\",\n               extension=\"i.landsat\")\n```\n:::\n\n\nLa búsqueda de escenas se basa en la región computacional definida y funcionaría\ncomo se detalla a continuación.\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\n# search for Landsat 8 scenes\n# l8_credentials = os.path.join(homedir, \"gisdata\", \"landsat\")\n# gs.run_command(\"i.landsat.download\", \n#               settings=l8_credentials,\n#               dataset=\"landsat_8_c1\",\n#               clouds=\"35\",\n#               start=\"2019-10-27\",\n#               end=\"2020-03-15\",\n#               flags=\"l\")\n```\n:::\n\n\nPor defecto, usando el comando anterior sin la opción *l* y proveyendo una carpeta\nde descarga, se descargarían todas las imágenes encontradas anteriormente. \nSin embargo, también es posible descargar imágenes seleccionadas via su *id*.\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\n# download selected scenes\n# gs.run_command(\"i.landsat.download\", \n#               settings=l8_credentials,\n#               id=\"LC82290822020062LGN00,LC82290822020014LGN00\",\n#               output=os.path.join(homedir, \"gisdata\", \"landsat_data\"))\n```\n:::\n\n\nComo el módulo de descarga no está andando y porque la descarga puede tomar mucho \ntiempo con conexiones lentas, vamos a usar imágenes previamente descargadas.\nComo primer paso vamos a imprimir todas las bandas presentes dentro de la carpeta\n`landsat_data`.\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\n# print all landsat bands within landsat_data folder\n# (1: projection match, 0: projection does not match)\ngs.run_command(\"i.landsat.import\",\n               input=os.path.join(homedir, \"gisdata\", \"landsat_data\"),\n               flags=\"p\")\n```\n:::\n\n\nTambién podemos imprimir sólo las bandas seleccionadas con un patrón.\n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\n# print a selection of bands - might be sloooow\ngs.run_command(\"i.landsat.import\",\n               input=os.path.join(homedir, \"gisdata\", \"landsat_data\"), \n               pattern=\"B(2|3|4|5|6|8)\",\n               flags=\"p\")\n```\n:::\n\n\nPara empezar a trabajar con los datos L8, vamos entonces a importar todas las \nbandas, recortar a la región y reproyectar al vuelo, ya que vimos que su CRS\nno coincide con el del proyecto donde nos encontramos.\n\n::: {.cell execution_count=20}\n``` {.python .cell-code}\n# import all bands, subset to region and reproject\ngs.run_command(\"i.landsat.import\", \n               input=os.path.join(homedir, \"gisdata\", \"landsat_data\"), \n               extent=\"region\",\n               flags=\"r\")\n```\n:::\n\n\nListamos las bandas importadas y revisamos los metadatos de alguna de ellas.\n\n::: {.cell execution_count=21}\n``` {.python .cell-code}\n# list raster maps\ngs.list_grouped(type=\"raster\")[\"landsat8\"]\n```\n:::\n\n\n::: {.cell execution_count=22}\n``` {.python .cell-code}\n# check metadata of some imported bands\ngs.raster_info(map=\"LC08_L1TP_229082_20200114_20200127_01_T1_B4\")\n```\n:::\n\n\n## Pre-procesamiento de datos satelitales\n\n![Workflow de pre-procesamiento de datos satelitales](../assets/img/rs_workflow.jpg){width=70% fig-align=\"center\"}\n\n### De número digital (ND) a reflectancia y temperatura\n\n- Los datos L8 OLI vienen en 16-bits con rango de datos entre 0 y 65535.\n- [i.landsat.toar](https://grass.osgeo.org/grass-stable/manuals/i.landsat.toar.html) \nconvierte los números digitales (ND) en reflectancia TOA (y temperatura de brillo) \npara todos los sensores Landsat. Opcionalmente proporciona reflectancia de \nsuperficie (BOA) después de la corrección DOS. \n- [i.atcorr](https://grass.osgeo.org/grass-stable/manuals/i.atcorr.html) proporciona\nun método de corrección atmosférica más complejo para gran variedad de sensores \n(S6).\n\n\nAntes de comenzar a procesar los datos, vamos a definir la resolución de la \nregión computacional a una banda de 30 m.\n\n::: {.cell execution_count=23}\n``` {.python .cell-code}\n# set the region to a 30m band\ngs.run_command(\"g.region\", \n               raster=\"LC08_L1TP_229082_20200114_20200127_01_T1_B4\", \n               flags=\"p\")\n```\n:::\n\n\nAhora sí, convertimos los ND a reflectancia superficial y temperatura usando el \nmétodo Dark Object Substraction (DOS).\n\n::: {.cell execution_count=24}\n``` {.python .cell-code}\n# convert from DN to surface reflectance and temperature\nmetadata = os.path.join(homedir, \"gisdata\", \"landsat_data\", \"LC08_L1TP_229082_20200114_20200127_01_T1_MTL.txt\")\ngs.run_command(\"i.landsat.toar\",\n               input=\"LC08_L1TP_229082_20200114_20200127_01_T1_B\",\n               output=\"LC08_229082_20200114_SR_B\",\n               sensor=\"oli8\",\n               metfile=metadata,\n               method=\"dos1\")\n```\n:::\n\n\nCorroboremos los metadatos antes y después de la conversión ND >> RS para una\nbanda.\n\n::: {.cell execution_count=25}\n``` {.python .cell-code}\n# list output maps\ngs.list_grouped(type=\"raster\",\n                pattern=\"*SR*\")[\"landsat8\"]\n```\n:::\n\n\n::: {.cell execution_count=26}\n``` {.python .cell-code}\n# check info before and after for one band\nprint(gs.read_command(\"r.info\", \n                      map=\"LC08_L1TP_229082_20200114_20200127_01_T1_B3\"))\n```\n:::\n\n\n::: {.cell execution_count=27}\n``` {.python .cell-code}\nprint(gs.read_command(\"r.info\", \n                      map=\"LC08_229082_20200114_SR_B3\"))\n```\n:::\n\n\n::: {.cell execution_count=28}\n``` {.python .cell-code}\n# Visualize results\nb3_map=gj.InteractiveMap(width = 500, tiles=\"OpenStreetMap\")\nb3_map.add_raster(\"LC08_L1TP_229082_20200114_20200127_01_T1_B3\")\nb3_map.add_raster(\"LC08_229082_20200114_SR_B3\")\nb3_map.add_layer_control(position = \"bottomright\")\nb3_map.show()\n```\n:::\n\n\n:::{.callout-caution title=\"Tarea Opcional\"}\nSeguir los mismos pasos para la escena del 02/03/2020. ¿Qué notan de diferente?\n:::\n\n\n### Ajuste de color y composiciones RGB\n\nPara lograr una buena visualización en composiciones RGB, primero realizamos un \najuste de colores utilizando el módulo \n[i.colors.enhance](https://grass.osgeo.org/grass-stable/manuals/i.colors.enhance.html).\n\n::: {.cell execution_count=29}\n``` {.python .cell-code}\n# enhance the colors\ngs.run_command(\"i.colors.enhance\",\n               red=\"LC08_229082_20200114_SR_B4\",\n               green=\"LC08_229082_20200114_SR_B3\", \n               blue=\"LC08_229082_20200114_SR_B2\",\n               strength=\"95\")\n```\n:::\n\n\nVisualicemos la combinacion RGB color natural usando `gj.Map`.\n\n::: {.cell execution_count=30}\n``` {.python .cell-code}\n# display RGB\nrgb_map = gj.Map(width=450, use_region=True)\nrgb_map.d_rgb(red=\"LC08_229082_20200114_SR_B4\",\n              green=\"LC08_229082_20200114_SR_B3\", \n              blue=\"LC08_229082_20200114_SR_B2\",)\nrgb_map.show()\n```\n:::\n\n\n:::{.callout-caution title=\"Tarea\"}\nHagamos una composición falso color 543. ¿Sobre qué bandas debieran realizar el\najuste? \n:::\n\n### Enmascarado de nubes con banda QA\n\n- Landsat 8 proporciona una banda de calidad (quality assessment, QA) con valores\nenteros de 16 bits que representan las combinaciones de superficie, atmósfera y \ncondiciones del sensor que pueden afectar la utilidad general de un determinado \npixel. \n- La extensión \n[i.landsat.qa](https://grass.osgeo.org/grass-stable/manuals/addons/i.landsat.qa.html) \nreclasifica la banda QA de Landsat 8 de acuerdo a la calidad del pixel. \n\n:::{.callout-note}\nMás información sobre la banda QA de L8 en la [guía de usuario](https://d9-wret.s3.us-west-2.amazonaws.com/assets/palladium/production/s3fs-public/media/files/LSDS-1619_Landsat8-9-Collection2-Level2-Science-Product-Guide-v5.pdf).\n:::\n \nVamos a utilizar i.landsat.qa para crear las reglas necesarias para identificar\nlas nubes y sombras de nubes en las escenas L8.\n\n::: {.cell execution_count=31}\n``` {.python .cell-code}\n# create a rule set\ngs.run_command(\"i.landsat.qa\",\n               dataset=\"landsat_8_c1\",\n               cloud_shadow_confidence=\"Medium,High\",\n               cloud_confidence=\"Medium,High\",\n               output=os.path.join(homedir, \"Cloud_Mask_rules.txt\"))\n```\n:::\n\n\nCon las reglas que creamos anteriormente, reclasificamos la banda QA para obtener \nun mapa ráster que podamos luego usar como máscara.\n\n::: {.cell execution_count=32}\n``` {.python .cell-code}\n# reclass the BQA band based on the rule set created\ngs.run_command(\"r.reclass\",\n               input=\"LC08_L1TP_229082_20200114_20200127_01_T1_BQA\",\n               output=\"LC08_229082_20200114_Cloud_Mask\",\n               rules=os.path.join(homedir, \"Cloud_Mask_rules.txt\"))\n```\n:::\n\n\nPara estimar la superficie cubierta por nubes y sombras de nubes, usamos el \nmódulo [r.report](https://grass.osgeo.org/grass-stable/manuals/r.report.html).\n\n::: {.cell execution_count=33}\n``` {.python .cell-code}\n# report % of clouds and shadows\nprint(gs.read_command(\"r.report\",\n                      map=\"LC08_229082_20200114_Cloud_Mask\",\n                      units=\"p\",\n                      flags=\"e\"))\n```\n:::\n\n\nVisualizamos el mapa reclasificado.\n\n::: {.cell execution_count=34}\n``` {.python .cell-code}\n# display reclassified map over RGB\nrgb_map.d_rast(map=\"LC08_229082_20200114_Cloud_Mask\")\nrgb_map.show()\n```\n:::\n\n\n## Fusión de datos/Pansharpening\n\nVamos a usar la banda pancromática (15 m) para mejorar la definición de las bandas \nespectrales de 30 m, por medio de: \n[i.fusion.hpf](https://grass.osgeo.org/grass-stable/manuals/addons/i.fusion.hpf.html), \nque aplica un método de adición basado en un filtro de paso alto. \nOtros métodos de pansharpening están implementados en el módulo \n[i.pansharpen](https://grass.osgeo.org/grass-stable/manuals/i.pansharpen.html).\n\nComo primer paso, instalamos la extensión *i.fusion.hpf*.\n\n::: {.cell execution_count=35}\n``` {.python .cell-code}\n# Install the reqquired addon\ngs.run_command(\"g.extension\",\n               extension=\"i.fusion.hpf\")\n```\n:::\n\n\nLuego, como vamos a \"mejorar\" la resolución espacial de las bandas multiespectrales \na 15 m, necesitamos alinear la resolución de la región computacional a la banda PAN.\n\n::: {.cell execution_count=36}\n``` {.python .cell-code}\n# Set the region to PAN band (15m)\ngs.run_command(\"g.region\",\n               raster=\"LC08_229082_20200114_SR_B8\",\n               flags=\"p\")\n```\n:::\n\n\n... y ejecutamos la fusión.\n\n::: {.cell execution_count=37}\n``` {.python .cell-code}\n# list bands\nms_bands = gs.list_grouped(type=\"raster\", \n                           pattern=\"*_SR_B[1-7]\")[\"landsat8\"]\nms_bands\n```\n:::\n\n\n::: {.cell execution_count=38}\n``` {.python .cell-code}\n# Apply the fusion based on high pass filter\ngs.run_command(\"i.fusion.hpf\",\n               pan=\"LC08_229082_20200114_SR_B8\", \n               msx=ms_bands,\n               suffix=\"hpf\", \n               center=\"high\", \n               modulation=\"max\", \n               trim=\"0.0\", \n               flags=\"lc\")\n```\n:::\n\n\nFinalmente, listamos los mapas resultantes usando un patrón de búsqueda\n\n::: {.cell execution_count=39}\n``` {.python .cell-code}\n# list the fused maps\ngs.list_grouped(type=\"raster\", \n                pattern=\"*.hpf\")[\"landsat8\"]\n```\n:::\n\n\n::: {.cell execution_count=40}\n``` {.python .cell-code}\n# check info of a pansharpened band\ngs.raster_info(\"LC08_229082_20200114_SR_B4.hpf\")\n```\n:::\n\n\ny visualizamos las diferencias con `gj.InteractiveMap`.\n\n::: {.cell execution_count=41}\n``` {.python .cell-code}\n# display original and fused maps\nhpf_map = gj.InteractiveMap(width = 500, tiles=\"OpenStreetMap\")\nhpf_map.add_raster(\"LC08_229082_20200114_SR_B4\")\nhpf_map.add_raster(\"LC08_229082_20200114_SR_B4.hpf\")\nhpf_map.add_layer_control(position = \"bottomright\")\nhpf_map.show()\n```\n:::\n\n\n## Índices de agua y vegetación\n\nEn esta sección vamos a estimar los conocidos índices de vegetación y agua. No\nobstante, necesitamos primero, establecer la máscara de nubes y sombras de nubes\nobtenida anteriormente para evitar el cómputo de los índices sobre estas áreas.\n\n::: {.cell execution_count=42}\n``` {.python .cell-code}\n# Set the cloud mask to avoid computing over clouds\ngs.run_command(\"r.mask\",\n               raster=\"LC08_229082_20200114_Cloud_Mask\")\n```\n:::\n\n\nCalculamos el NDVI y establecemos la paleta de colores.\n\n::: {.cell execution_count=43}\n``` {.python .cell-code}\n# Compute NDVI\nndvi_formula = \"LC08_229082_20200114_NDVI = (LC08_229082_20200114_SR_B5.hpf - LC08_229082_20200114_SR_B4.hpf) / (LC08_229082_20200114_SR_B5.hpf + LC08_229082_20200114_SR_B4.hpf) * 1.0\"\ngs.mapcalc(exp=ndvi_formula)\n\n# Set the color palette\ngs.run_command(\"r.colors\",\n               map=\"LC08_229082_20200114_NDVI\",\n               color=\"ndvi\")\n```\n:::\n\n\nCalculamos el NDWI y establecemos la paleta de colores.\n\n::: {.cell execution_count=44}\n``` {.python .cell-code}\n# Compute NDWI\nndwi_formula = \"LC08_229082_20200114_NDWI = (LC08_229082_20200114_SR_B5.hpf - LC08_229082_20200114_SR_B6.hpf) / (LC08_229082_20200114_SR_B5.hpf + LC08_229082_20200114_SR_B6.hpf) * 1.0\"\ngs.mapcalc(exp=ndwi_formula)\n\n# Set the color palette\ngs.run_command(\"r.colors\",\n               map=\"LC08_229082_20200114_NDWI\",\n               color=\"ndwi\")\n```\n:::\n\n\nVisualizamos los mapas resultantes.\n\n::: {.cell execution_count=45}\n``` {.python .cell-code}\nndi = gj.InteractiveMap(width=450, use_region=True)\nndi.add_raster(\"LC08_229082_20200114_NDVI\")\nndi.add_raster(\"LC08_229082_20200114_NDWI\")\nndi.add_layer_control(position = \"bottomright\")\nndi.show()\n```\n:::\n\n\n:::{.callout-warning title=\"Tarea Opcional\"}\nEstimar NDVI y NDWI para la otra escena usando el módulo [i.vi](https://grass.osgeo.org/grass-stable/manuals/i.vi.html).\n:::\n\n\n## Clasificación No Supervisada\n\nLos pasos para realizar una clasificación no supervisada en GRASS, implican:\n\n- Asignar semantic labels a las bandas con [r.semantic.label](https://grass.osgeo.org/grass-stable/manuals/r.semantic.label.html) \no [r.support](https://grass.osgeo.org/grass-stable/manuals/r.support.html)\n- Agrupar las bandas (i.e., hacer un stack): [i.group](https://grass.osgeo.org/grass-stable/manuals/i.group.html)\n- Generar firmas para *n* número de clases: [i.cluster](https://grass.osgeo.org/grass-stable/manuals/i.cluster.html)\n- Clasificar usando las firmas: [i.maxlik](https://grass.osgeo.org/grass-stable/manuals/i.maxlik.html)\n\n\n#### ¿Qué son los semantic labels?\n\nLos *semantic labels* son etiquetas que podemos agregar a cualquier mapa ráster\ny que nos indican qué variable está representada en ese mapa.\nEstas etiquetas son especialmente relevantes para las imágenes de satélite, \nya que nos permiten identificar a qué sensor y banda corresponde el mapa. \nSon útiles a la hora de trabajar con colecciones de imágenes de satélite y \ntambién a la hora de clasificar diferentes escenas. \n\nPor ejemplo, si generamos firmas espectrales para unas clases usando un \ndeterminado conjunto de bandas, estas firmas pueden reutilizarse para \nclasificar otra escena siempre que las etiquetas semánticas sean las mismas. \n\n¡Cuidado! Aunque es posible reutilizar las firmas espectrales para cualquier \nescena con las mismas bandas, los cambios temporales (estaciones, impacto \nmeteorológico) limitan su aplicabilidad sólo a escenas obtenidas más o menos \nal mismo tiempo.\n\nProbemos entonces, asignar semantic labels a las bandas de L8 y los índices de\nvegetación.\n\n::: {.cell execution_count=46}\n``` {.python .cell-code}\n# list the bands needed for classification\nbands = gs.list_grouped(type=\"raster\",\n                        pattern=\"*_SR*hpf\")[\"landsat8\"]\nbands\n```\n:::\n\n\n::: {.cell execution_count=47}\n``` {.python .cell-code}\n# semantic labels list\nlabels = [\"L8_1\", \"L8_2\", \"L8_3\", \"L8_4\", \"L8_5\", \"L8_6\", \"L8_7\"]\n```\n:::\n\n\nPara bandas de satélites como Landsat y Sentinel, usamos el comando [r.sematic.label](https://grass.osgeo.org/grass-stable/manuals/r.semantic.label.html) que toma metadatos sobre los labels de [i.band.library](https://grass.osgeo.org/grass-stable/manuals/i.band.library.html). Es posible agregar bandas de otros satélites siempre que se siga un determinado formato.\n\n::: {.cell execution_count=48}\n``` {.python .cell-code}\n# add semantic labels to bands\ngs.run_command(\"r.semantic.label\",\n               map=bands,\n               semantic_label=labels, \n               operation=\"add\")\n```\n:::\n\n\nPara cualquier otro ráster al que deseemos agregar una etiqueta, usamos [r.support](https://grass.osgeo.org/grass-stable/manuals/r.support.html) que nos permite agregar distintos metadatos a nuestros datos en GRASS.\n\n::: {.cell execution_count=49}\n``` {.python .cell-code}\n# add semantic labels to indices\nfor i in [\"NDVI\", \"NDWI\"]:\n    gs.run_command(\"r.support\", \n                   map=f\"LC08_229082_20200114_{i}\",\n                   semantic_label=i)\n```\n:::\n\n\nImprimimos los semantic labels\n\n::: {.cell execution_count=50}\n``` {.python .cell-code}\ngs.raster_info(\"LC08_229082_20200114_SR_B7.hpf\")[\"semantic_label\"]\n```\n:::\n\n\nCreamos un grupo de imágenes o *stack* con las bandas 1 a 7 más el NDVI y el NDWI.\n\n::: {.cell execution_count=51}\n``` {.python .cell-code}\n# add ndvi and ndwi to the list of bands\nfor i in [\"NDVI\", \"NDWI\"]:\n    bands.append(f\"LC08_229082_20200114_{i}\")\n\nbands\n```\n:::\n\n\n::: {.cell execution_count=52}\n``` {.python .cell-code}\n# create an imagery group with the list of bands\ngs.run_command(\"i.group\",\n               group=\"l8\",\n               subgroup=\"l8\",\n               input=bands)\n```\n:::\n\n\n::: {.cell execution_count=53}\n``` {.python .cell-code}\n# print elements within the group \ngs.run_command(\"i.group\",\n               group=\"l8\",\n               flags=\"l\")\n```\n:::\n\n\nObtenemos estadísticos -firmas- para las *n* clases de interés con una muestra\nde pixeles\n\n::: {.cell execution_count=54}\n``` {.python .cell-code}\n# statistics for unsupervised classification\ngs.run_command(\"i.cluster\",\n               group=\"l8\",\n               subgroup=\"l8\",\n               sig=\"l8_hpf\",\n               classes=\"7\",\n               separation=\"0.6\")\n```\n:::\n\n\nUsamos las firmas espectrales para realizar la clasificación no supervisada de\ntoda la imagen\n\n::: {.cell execution_count=55}\n``` {.python .cell-code}\n# Maximum Likelihood unsupervised classification\ngs.run_command(\"i.maxlik\",\n               group=\"l8\",\n               subgroup=\"l8\",\n               sig=\"l8_hpf\",\n               output=\"l8_hpf_class\",\n               rej=\"l8_hpf_rej\")\n```\n:::\n\n\n::: {.cell execution_count=56}\n``` {.python .cell-code}\n# Mostrar el mapa clasificado con `InteractiveMap`\nclas = gj.InteractiveMap(width=450, use_region=True)\nclas.add_raster(\"l8_hpf_class\")\nclas.add_layer_control(position = \"bottomright\")\nclas.show()\n```\n:::\n\n\n### Información derivada adicional\n\nUsualmente, para realizar clasificaciones, derivamos muchas variables a partir \nde las bandas de sensores satelitales multiespectrales. Otra información podría\nobtenerse con los siguientes módulos, entre otros:\n\n- medidas de textura: \n[r.texture](https://grass.osgeo.org/grass-stable/manuals/r.texture.html), \n- medidas de diversidad: \n[r.diversity](https://grass.osgeo.org/grass-stable/manuals/addons/r.diversity.html), \n- estadísticas locales con información de contexto: [r.neighbors](https://grass.osgeo.org/grass-stable/manuals/r.neighbors.html),\n- transformación tasseled cap: [i.tasscap](https://grass.osgeo.org/grass-stable/manuals/i.tasscap.html),\n- etc.\n\n\n# Info y ejercicios de clasificación en GRASS GIS\n\n- [Topic classification](http://grass.osgeo.org/grass-stable/manuals/topic_classification.html) en los manuales de GRASS GIS\n- [Image classification](http://grasswiki.osgeo.org/wiki/Image_classification) en la wiki\n- [Ejemplos de clasificación](http://training.gismentors.eu/grass-gis-irsae-winter-course-2018/units/28.html) en el curso dictado en Noruega en 2018\n- [Detección de cambios con Landsat](https://veroandreo.gitlab.io/post/jan2021_ilandsat_tutorial/)\n- [Taller GRASS para sensado remoto en FOSS4G 2022](https://github.com/veroandreo/foss4g2022_grass4rs)\n\n",
    "supporting": [
      "imagery_data_in_grass_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}