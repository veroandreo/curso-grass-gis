{
  "hash": "bc25ea07557bcb396b40694155c3e879",
  "result": {
    "markdown": "---\ntitle: 'Ejercicio: OBIA en GRASS GIS'\nauthor: Verónica Andreo\ndate: today\nformat:\n  html:\n    code-tools: true\n    code-copy: true\n    code-fold: false\nexecute:\n  eval: false\n  cache: false\n  keep-ipynb: true\n---\n\nEn este ejercicio vamos a ejemplificar el flujo de trabajo para realizar una\nclasificación supervisada basada en objetos con datos SPOT. \n\n\n# Datos para esta sesión\n\n:::: columns\n:::{.column width=\"60%\"}\n![](../assets/img/obia_region.png)\n:::\n\n:::{.column width=\"40%\"}\n- [SPOT 6](https://www.eoportal.org/satellite-missions/spot-6-7)\n- Canales VIS - NIR (6 m)\n- Canal PAN (1.5 m)\n- Datos ya corregidos y fusionados; resolución 1.5 m\n:::\n::::\n\n# Manos a la obra\n\n## Iniciamos GRASS GIS\n\nIniciamos GRASS GIS en el proyecto *posgar2007_4_cba* y mapset *PERMANENT*.\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport os\n\n# data directory\nhomedir = os.path.expanduser('~')\n\n# GRASS GIS database variables\ngrassdata = os.path.join(homedir, \"grassdata\")\nproject='posgar2007_4_cba'\nmapset='PERMANENT'\n```\n:::\n\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\n# import standard Python packages we need\nimport subprocess\nimport sys\n\n# ask GRASS GIS where its Python packages are to be able to start it from the notebook\nsys.path.append(\n    subprocess.check_output([\"grass\", \"--config\", \"python_path\"], text=True).strip()\n)\n```\n:::\n\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\n# import the GRASS GIS packages we need\nimport grass.script as gs\nimport grass.jupyter as gj\n\n# start the GRASS GIS Session\nsession = gj.init(grassdata, project, mapset)\n```\n:::\n\n\n:::{.callout-warning title=\"Tarea\"}\n- Crear un mapset llamado *`obia_spot`* e importar allí las bandas VIS-NIR y PAN de la imagen SPOT con reproyección al vuelo y resolución espacial de 1.5 m.\n- Alinear la región computacional a la extensión y resolución de alguna de las bandas importadas.\n- Hacer una ecualización de histograma para mejorar el contraste de visualización.\n- Mostrar la combinación RGB color natural (1: azul, 2: verde, 3: rojo, 4: NIR).\n:::\n\n## Importar datos y visualizar\n\nCreamos el mapset *obia_spot*.\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\n# Create a new mapset\ngs.run_command(\"g.mapset\",\n               mapset=\"obia_spot\",\n               flags=\"c\")\n```\n:::\n\n\nUna vez creado el mapset, procedemos con la importación de datos. Empezamos por las bandas multi-espectrales.\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nspot_data = os.path.join(homedir, \"gisdata\", \"spot_data\")\n```\n:::\n\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\n# import pansharpened SPOT data\ngs.run_command(\"r.import\",\n               input=os.path.join(spot_data, \"SPOT_20180621_PANSHARP_p.tif\"),\n               output=\"SPOT_20180621_PANSHARP\",\n               resolution=\"value\",\n               resolution_value=1.5)\n```\n:::\n\n\nImportamos también la banda pancromática.\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\n# import SPOT PAN band\ngs.run_command(\"r.import\",\n               input=os.path.join(spot_data, \"SPOT_20180621_PAN.tif\"),\n               output=\"SPOT_20180621_PAN\",\n               resolution=\"value\",\n               resolution_value=1.5)\n```\n:::\n\n\nChequeamos la lista de mapas raster en el mapset.\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\ngs.list_grouped(type=\"raster\")[\"obia_spot\"]\n```\n:::\n\n\nEstablecemos la región computacional a una de las bandas importadas, de modo que límites y resolución de la región queden alineados a los datos importados.\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\n# align region to one of the raster bands\ngs.run_command(\"g.region\",\n               raster=\"SPOT_20180621_PANSHARP.1\",\n               flags=\"p\")\n```\n:::\n\n\nEstablecemos *grey* como paleta de colores para las bandas RGB, para poder realizar la composición color natural posteriormente.\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\n# apply grey color to RGB bands\ngs.run_command(\"r.colors\", \n               map=\"SPOT_20180621_PANSHARP.1,SPOT_20180621_PANSHARP.2,SPOT_20180621_PANSHARP.3\",\n               color=\"grey\")\n```\n:::\n\n\nPrimero, hacemos la ecualización de colores para mejorar la visualización.\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\n# perform color auto-balancing for RGB bands\ngs.run_command(\"i.colors.enhance\", \n               red=\"SPOT_20180621_PANSHARP.3\",\n               green=\"SPOT_20180621_PANSHARP.2\", \n               blue=\"SPOT_20180621_PANSHARP.1\",\n               strength=95)\n```\n:::\n\n\nVisualizamos la composición RGB 321 color natural.\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\n# display the enhanced RGB combination\ncba_rgb = gj.Map(use_region=False)\ncba_rgb.d_rgb(red=\"SPOT_20180621_PANSHARP.3\",\n              green=\"SPOT_20180621_PANSHARP.2\",\n              blue=\"SPOT_20180621_PANSHARP.1\")\ncba_rgb.d_grid(size=2000, flags=\"b\")\ncba_rgb.show()\n```\n:::\n\n\n## Hay valores nulos?\n\nEn la cadena de procesamiento que vamos a realizar, especialmente en los pasos de segmentación, no se admiten valores nulos en los mapas de entrada. Así que, como primer paso antes de proceder, chequeamos la estadística univariada para saber si hay valores nuelos en nuestros mapas.\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\n# one band\nprint(gs.read_command(\"r.univar\",\n                      map=\"SPOT_20180621_PANSHARP.2\"))\n```\n:::\n\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\n# bands list\npansharp = gs.list_grouped(type=\"raster\",\n                           pattern=\"*PANSHARP*\")[\"obia_spot\"]\npansharp\n```\n:::\n\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\n# joint stats for all the bands\nprint(gs.read_command(\"r.univar\",\n                      map=pansharp))\n```\n:::\n\n\n:::{.callout-important}\nSi hubiera valores nulos, se deben rellenar antes de comenzar! Qué herramientas podríamos utilizar?\n:::\n\n## Índices espectrales y texturas GLCM\n\nComo ya hicimos en los ejercicios anteriores, estimamos índices espectrales de vegetación y agua. \n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\n# estimate vegetation index\ngs.run_command(\"i.vi\", \n               red=\"SPOT_20180621_PANSHARP.3\", \n               nir=\"SPOT_20180621_PANSHARP.4\", \n               output=\"SPOT_20180621_NDVI\", \n               viname=\"ndvi\")\n```\n:::\n\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\n# estimate water index\ngs.run_command(\"i.wi\", \n               green=\"SPOT_20180621_PANSHARP.2\", \n               nir=\"SPOT_20180621_PANSHARP.4\", \n               output=\"SPOT_20180621_NDWI\", \n               winame=\"ndwi_mf\")\n```\n:::\n\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\n# set ndwi color palette\ngs.run_command(\"r.colors\", \n               map=\"SPOT_20180621_NDWI\", \n               color=\"ndwi\")\n```\n:::\n\n\nPor otra parte, vamos a estimar medidas de textura con [r.texture](https://grass.osgeo.org/grass-stable/manuals/r.texture.html). En este caso, elegimos Inverse Difference Moment (IDM) y Angular Second Moment (ASM), pero hay muchas otras opciones. Este módulo puede ser muy lento si la región computacional es muy grande y si el tamaño de la ventana es grande también. Para agilizar los cálculos en estos casos, se puede usar la extensión [r.texture.tiled](https://grass.osgeo.org/grass-stable/manuals/addons/r.texture.tiled.html).\n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\n# estimate textures measures\ngs.run_command(\"r.texture\",\n               input=\"SPOT_20180621_PAN\",\n               output=\"SPOT_20180621\",\n               size=7,\n               distance=3,\n               method=\"idm,asm\")\n```\n:::\n\n\n::: {.cell execution_count=20}\n``` {.python .cell-code}\n# set color table to grey for texture bands\ngs.run_command(\"r.colors\", \n               map=\"SPOT_20180621_IDM\", \n               color=\"grey\",\n               flags=\"e\")\ngs.run_command(\"r.colors\", \n               map=\"SPOT_20180621_ASM\", \n               color=\"grey\",\n               flags=\"e\")\n```\n:::\n\n\nVisualizamos las bandas creadas.\n\n::: {.cell execution_count=21}\n``` {.python .cell-code}\nidx_map = gj.InteractiveMap(width = 400, use_region=False, tiles=\"OpenStreetMap\")\nidx_map.add_raster(\"SPOT_20180621_NDVI\", opacity=0.7)\nidx_map.add_raster(\"SPOT_20180621_NDWI\", opacity=0.7)\nidx_map.add_raster(\"SPOT_20180621_IDM\", opacity=0.7)\nidx_map.add_raster(\"SPOT_20180621_ASM\", opacity=0.7)\nidx_map.add_layer_control(position = \"bottomright\")\nidx_map.show()\n```\n:::\n\n\n:::{.callout-note}\nSobre qué banda calculamos las texturas? Si no contamos con una banda \npancromática, podemos crearla promediando las bandas visibles\n\n::: {.cell execution_count=22}\n``` {.python .cell-code}\n# create pan-vis from RGB (if no pan available)\nR = \"SPOT_20180621_PANSHARP.3\"\nG = \"SPOT_20180621_PANSHARP.2\"\nB = \"SPOT_20180621_PANSHARP.1\"\n\ngs.mapcalc(exp=f\"PANVIS = round(({R} + {G} + {B}) / 3)\"\n```\n:::\n\n\n:::\n\n## Segmentación\n\n### Búsqueda de umbrales de sub y sobre-segmentación\n\nComo vimos en el ejercicio anterior, usualmente, los módulos **i.\\*** toman un grupo de mapas como entrada. Antes de comenzar con la segmentación, entonces, creamos un grupo con las bandas multiespectrales únicamente.\n\n::: {.cell execution_count=23}\n``` {.python .cell-code}\n# create imagery group (only ms bands)\ngs.run_command(\"i.group\",\n               group=\"spot_bands\",\n               input=pansharp)\n```\n:::\n\n\nAhora vamos a aprovechar una de las grandes ventajas de la región computacional, i.e., definir una región más pequeña para realizar unas pruebas :)\n\n::: {.cell execution_count=24}\n``` {.python .cell-code}\n# set smaller region\ngs.run_command(\"g.region\",\n               n=6525171,\n               s=6523179,\n               w=4390557,\n               e=4393257)\ngs.run_command(\"g.region\",\n               save=\"obia_subset\")\ngs.region()\n```\n:::\n\n\nAhora sí, ejecutamos un par de segmentaciones para determinar niveles de sub- y sobre-segmentación. Empezamos con un umbral pequeño.\n\n::: {.cell execution_count=25}\n``` {.python .cell-code}\n# run segmentation - small threshold\ngs.run_command(\"i.segment\",\n               group=\"spot_bands\",\n               output=\"segment_001\",\n               threshold=0.01,\n               memory=2000)\n```\n:::\n\n\n::: {.cell execution_count=26}\n``` {.python .cell-code}\n# convert output to vector\ngs.run_command(\"r.to.vect\",\n               input=\"segment_001\",\n               output=\"segment_001\",\n               type=\"area\",\n               flags=\"tv\")\n```\n:::\n\n\n::: {.cell execution_count=27}\n``` {.python .cell-code}\n# display results\nsegs = gj.Map(use_region=True)\nsegs.d_rgb(red=\"SPOT_20180621_PANSHARP.3\",\n              green=\"SPOT_20180621_PANSHARP.2\",\n              blue=\"SPOT_20180621_PANSHARP.1\")\nsegs.d_vect(map=\"segment_001\", type=\"boundary\", color=\"yellow\")\nsegs.show()\n```\n:::\n\n\nProbamos con un umbral más grande.\n\n::: {.cell execution_count=28}\n``` {.python .cell-code}\n# run segmentation - larger threshold\ngs.run_command(\"i.segment\",\n               group=\"spot_bands\",\n               output=\"segment_005\",\n               threshold=0.05,\n               memory=2000)\n```\n:::\n\n\n::: {.cell execution_count=29}\n``` {.python .cell-code}\n# convert output to vector\ngs.run_command(\"r.to.vect\",\n               input=\"segment_005\",\n               output=\"segment_005\",\n               type=\"area\",\n               flags=\"tv\")\n```\n:::\n\n\n::: {.cell execution_count=30}\n``` {.python .cell-code}\n# display results\nsegs = gj.Map(use_region=True)\nsegs.d_rgb(red=\"SPOT_20180621_PANSHARP.3\",\n              green=\"SPOT_20180621_PANSHARP.2\",\n              blue=\"SPOT_20180621_PANSHARP.1\")\nsegs.d_vect(map=\"segment_005\", type=\"boundary\", color=\"red\")\nsegs.show()\n```\n:::\n\n\nHagamos zoom sobre los resultados para cada umbral.\n\n:::: columns\n:::{.column width=\"50%\"}\nSobre-segmentado\n\n![](../assets/img/over_segmented.png)\n:::\n\n:::{.column width=\"50%\"}\nSub-segmentado\n\n![](../assets/img/sub_segmented.png)\n:::\n::::\n\n:::{.callout-warning title=\"Tarea\"}\nSe animan a probar con otros valores y en otras regiones?\n:::\n\n### Búsqueda automática de umbrales por optimización\n\nTeniendo valores de umbrales de sub- y sobre-segmentación, podemos proceder a realizar la segmentación de manera autómatica, buscando el mejor umbral en una especie de grilla definida por umbral mínimo, umbral máximo y paso. Para ello, utilizamos la extensión: [i.segment.uspo](https://grass.osgeo.org/grass-stable/manuals/addons/i.segment.uspo.html).\n\nEste procedimiento es computacionalmente intensivo para un área grande y muchas combinaciones de parámetros, pero siempre podemos:\n\n- Limitar el tamaño de la región computacional o generar *tiles* con [i.cutlines](https://grass.osgeo.org/grass-stable/manuals/addons/i.cutlines.html) y paralelizar la USPO.\n- Limitar el rango de los parámetros, o usar un paso relativamente grande.\n- Crear **superpixels** con [i.superpixels.slic](https://grass.osgeo.org/grass-stable/manuals/addons/i.superpixels.slic.html) para usarlos como semillas.\n \n#### Generación de semillas\n\nLa extensión [i.superpixels.slic](https://grass.osgeo.org/grass-stable/manuals/addons/i.superpixels.slic.html)\n\n- También puede utilizarse para la segmentación per se, como vimos en el ejercicio anterior.\n- Es muy rápida para reagrupar pequeñas cantidades de píxeles similares.\n- Se puede usar para reducir el número de píxeles en un factor de 4-5 y acelerar *i.segment.uspo*, que ya no empieza por pixeles individuales, sino por pequeños grupos de pixeles similares.\n- Se usa baja compactación para mantener la separación espectral (Ver el manual: *A larger compactness value will cause spatially more compact, but spectrally more heterogeneous superpixels*).\n\n### USPO con superpixels como semillas\n\nVamos a ejecutar entonces *i.superpixels.slic* con bajo valor de compactación para generar el semillero para *i.segment.uspo*.\n\n::: {.cell execution_count=31}\n``` {.python .cell-code}\n# run superpixel segmentation to use as seeds\ngs.run_command(\"i.superpixels.slic\",\n               input=\"spot_bands\",\n               output=\"superpixels\",\n               step=2,\n               compactness=0.7,\n               memory=2000)\n```\n:::\n\n\nAcá podemos ver un recorte de la composición RGB y el resultado de la ejecución de *i.superpixels.slic*.\n\n![](../assets/img/superpixels.png)\n\n:::{.callout-warning title=\"Tarea\"}\nCuántas semillas se generaron? Qué factor de reducción se consigue en comparación a usar todos los pixeles?\n\nPara responder pueden dar una mirada a los manuales de [r.info](https://grass.osgeo.org/grass-stable/manuals/r.info.html) y [g.region](https://grass.osgeo.org/grass-stable/manuals/g.region.html).\n:::\n\nInstalamos las extensiones y ejecutamos la segmentación con optimización.\n\n::: {.cell execution_count=32}\n``` {.python .cell-code}\n# install extensions\ngs.run_command(\"g.extension\", \n               extension=\"r.neighborhoodmatrix\")\ngs.run_command(\"g.extension\", \n               extension=\"i.segment.uspo\")\n```\n:::\n\n\n::: {.cell execution_count=33}\n``` {.python .cell-code}\n# run segmentation with uspo\ngs.run_command(\"i.segment.uspo\",\n               group=\"spot_bands\",\n               output=\"uspo_parameters.csv\",\n               region=\"obia_subset\",\n               seeds=\"superpixels\",\n               segment_map=\"segs\",\n               threshold_start=0.005,\n               threshold_stop=0.05,\n               threshold_step=0.005,\n               minsizes=3, \n               number_best=5,\n               memory=2000,\n               processes=6)\n```\n:::\n\n\n::: {.cell execution_count=34}\n``` {.python .cell-code}\n# explore results\ngs.list_grouped(type=\"raster\", \n                pattern=\"segs_*\")[\"obia_spot\"]\n```\n:::\n\n\n::: {.cell execution_count=35}\n``` {.python .cell-code}\n!cat uspo_parameters.csv\n```\n:::\n\n\nConvertimos el mejor resultado, i.e., *\\*rank1* a vector para visualizar el resultado.\n\n::: {.cell execution_count=36}\n``` {.python .cell-code}\n# convert to vector the rank1\ngs.run_command(\"r.to.vect\",\n               input=\"segs_obia_subset_rank1\",\n               output=\"segs\",\n               type=\"area\",\n               flags=\"tv\")\n```\n:::\n\n\nZoom al resultado de ejecutar la segmentación con USPO\n\n![](../assets/img/result_uspo.png)\n\n:::{.callout-warning title=\"Tarea\"}\nCuántos segmentos obtuvieron?\n\nDar una mirada a [v.info](https://grass.osgeo.org/grass-stable/manuals/v.info.html) para responder.\n:::\n\n## Estadísticas de segmentos: [i.segment.stats](https://grass.osgeo.org/grass-stable/manuals/addons/i.segment.stats.html)\n\nInstalamos la extensión que nos permite extraer estadísticas para los segmentos obtenidos en el paso anterior.\n\n::: {.cell execution_count=37}\n``` {.python .cell-code}\n# install extensions\ngs.run_command(\"g.extension\", \n               extension=\"i.segment.stats\")\n```\n:::\n\n\n::: {.cell execution_count=38}\n``` {.python .cell-code}\n# extract stats for all segments \n# Note: vectormap output does not work for this dataset, see loong workaround with csv output in further steps\ngs.run_command(\"i.segment.stats\",\n               map=\"segs_obia_subset_rank1\",\n               csvfile=\"segs_stats.csv\",\n               rasters=\"SPOT_20180621_ASM,SPOT_20180621_IDM,SPOT_20180621_NDVI,SPOT_20180621_NDWI,SPOT_20180621_PAN\",\n               raster_statistics=\"mean,stddev\",\n               area_measures=\"area,perimeter,compact_circle,compact_square\",\n               processes=4)\n```\n:::\n\n\nVisualizamos el csv resultante con la estadística por segmentos.\n\n::: {.cell execution_count=39}\n``` {.python .cell-code}\n!cat segs_stats.csv | head\n```\n:::\n\n\n:::{.callout-warning title=\"Tarea\"} \nQué otras estadísticas se podrían obtener? \nQué otro(s) módulo(s) podría(n) sustituir a *i.segment.stats*? \n:::\n\n## Datos de entrenamiento\n\nTenemos nuestros segmentos caracterizados, pero nos falta un dato fundamental para poder realizar una clasificación supervisada... la verdad de terreno, i.e., a qué clase pertenece una muestra de todos los segmentos del área de estudio. Como etiquetar segmentos o puntos es una tarea tediosa, se provee dentro del mapset `PERMANENT` un conjunto de puntos con etiqueta para realizar el entrenamiento. Veamos cuántos puntos tenemos.\n\n::: {.cell execution_count=40}\n``` {.python .cell-code}\n# get info of labeled points\ngs.vector_info_topo(\"labeled_points\")\n```\n:::\n\n\nComo el acceso a tablas de otros mapsets no está permitido, nos copiamos el vector con los puntos etiquetados al mapset `obia_spot`.\n\n::: {.cell execution_count=41}\n``` {.python .cell-code}\n# copy vector to current mapset (access to tables from different mapsets is not allowed)\ngs.run_command(\"g.copy\",\n               vector=\"labeled_points@PERMANENT,labeled_points\")\n```\n:::\n\n\nCuántos puntos de cada clase tenemos?\n\n::: {.cell execution_count=42}\n``` {.python .cell-code}\n# get number of points per class\nprint(gs.read_command(\"db.select\",\n                      sql=\"SELECT train_class,COUNT(cat) as count_class FROM labeled_points GROUP BY train_class\"))\n```\n:::\n\n\nSeleccionar segmentos sobre los cuales tenemos puntos de entrenamiento\n\n::: {.cell execution_count=43}\n``` {.python .cell-code}\n# select segments that are below labeled points\ngs.run_command(\"v.select\",\n               ainput=\"segs\",\n               binput=\"labeled_points\",\n               output=\"train_segments\",\n               operator=\"overlap\")\n```\n:::\n\n\nCuántos segmentos contienen puntos de entrenamiento?\n\n::: {.cell execution_count=44}\n``` {.python .cell-code}\n# get info of segments\ngs.vector_info_topo(map=\"train_segments\")\n```\n:::\n\n\nVeamos un zoom a la selección de segmentos con puntos de entrenamiento.\n\n![](../assets/img/points_in_segments.png)\n\nAntes de asignar el atributo de los puntos a los segmentos, necesitamos agregar una tabla y una columna al vector con los segmentos.\n\n::: {.cell execution_count=45}\n``` {.python .cell-code}\n# add attr table to train segments\ngs.run_command(\"v.db.addtable\",\n               map=\"train_segments\")\n```\n:::\n\n\n::: {.cell execution_count=46}\n``` {.python .cell-code}\n# add column to train segments\ngs.run_command(\"v.db.addcolumn\",\n               map=\"train_segments\",\n               column=\"class int\")\n```\n:::\n\n\nAhora sí, usamos el módulo [v.distance](https://grass.osgeo.org/grass-stable/manuals/v.distance.html) para transferir la etiqueta (clase de cobertura) desde los puntos a los segmentos\n\n::: {.cell execution_count=47}\n``` {.python .cell-code}\n# assign label from points to segments\ngs.run_command(\"v.distance\",\n               from_=\"train_segments\", \n               to=\"labeled_points\",\n               upload=\"to_attr\",\n               column=\"class\",\n               to_column=\"train_class\")\n```\n:::\n\n\nCuántos segmentos de cada clase tenemos?\n\n::: {.cell execution_count=48}\n``` {.python .cell-code}\n# group training segments per class\n!db.select sql=\"SELECT class,COUNT(cat) as count_class FROM train_segments GROUP BY class\"\n```\n:::\n\n\nComo, por alguna razón, para estos datos, no pudimos obtener un vector a partir de i.segment.stats, necesitamos hacer un \"workaround\" para obtener, en cambio, un csv con los segmentos de entrenamiento, sus estadísticas y sus etiquetas. Para eso, haremos lo siguiente:\n\n- convertir a raster el vector `train_segments` con las etiquetas para poder obtener las estadísticas con i.segment.stats,\n- obtener las estadísticas para los segmentos de entrenamiento únicamente con i.segment.stats,\n- importar a GRASS la tabla csv resultante (Sí, podemos importar tablas a GRASS!),\n- unir el vector de segmentos de entrenamiento que tiene las etiquetas con la tabla con las estadísticas,\n- eliminar la columna cat_ resultante de la unión, ya que no es un atributo para la clasificación, y\n- exportar la nueva tabla de atributos como csv.\n\nSi, de i.segment.stats ustedes pueden obtener un vector, la tarea es mucho más sencilla: \n```\n# select segments that are below labeled points\nv.select \\\n  ainput=segs_stats \\ # vector obtenido con i.segment.stats\n  binput=labeled_points \\\n  output=train_segments \\\n  operator=overlap\n\n# add column to train segments\nv.db.addcolumn train_segments column=\"class int\"\n\n# assign label from points to segments\nv.distance from=train_segments \\\n  to=labeled_points \\\n  upload=to_attr \\\n  column=class \\\n  to_column=train_class\n```\n\nEmpecemos...\n\n::: {.cell execution_count=49}\n``` {.python .cell-code}\n# convert train_segments vector to raster\ngs.run_command(\"v.to.rast\",\n               input=\"train_segments\",\n               output=\"train_segments\",\n               use=\"cat\")\n```\n:::\n\n\n::: {.cell execution_count=50}\n``` {.python .cell-code}\n# extract stats for training segments\ngs.run_command(\"i.segment.stats\",\n               map=\"train_segments\",\n               csvfile=\"train_segs_stats.csv\",\n               separator=\"comma\",\n               rasters=\"SPOT_20180621_ASM,SPOT_20180621_IDM,SPOT_20180621_NDVI,SPOT_20180621_NDWI,SPOT_20180621_PAN\",\n               raster_statistics=\"mean,stddev\",\n               area_measures=\"area,perimeter,compact_circle,compact_square\",\n               processes=4)\n```\n:::\n\n\n::: {.cell execution_count=51}\n``` {.python .cell-code}\n!cat train_segs_stats.csv | head\n```\n:::\n\n\n::: {.cell execution_count=52}\n``` {.python .cell-code}\n# import csv table\ngs.run_command(\"db.in.ogr\",\n               input=\"train_segs_stats.csv\",\n               output=\"train_segs_stats\") # name of the table within GRASS\n```\n:::\n\n\n::: {.cell execution_count=53}\n``` {.python .cell-code}\nprint(gs.read_command(\"db.describe\",\n                      table=\"train_segs_stats\",\n                      flags=\"c\"))\n```\n:::\n\n\n::: {.cell execution_count=54}\n``` {.python .cell-code}\n# paste column class from train_segments to train_segs_stats.csv\ngs.run_command(\"v.db.join\",\n               map=\"train_segments\",\n               column=\"cat\",\n               other_table=\"train_segs_stats\",\n               other_column=\"cat_\")\n```\n:::\n\n\n::: {.cell execution_count=55}\n``` {.python .cell-code}\n# drop cat_ column\ngs.run_command(\"v.db.dropcolumn\",\n               map=\"train_segments\",\n               columns=\"cat_\")\n```\n:::\n\n\n::: {.cell execution_count=56}\n``` {.python .cell-code}\n# save patched attr table as csv \ngs.run_command(\"v.db.select\",\n               map=\"train_segments\",\n               file=\"rain_segs_stats_class.csv\")\n```\n:::\n\n\n::: {.cell execution_count=57}\n``` {.python .cell-code}\n# check csv\n!cat train_segs_stats_class.csv | head\n```\n:::\n\n\n::: {.cell execution_count=58}\n``` {.python .cell-code}\n# remove column cat_ and save fixed csv\n# !cut --complement -f3 -d\"|\" train_segs_stats_class.csv > train_segs_stats_class_fix.csv\n```\n:::\n\n\n:::{.callout-note title=\"Una forma de seleccionar y etiquetar datos de entrenamiento\"}\n- Ejecutar una clasificación no supervisada con 10 clases\n- Extraer una *x* cantidad de puntos por clase ([r.sample.category](https://grass.osgeo.org/grass-stable/manuals/addons/r.sample.category.html))\n- Etiquetar los puntos manualmente\n- Usar puntos para transferir las etiquetas a los segmentos como ya vimos\n\n```\n# Unsupervised classification\ni.group group=spot_all input=SPOT_20180621_ASM,SPOT_20180621_IDM,SPOT_20180621_NDVI,SPOT_20180621_NDWI,SPOT_20180621_PAN,SPOT_20180621_PANSHARP.1,SPOT_20180621_PANSHARP.2,SPOT_20180621_PANSHARP.3,SPOT_20180621_PANSHARP.4\ni.cluster group=spot_all signaturefile=sig classes=10\ni.maxlik group=spot_all signaturefile=sig output=uns_clas\n\n# install extension\ng.extension r.sample.category\n\n# get n points per class\nr.sample.category input=uns_clas output=uns_clas_points npoints=150\n\n# then, manually label points\n```\n:::\n\n## Clasificación con Machine learning\n\nAhora sí, finalmente llegamos a la clasificación de los segmentos. Vamos a instalar la extensión [v.class.mlR](https://grass.osgeo.org/grass-stable/manuals/addons/v.class.mlR.html). Esta extensión usa paquetes de R para realizar la clasificación, por lo tanto necesitamos tener R y ciertos paquetes previamente instalados.\n\n::: {.cell execution_count=59}\n``` {.python .cell-code}\n# install extension\ngs.run_command(\"g.extension\", \n               extension=\"v.class.mlR\")\n```\n:::\n\n\n::: {.cell execution_count=60}\n``` {.python .cell-code}\n# run classification\ngs.run_command(\"v.class.mlR\",\n               segments_file=\"segs_stats.csv\", # stats of all segments\n               training_file=\"train_segs_stats_class.csv\", # stats of training segs\n               train_class_column=\"class\",\n               classified_map=\"classification\",\n               raster_segments_map=\"segs_obia_subset_rank1\",\n               classifier=\"rf\",\n               folds=5,\n               partitions=10,\n               tunelength=10,\n               weighting_modes=\"smv\",\n               weighting_metric=\"accuracy\",\n               output_model_file=\"model\",\n               variable_importance_file=\"var_imp.txt\",\n               accuracy_file=\"accuracy.csv\",\n               model_details=\"classifier_runs.txt\",\n               r_script_file=\"Rscript_mlR.R\",\n               processes=2, # use more if available\n               flags=\"nf\")\n```\n:::\n\n\n:::{.callout-warning title=\"Tarea\"}\nCrear paleta de colores para las clases de cobertura urbana asignando colores interactivamente\n\n- Ir agregando valores\n- Seleccionar colores \n- Previsualizar\n- Guardar la paleta creada como *obia_urban* para reusar posteriormente\n\n![](../assets/img/assign_color_to_train_segments.png){width=70%}\n:::\n\nAplicamos la paleta de colores que creamos.\n\n::: {.cell execution_count=61}\n``` {.python .cell-code}\n# set color table that we created interactively\ngs.run_command(\"r.colors\",\n               map=\"classification_rf\",\n               rules=\"obia_urban\")\n```\n:::\n\n\nVisualizamos el resultado de la clasificación supervisada con Machine Learning basada en objetos\n\n::: {.cell execution_count=62}\n``` {.python .cell-code}\n# display results\nobia = gj.Map(use_region=True)\nobia.d_rast(map=\"classification_rf\")\nobia.show()\n```\n:::\n\n\nRevisemos los archivos auxiliares que obtuvimos de la ejecución de la clasificación por random forest.\n\n::: {.cell execution_count=63}\n``` {.python .cell-code}\n!cat var_imp.txt\n```\n:::\n\n\n::: {.cell execution_count=64}\n``` {.python .cell-code}\n!cat accuracy.csv\n```\n:::\n\n\n::: {.cell execution_count=65}\n``` {.python .cell-code}\n!cat classifier_runs.txt\n```\n:::\n\n\n:::{.callout-important}\nEl proceso de clasificación usualmente conlleva una serie de iteraciones que implican selección de variables más importantes, búsqueda de más/mejores datos de entrenamiento y validación\n:::\n\n## Validación\n\n- Se usan datos independientes para validar las clasificaciones\n- Se construye una **matriz de confusión** que permite visualizar los errores por \nclase en los elementos que están fuera de la diagonal\n- Se estiman varias medidas relacionadas a la precisión, ej.: **overall accuracy** \ny **kappa**\n\nDistintas opciones:\n1. Generar un nuevo set de puntos y etiquetarlos\n2. Separar el set de puntos etiquetados en *train* y *test* de antemano\n\n### Opción 1\n\n:::{.callout-warning title=\"Tarea\"}\nGenerar un set de validación de al menos 50 segmentos. Una vez creado el vector de segmentos con etiquetas, *testing*, convertirlo a formato raster y ejecutar [**r.kappa**](https://grass.osgeo.org/grass-stable/manuals/r.kappa.html).\n:::\n\n[r.kappa](https://grass.osgeo.org/grass-stable/manuals/r.kappa.html) necesita mapas raster como *input*, por lo tanto necesitamos transformar los segmentos de validación a formato raster usando la columna *`class`* como fuente de valores para los pixeles.\n\n::: {.cell execution_count=66}\n``` {.python .cell-code}\n# convert labeled test segments to raster\ngs.run_command(\"v.to.rast\",\n               map=\"testing\",\n               use=\"attr\",\n               attribute_column=\"class\",\n               output=\"testing\")\n```\n:::\n\n\n::: {.cell execution_count=67}\n``` {.python .cell-code}\n# create confusion matrix and estimate precision measures\nprint(gs.read_command(\"r.kappa\",\n                      classification=\"classification_rf\",\n                      reference=\"testing\"))\n```\n:::\n\n\n### Opción 2\n\nAlternativamente, podemos separar el set de puntos etiquetados en *train* y *test*. Usemos la extensión [v.divide.training_validation](https://github.com/mundialis/v.divide.training_validation) creada por [mundialis](https://www.mundialis.de/en/).\n\n::: {.cell execution_count=68}\n``` {.python .cell-code}\n# install the extension\ngs.run_command(\"g.extension\",\n               extension=\"v.divide.training_validation\",\n               url=\"https://github.com/mundialis/v.divide.training_validation\")\n```\n:::\n\n\n::: {.cell execution_count=69}\n``` {.python .cell-code}\n# divide our labeled segments into train and test\ngs.run_command(\"v.divide.training_validation\",\n               input=\"train_segments\",\n               column=\"class\", \n               training=\"training\", \n               validation=\"testing\", \n               training_percent=30)\n```\n:::\n\n\n:::{.callout-warning title=\"Tarea\"}\nEjecutar nuevamente la clasificación usando sólo el vector *training*. Recordar convertir a csv.\n:::\n\nAgregamos la columna `pred_class` al vector *test*\n\n::: {.cell execution_count=70}\n``` {.python .cell-code}\n# add column to test point map\ngs.run_command(\"v.db.addcolumn\",\n               map=\"testing\",\n               column=\"pred_class integer\")\n```\n:::\n\n\nObtener las clases predichas para los segmentos de validación\n\n::: {.cell execution_count=71}\n``` {.python .cell-code}\n# query the classified map\ngs.run_command(\"v.what.rast\",\n               map=\"testing\",\n               column=\"pred_class\",\n               raster=\"classification_rf\")\n```\n:::\n\n\n:::{.callout-warning title=\"Tarea\"}\nCovertir a raster y ejecutar r.kappa.\n:::\n\n",
    "supporting": [
      "exercise_obia_files"
    ],
    "filters": [],
    "includes": {}
  }
}