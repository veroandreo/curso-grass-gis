{
  "hash": "8585321c4adcf963087b1f4089e8f851",
  "result": {
    "markdown": "---\ntitle: 'Ejercicio: Series temporales en GRASS GIS'\nauthor: Verónica Andreo\ndate: today\nformat:\n  html:\n    code-tools: true\n    code-copy: true\n    code-fold: false\nexecute:\n  eval: false\n  cache: false\n  keep-ipynb: true\n---\n\n## Ejercicio: Manos a la obra con series temporales de NDVI \n\n\n\n### Contenidos\n\n- Datos para el ejercicio\n- Uso de bandas de confiabilidad\n- Creación de serie de NDVI\n- HANTS como método de reconstrucción\n- Agregación temporal\n- Índices de fenología\n- NDWI y frecuencia de inundación\n- Regresión entre NDVI y NDWI\n\n\n### Datos para el ejercicio\n\n- Producto MODIS: <a href=\"https://lpdaac.usgs.gov/products/mod13c2v006/\">MOD13C2 Collection 6</a>\n- Composiciones globales mensuales \n- Resolución espacial: 5600 m\n- Mapset `modis_ndvi` \n\n\n![](../assets/img/mod13c2_global_ndvi.png)\n\n\n### Exploramos los datos de NDVI\n\nIniciar GRASS GIS en el mapset *modis_ndvi*\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\n# paths\ngrassdata='/home/veroandreo/grassdata/'\nlocation='posgar2007_4_cba'\nmapset='modis_ndvi'\n```\n:::\n\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nimport os\nimport subprocess\nimport sys\n\n# Ask GRASS GIS where its Python packages are to be able to start it from the notebook\nsys.path.append(\n    subprocess.check_output([\"grass\", \"--config\", \"python_path\"], text=True).strip()\n)\n\n# Importar los paquetes python de GRASS\nimport grass.script as gs\nimport grass.jupyter as gj\n\n# Iniciar GRASS\nsession = gj.init(grassdata, location, mapset)\n```\n:::\n\n\nAgregar *modis_lst* a la lista de mapsets accesibles\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\n# add `modis_lst` to accessible mapsets path\ng.mapsets -p\ng.mapsets mapset=modis_lst operation=add\n```\n:::\n\n\nListar los mapas y obtener información de alguno de ellos\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\n# list files and get info and stats\ng.list type=raster mapset=.\n\nr.info map=MOD13C2.A2015001.006.single_Monthly_NDVI\nr.univar map=MOD13C2.A2015001.006.single_Monthly_NDVI\n```\n:::\n\n\n> **Tarea**\n> \n> - Mostrar los mapas de NDVI, NIR y pixel reliability.\n> - Obtener información sobre los valores mínimos y máximos\n> - ¿Qué se puede decir sobre los valores de cada banda?\n> - ¿Hay valores nulos?\n\n### Uso de la banda de confiabilidad\n\n> **Tarea**\n>\n> - Leer acerca de la banda de confiabilidad en la [Guía de usuario](https://lpdaac.usgs.gov/documents/103/MOD13_User_Guide_V6.pdf) de MOD13 (pag 27).\n> - Para una misma fecha mostrar la banda de confiabilidad y el NDVI.\n> - Seleccionar sólo los pixeles con valor 0 (Buena calidad) en la banda de confiabilidad. ¿Qué se observa?\n\n\n### Uso de la banda de confiabilidad\n\nDefinir la región computacional\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\n# set computational region\ng.region -p vector=provincia_cba \\\n  align=MOD13C2.A2015001.006.single_Monthly_NDVI\n```\n:::\n\n\nEstablecer los límites provinciales como máscara\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\n# set mask\nr.mask vector=provincia_cba\n```\n:::\n\n\nMantener sólo los pixeles de la mejor calidad\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\n# keep only NDVI most reliable pixels (one map) - *nix\nPR=MOD13C2.A2015274.006.single_Monthly_pixel_reliability\nNDVI=MOD13C2.A2015274.006.single_Monthly_NDVI\n\nr.mapcalc \\\n  expression=\"${NDVI}_filt = if(${PR} != 0, null(), ${NDVI})\"\n```\n:::\n\n\nMantener sólo los pixeles de la mejor calidad - para todos los mapas\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\n# list of maps\nPR=`g.list type=raster pattern=\"*_pixel_reliability\" separator=\" \"`\nNDVI=`g.list type=raster pattern=\"*_Monthly_NDVI\" separator=\" \"`\n# convert list to array\nPR=($PR)\nNDVI=($NDVI)\n\n# iterate over the 2 arrays\nfor ((i=0;i<${#PR[@]};i++)) ; do\n r.mapcalc --o \\\n  expression=\"${NDVI[$i]}_filt = if(${PR[$i]} != 0, null(), ${NDVI[$i]})\"\ndone\n```\n:::\n\n\n> **Tarea**\n>\n> Cómo podrían hacer lo mismo pero con módulos temporales?\n\nQué les parece [t.rast.algebra](https://grass.osgeo.org/grass-stable/manuals/t.rast.algebra.html)?\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\n# apply pixel reliability band\nt.rast.algebra \\\n  expression=\"NDVI_monthly_filt = if(pixel_rel_monthly != 0, null(), ndvi_monthly)\"\n  basename=ndvi_monthly \\\n  suffix=gran\n```\n:::\n\n\n> **Tarea**\n>\n> Comparar las estadísticas entre los mapas de NDVI originales y filtrados para la misma fecha\n\n\n### Creación de la serie de tiempo\n\nCrear STRDS de NDVI\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\n# create STRDS\nt.create output=ndvi_monthly \\\n  type=strds temporaltype=absolute \\\n  title=\"Filtered monthly NDVI\" \\\n  description=\"Filtered monthly NDVI - MOD13C2 - Cordoba, 2015-2019\"\n```\n:::\n\n\nCorroborar que la STRDS fue creada\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\n# check if it was created\nt.list type=strds\n```\n:::\n\n\nCrear archivo con lista de mapas\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\n# list NDVI filtered files\ng.list type=raster pattern=\"*filt\" output=ndvi_list.txt\n```\n:::\n\n\nAsignar fecha a los mapas, i.e., registrar\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\n# register maps\nt.register -i input=ndvi_monthly \\\n  type=raster file=ndvi_list.txt \\\n  start=\"2015-01-01\" \\\n  increment=\"1 months\"\n```\n:::\n\n\nImprimir info básica de la STRDS\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\n# print time series info\nt.info input=ndvi_monthly\n```\n:::\n\n\nImprimir la lista de mapas en la STRDS\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\n# print list of maps in time series\nt.rast.list input=ndvi_monthly\n```\n:::\n\n\n> **Tarea**\n> \n> Explorar visualmente los valores de las series temporales en diferentes puntos. \n> Usar [g.gui.tplot](https://grass.osgeo.org/grass-stable/manuals/g.gui.tplot.html) y seleccionar diferentes puntos interactivamente.\n\n### Datos faltantes\n\nObtener las estadísticas de la serie de tiempo\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\n# How much missing data we have after filtering for pixel reliability?\nt.rast.univar input=ndvi_monthly\n```\n:::\n\n\nContar los datos válidos\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\n# count valid data\nt.rast.series input=ndvi_monthly \\\n  method=count \\\n  output=ndvi_count_valid\n```\n:::\n\n\nEstimar el porcentaje de datos faltantes\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\n# estimate percentage of missing data\nr.mapcalc \\\n expression=\"ndvi_missing = ((60 - ndvi_count_valid) * 100.0)/60\"\n```\n:::\n\n\nCómo guardar en una variable el numero de mapas de una serie de tiempo?\n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\nt.info -g ndvi_monthly\n`eval t.info ndvi_monthly`\necho $number_of_maps\n\nr.mapcalc \\\n  expression=\"ndvi_missing = (($number_of_maps - ndvi_count_valid) * 100.0)/$number_of_maps\"\n```\n:::\n\n\n> **Tarea**\n>\n> - Mostrar el mapa que representa el porcentaje de datos faltantes y explorar los valores. \n> - Obtener estadísticas univariadas de este mapa.\n> - Dónde estan los mayores porcentajes de datos faltantes? Por qué creen que puede ser?\n\n### Reconstrucción temporal: HANTS\n\n- Harmonic Analysis of Time Series (HANTS)\n- Implementado en la extensión [r.hants](https://grass.osgeo.org/grass-stable/manuals/addons/r.hants.html)\n\n<img src=\"../assets/img/evi_evi_hants.png\" width=\"65%\">\n\n\n### Reconstrucción temporal: HANTS\n\nInstalar la extensión *r.hants*\n\n::: {.cell execution_count=20}\n``` {.python .cell-code}\n# install extension\ng.extension extension=r.hants\n```\n:::\n\n\nListar los mapas y aplicar r.hants\n\n::: {.cell execution_count=21}\n``` {.python .cell-code}\n# list maps\nmaplist=`t.rast.list input=ndvi_monthly method=comma`\n\n# gapfill: r.hants\nr.hants input=$maplist range=-2000,10000 \\\n  nf=5 fet=500 base_period=12\n```\n:::\n\n\n> **Tarea**\n>\n> Probar diferentes ajustes de parámetros en [r.hants](https://grass.osgeo.org/grass-stable/manuals/addons/r.hants.html) y comparar los resultados\n\n\n### Reconstrucción temporal: HANTS\n\nParcheo de serie original y reconstruída\n\n::: {.cell execution_count=22}\n``` {.python .cell-code}\n# patch original with filled (one map)\nNDVI_ORIG=MOD13C2.A2015001.006.single_Monthly_NDVI_filt\nNDVI_HANTS=MOD13C2.A2015001.006.single_Monthly_NDVI_filt_hants\n\nr.patch input=${NDVI_ORIG},${NDVI_HANTS} \\\n  output=${NDVI_HANTS}_patch\n```\n:::\n\n\nParcheo de serie original y reconstruída\n\n::: {.cell execution_count=23}\n``` {.python .cell-code}\n# list of maps\nORIG=`g.list type=raster pattern=\"*_filt\" separator=\" \"`\nFILL=`g.list type=raster pattern=\"*_hants\" separator=\" \"`\n# convert list to array\nORIG=($ORIG)\nFILL=($FILL)\n\n# iterate over the 2 arrays\nfor ((i=0;i<${#ORIG[@]};i++)) ; do\n  r.patch input=${ORIG[$i]},${FILL[$i]} output=${FILL[$i]}_patch --o\ndone\n```\n:::\n\n\nCrear serie de tiempo con los datos parcheados\n\n::: {.cell execution_count=24}\n``` {.python .cell-code}\n# create new time series \nt.create output=ndvi_monthly_patch \\\n  type=strds temporaltype=absolute \\\n  title=\"Patched monthly NDVI\" \\\n  description=\"Filtered, gap-filled and patched monthly NDVI - MOD13C2 - Cordoba, 2015-2019\"\n```\n:::\n\n\nRegistrar los mapas en la serie de tiempo\n\n::: {.cell execution_count=25}\n``` {.python .cell-code}\n# list NDVI patched files\ng.list type=raster pattern=\"*patch\" \\\n  output=list_ndvi_patched.txt\n\n# register maps\nt.register -i input=ndvi_monthly_patch \\\n  type=raster file=list_ndvi_patched.txt \\\n  start=\"2015-01-01\" \\\n  increment=\"1 months\"\n```\n:::\n\n\nImprimir información de la serie de tiempo\n\n::: {.cell execution_count=26}\n``` {.python .cell-code}\n# print time series info\nt.info input=ndvi_monthly_patch\n```\n:::\n\n\n> **Tarea**\n>\n> - Evaluar gráficamente los resultados de la reconstrucción de HANTS en pixeles con mayor porcentaje de datos faltantes \n> - Obtener estadísticas univariadas para las nuevas series temporales\n\n> **Tarea**\n>\n> - Ver la sección de métodos en [Metz el al. 2017](https://www.mdpi.com/2072-4292/9/12/1333) \n> - Qué otros algoritmos existen o qué otra aproximación podría seguirse?\n\n![](https://www.mdpi.com/remotesensing/remotesensing-09-01333/article_deploy/html/images/remotesensing-09-01333-ag.png)\n\n### Agregación con granularidad\n\n> **Tarea**\n>\n> - Obtener el promedio de NDVI cada dos meses\n> - Visualizar la serie de tiempo resultante con [g.gui.animation](https://grass.osgeo.org/grass-stable/manuals/g.gui.animation.html)\n\n### Fenología\n\nMes de máximo y mes de mínimo\n\n::: {.cell execution_count=27}\n``` {.python .cell-code}\n# get month of maximum and month of minimum\nt.rast.series input=ndvi_monthly_patch \\\n  method=minimum output=ndvi_min\nt.rast.series input=ndvi_monthly_patch \\\n  method=maximum output=ndvi_max\n\n```\n:::\n\n\nReemplazar con *start_month()* los valores en la STRDS si coinciden con el mínimo o máximo global\n\n::: {.cell execution_count=28}\n``` {.python .cell-code}\n# get month of maximum and minimum\nt.rast.mapcalc -n inputs=ndvi_monthly_patch \\\n  output=month_max_ndvi \\\n  expression=\"if(ndvi_monthly_patch == ndvi_max, start_month(), null())\" \\\n  basename=month_max_ndvi\n\nt.rast.mapcalc -n inputs=ndvi_monthly_patch \\\n  output=month_min_ndvi \\\n  expression=\"if(ndvi_monthly_patch == ndvi_min, start_month(), null())\" \\\n  basename=month_min_ndvi\n```\n:::\n\n\nObtener el primer mes en el que aparecieron el máximo y el mínimo\n\n::: {.cell execution_count=29}\n``` {.python .cell-code}\n# get the earliest month in which the maximum and minimum appeared\nt.rast.series input=month_max_ndvi \\\n  method=maximum output=max_ndvi_date\nt.rast.series input=month_min_ndvi \\\n  method=minimum output=min_ndvi_date\n```\n:::\n\n\nEliminar la serie temporal intermedia\n\n::: {.cell execution_count=30}\n``` {.python .cell-code}\n# remove month_max_lst strds \nt.remove -rf inputs=month_max_ndvi,month_min_ndvi\n```\n:::\n\n\n> **Tarea**\n>\n> - Mostrar los mapas resultantes con [g.gui.mapswipe](https://grass.osgeo.org/grass-stable/manuals/g.gui.mapswipe.html)\n> - Cuándo se observan los mínimos y máximos? Hay algun patrón? A qué se podría deber?\n\n> **Tarea**\n>\n> Asociar el máximo de LST con el máximo de NDVI y, la fecha de la máxima LST con la fecha del máximo NDVI\n\n![](assets/img/tip.png) Ver el módulo [r.covar](https://grass.osgeo.org/grass-stable/manuals/r.covar.html)\n\n\n### Fenología\n\nObtener series temporales de pendientes entre mapas consecutivos\n\n::: {.cell execution_count=31}\n``` {.python .cell-code}\n# time series of slopes\nt.rast.algebra \\\n expression=\"slope_ndvi = (ndvi_monthly_patch[1] - ndvi_monthly_patch[0]) / td(ndvi_monthly_patch)\" \\\n basename=slope_ndvi suffix=gran\n```\n:::\n\n\nObtener la máxima pendiente por año\n\n::: {.cell execution_count=32}\n``` {.python .cell-code}\n# get max slope per year\nt.rast.aggregate input=slope_ndvi output=ndvi_slope_yearly \\\n  basename=NDVI_max_slope_year suffix=gran \\\n  method=maximum \\\n  granularity=\"1 years\"\n```\n:::\n\n\n> **Tarea**\n>\n> - Obtener un mapa con la mayor tasa de crecimiento por píxel en el período 2015-2019\n> - Qué modulo usarían?\n\n\n### Fenología\n\nInstalar la extensión *r.seasons*\n\n::: {.cell execution_count=33}\n``` {.python .cell-code}\n# install extension\ng.extension extension=r.seasons\n```\n:::\n\n\nDeterminar el comienzo, el final y la duración del período de crecimiento\n\n::: {.cell execution_count=34}\n``` {.python .cell-code}\n# start, end and length of growing season\nr.seasons input=`t.rast.list -u input=ndvi_monthly_patch method=comma` \\\n  prefix=ndvi_season n=3 \\\n  nout=ndvi_season \\\n  threshold_value=3000 min_length=5\n```\n:::\n\n\n> **Tarea**\n>\n> - Qué nos dice cada mapa? Dónde es más larga la estación de crecimiento?\n> - Exportar los mapas resultantes como .png\n\n### Fenología\n\nCrear un mapa de umbrales para usar en *r.seasons*\n\n::: {.cell execution_count=35}\n``` {.python .cell-code}\n# create a threshold map: min ndvi + 0.1*ndvi\nr.mapcalc expression=\"threshold_ndvi = ndvi_min * 1.1\"\n```\n:::\n\n\n> **Tarea**\n>\n> Utilizar el mapa de umbrales en [r.seasons](https://grass.osgeo.org/grass-stable/manuals/addons/r.seasons.html) y comparar los mapas de salida con los resultados de utilizar sólo un valor de umbral\n\n### Serie de tiempo de NDWI\n\nCrear series temporales de NIR y MIR\n\n::: {.cell execution_count=36}\n``` {.python .cell-code}\n# create time series of NIR and MIR\nt.create output=NIR \\\n  type=strds temporaltype=absolute \\\n  title=\"NIR monthly\" \\\n  description=\"NIR monthly - MOD13C2 - 2015-2019\"\n\nt.create output=MIR \\\n  type=strds temporaltype=absolute \\\n  title=\"MIR monthly\" \\\n  description=\"MIR monthly - MOD13C2 - 2015-2019\"\n```\n:::\n\n\nListar archivos NIR y MIR\n\n::: {.cell execution_count=37}\n``` {.python .cell-code}\n# list NIR and MIR files\ng.list type=raster pattern=\"*NIR*\" output=list_nir.txt\ng.list type=raster pattern=\"*MIR*\" output=list_mir.txt\n```\n:::\n\n\nRegistrar mapas\n\n::: {.cell execution_count=38}\n``` {.python .cell-code}\n# register maps\nt.register -i input=NIR \\\n  type=raster file=list_nir.txt \\\n  start=\"2015-01-01\" increment=\"1 months\"\n\nt.register -i input=MIR \\\n  type=raster file=list_mir.txt \\\n  start=\"2015-01-01\" increment=\"1 months\"\n```\n:::\n\n\nImprimir información de la serie de tiempo\n\n::: {.cell execution_count=39}\n``` {.python .cell-code}\n# print time series info\nt.info input=NIR\nt.info input=MIR\n```\n:::\n\n\nEstimación de la serie temporal de NDWI\n\n::: {.cell execution_count=40}\n``` {.python .cell-code}\n# estimate NDWI time series\nt.rast.algebra basename=ndwi_monthly \\\n  expression=\"ndwi_monthly = if(NIR > 0 && MIR > 0, (float(NIR - MIR) / float(NIR + MIR)), null())\" \\\n  suffix=gran\n```\n:::\n\n\n> **Tarea**\n>\n> Obtener valores máximos y mínimos para cada mapa de NDWI y explorar el trazado de la serie de tiempo en diferentes puntos de forma interactiva\n\n![](assets/img/tip.png) Ver el manual de [t.rast.univar](https://grass.osgeo.org/grass-stable/manuals/t.rast.univar.html)\n\n\n### Frecuencia de inundación\n\nReclasificar los mapas según un umbral\n\n::: {.cell execution_count=41}\n``` {.python .cell-code}\n# reclassify\nt.rast.mapcalc -n input=ndwi_monthly \\\n  output=flood basename=flood \\\n  expression=\"if(ndwi_monthly > 0.8, 1, null())\"\n```\n:::\n\n\nObtener frecuencia de inundación\n\n::: {.cell execution_count=42}\n``` {.python .cell-code}\n# flooding frequency\nt.rast.series input=flood output=flood_freq method=sum\n```\n:::\n\n\n> **Tarea**\n>\n> Cuáles son las áreas que se han inundado con más frecuencia?\n\n\n### Regresión\n\nInstalar la extensión *r.regression.series*\n\n::: {.cell execution_count=43}\n``` {.python .cell-code}\n# install extension\ng.extension extension=r.regression.series\n```\n:::\n\n\nRealizar una regresión entre las series temporales de NDVI y NDWI - *nix\n\n::: {.cell execution_count=44}\n``` {.python .cell-code}\nxseries=`t.rast.list input=ndvi_monthly_patch method=comma`\nyseries=`t.rast.list input=ndwi_monthly method=comma`\n\nr.regression.series xseries=$xseries \\\n  yseries=$yseries \\\n  output=ndvi_ndwi_rsq \\\n  method=rsq\n```\n:::\n\n\n> **Tarea**\n>\n> Determinar dónde está la mayor correlación entre NDVI y NDWI\n\n\n<img src=\"../assets/img/gummy-question.png\" width=\"45%\">\n\n\n**Gracias por su atención!!**\n\n![GRASS GIS logo](../assets/img/grass_logo_alphab.png)\n\n",
    "supporting": [
      "exercise_temporal_files"
    ],
    "filters": [],
    "includes": {}
  }
}