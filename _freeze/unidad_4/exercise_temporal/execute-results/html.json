{
  "hash": "b91cfead8a5b2e2e09accee4a15bcf20",
  "result": {
    "markdown": "---\ntitle: 'Ejercicio: Series temporales en GRASS GIS'\nauthor: Verónica Andreo\ndate: today\nformat:\n  html:\n    code-tools: true\n    code-copy: true\n    code-fold: false\nexecute:\n  eval: false\n  cache: false\n  keep-ipynb: true\n---\n\nEn esta notebook vamos a recorrer algunas de las funcionalidades de TGRASS\nque ya vimos y otras nuevas, pero ahora con una serie de datos de NDVI.\n\nAntes de empezar y para ganar tiempo, conectamos nuestro drive e instalamos \nGRASS en Google Colab.\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\n# import drive from google colab\nfrom google.colab import drive\n# mount drive\ndrive.mount(\"/content/drive\")\n```\n:::\n\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\n%%bash\nDEBIAN_FRONTEND=noninteractive \nsudo add-apt-repository ppa:ubuntugis/ubuntugis-unstable \napt update \napt install grass subversion grass-dev\napt remove libproj22\n```\n:::\n\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\n!grass --config path\n```\n:::\n\n\n## Datos para el ejercicio\n\n- Producto MODIS: <a href=\"https://lpdaac.usgs.gov/products/mod13c2v006/\">MOD13C2 Collection 6</a>\n- Composiciones globales mensuales \n- Resolución espacial: 5600 m\n- Mapset `modis_ndvi` \n\n\n![](../assets/img/mod13c2_global_ndvi.png){width=70%}\n\n## Iniciamos GRASS\n\nDefinimos las rutas y el mapset *`modis_ndvi`*\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nimport os\n\n# data directory\nhomedir = \"/content/drive/MyDrive/curso_grass_2023\"\n\n# change to homedir so output files will be saved there\nos.chdir(homedir)\n\n# GRASS GIS database variables\ngrassdata = os.path.join(homedir, \"grassdata\")\nproject = \"posgar2007_4_cba\"\nmapset = \"modis_ndvi\"\n```\n:::\n\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\n# import standard Python packages we need\nimport sys\nimport subprocess\n\n# ask GRASS GIS where its Python packages are to be able to run it from the notebook\nsys.path.append(\n    subprocess.check_output([\"grass\", \"--config\", \"python_path\"], text=True).strip()\n)\n```\n:::\n\n\nImportamos los paquetes de GRASS e iniciamos una sesión:\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\n# import the GRASS GIS packages we need\nimport grass.script as gs\nimport grass.jupyter as gj\n\n# Start the GRASS GIS Session\nsession = gj.init(grassdata, project, mapset)\n```\n:::\n\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\n# show current GRASS GIS settings, this also checks if the session works\ngs.gisenv()\n```\n:::\n\n\n## Exploramos los datos de NDVI\n\nListar los mapas y obtener información de alguno de ellos\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\n# list raster files\nlista_mapas = gs.list_grouped(type=\"raster\")[\"modis_ndvi\"]\nlista_mapas[:10]\n```\n:::\n\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\n#  get info and stats\ngs.raster_info(map=\"MOD13C2.A2015001.006.single_Monthly_NDVI\")\n```\n:::\n\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\nprint(gs.read_command(\"r.univar\",\n                      map=\"MOD13C2.A2015001.006.single_Monthly_NDVI\"))\n```\n:::\n\n\n:::{.callout-warning title=\"Tarea\"}\n- Mostrar los mapas de NDVI, NIR y pixel reliability.\n- Obtener información sobre los valores mínimos y máximos\n- ¿Qué se puede decir sobre los valores de cada banda?\n- ¿Hay valores nulos?\n:::\n\n## Uso de la banda de confiabilidad\n\nDefinir la región computacional\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\n# set computational region\ngs.region_env(vector=\"provincia_cba\",\n              align=\"MOD13C2.A2015001.006.single_Monthly_NDVI\",\n              flags=\"p\")\n```\n:::\n\n\nEstablecer los límites provinciales como máscara\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\n# set a MASK to Cba boundary\ngs.run_command(\"r.mask\",\n               vector=\"provincia_cba\")\n```\n:::\n\n\n:::{.callout-warning title=\"Tarea\"}\n- Leer acerca de la banda de confiabilidad en la [Guía de usuario](https://lpdaac.usgs.gov/documents/103/MOD13_User_Guide_V6.pdf) de MOD13 (pag 27).\n- Para una misma fecha mapear la banda de confiabilidad y el NDVI.\n- Seleccionar sólo los pixeles con valor 0 (Buena calidad) en la banda de confiabilidad. ¿Qué se observa?\n:::\n\nMantener sólo los pixeles de la mejor calidad\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\n# keep only NDVI most reliable pixels (one map)\nPR=\"MOD13C2.A2015274.006.single_Monthly_pixel_reliability\"\nNDVI=\"MOD13C2.A2015274.006.single_Monthly_NDVI\"\n\ngs.mapcalc(exp=f\"{NDVI}_filt = if({PR} != 0, null(), {NDVI})\")\n```\n:::\n\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\n# plot result\nndvi_filt = gj.InteractiveMap(width = 500, tiles=\"OpenStreetMap\")\nndvi_filt.add_raster(\"MOD13C2.A2015274.006.single_Monthly_NDVI_filt\")\nndvi_filt.show()\n```\n:::\n\n\nMantener sólo los pixeles de la mejor calidad para todos los mapas\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\n# list of maps\nPR = gs.list_grouped(type=\"raster\", \n                     pattern=\"*_pixel_reliability\")[\"modis_ndvi\"]\nNDVI = gs.list_grouped(type=\"raster\", \n                       pattern=\"*_Monthly_NDVI\")[\"modis_ndvi\"]\n\n# iterate over the 2 arrays\nfor i,j in zip(PR,NDVI):\n    print(i, j)\n    gs.mapcalc(exp=f\"{j}_filt = if({i} != 0, null(), {j})\")\n```\n:::\n\n\n:::{.callout-note}\nCómo podrían hacer lo mismo pero usando módulos temporales? Qué les parece [t.rast.algebra](https://grass.osgeo.org/grass-stable/manuals/t.rast.algebra.html)? \nOJO! Esto requiere primero crear las series de tiempo y registrar los mapas \npara que funcione!\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\n# apply pixel reliability band with t.rast.algebra\nexpression=\"NDVI_monthly_filt = if(pixel_rel_monthly != 0, null(), ndvi_monthly)\"\n\ngs.run_command(\"t.rast.algebra\",\n               expression=expression,\n               basename=\"ndvi_monthly\",\n               suffix=\"gran\",\n               nproc=4)\n```\n:::\n\n\n:::\n\n:::{.callout-warning title=\"Tarea\"}\nComparar las estadísticas entre los mapas de NDVI originales y filtrados para la misma fecha\n:::\n\n## Creación de la serie de tiempo\n\nCrear STRDS de NDVI\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\n# create STRDS\ngs.run_command(\"t.create\",\n               type=\"strds\",\n               temporaltype=\"absolute\",\n               output=\"ndvi_monthly\",\n               title=\"Filtered monthly NDVI\",\n               description=\"Filtered monthly NDVI - MOD13C2 - Cordoba, 2015-2019\")\n```\n:::\n\n\nCorroborar que la STRDS fue creada\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\n# check if it was created\ngs.read_command(\"t.list\",\n                type=\"strds\")\n```\n:::\n\n\nCrear archivo con lista de mapas\n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\n# list NDVI filtered files\nNDVI_filt = gs.list_grouped(type=\"raster\", \n                            pattern=\"*_filt\")[\"modis_ndvi\"]\nNDVI_filt[:10]\n```\n:::\n\n\nAsignar fecha a los mapas, i.e., registrar\n\n::: {.cell execution_count=20}\n``` {.python .cell-code}\n# register maps\ngs.run_command(\"t.register\",\n               input=\"ndvi_monthly\",\n               maps=NDVI_filt,\n               start=\"2015-01-01\",\n               increment=\"1 months\",\n               flags=\"i\")\n```\n:::\n\n\nImprimir info básica de la STRDS\n\n::: {.cell execution_count=21}\n``` {.python .cell-code}\n# print time series info\nprint(gs.read_command(\"t.info\", \n                      input=\"ndvi_monthly\"))\n```\n:::\n\n\nImprimir la lista de mapas en la STRDS\n\n::: {.cell execution_count=22}\n``` {.python .cell-code}\n# print list of maps in time series\nprint(gs.read_command(\"t.rast.list\", \n                      input=\"ndvi_monthly\"))\n```\n:::\n\n\nTambién podemos obtener los valores para un único pixel\n\n::: {.cell execution_count=23}\n``` {.python .cell-code}\n# Get region center coordinates for query \ngs.region(complete=True)\n```\n:::\n\n\n::: {.cell execution_count=24}\n``` {.python .cell-code}\n# Query map at center coordinates\nprint(gs.read_command(\"t.rast.what\", \n                      strds=\"s2_ndvi\", \n                      coordinates=\"637500,221750\", \n                      layout=\"col\", \n                      flags=\"n\"))\n```\n:::\n\n\n:::{.callout-warning title=\"Tarea\"}\nExplorar visualmente los valores de las series temporales en diferentes puntos. \nUsar [g.gui.tplot](https://grass.osgeo.org/grass-stable/manuals/g.gui.tplot.html) y seleccionar diferentes puntos interactivamente.\n:::\n\n## Datos faltantes\n\nObtener las estadísticas de la serie de tiempo\n\n::: {.cell execution_count=25}\n``` {.python .cell-code}\n# How much missing data we have after filtering for pixel reliability?\nprint(gs.read_command(\"t.rast.univar\",\n                      input=\"ndvi_monthly\"))\n```\n:::\n\n\nContar los datos válidos\n\n::: {.cell execution_count=26}\n``` {.python .cell-code}\n# count valid data\ngs.run_command(\"t.rast.series\",\n               input=\"ndvi_monthly\",\n               method=\"count\",\n               output=\"ndvi_count_valid\")\n```\n:::\n\n\nEstimar el porcentaje de datos faltantes\n\n::: {.cell execution_count=27}\n``` {.python .cell-code}\n# estimate percentage of missing data\ngs.mapcalc(exp=\"ndvi_missing = ((60 - ndvi_count_valid) * 100.0)/60\")\n```\n:::\n\n\nCómo guardar en una variable el numero de mapas de una serie de tiempo?\n\n::: {.cell execution_count=28}\n``` {.python .cell-code}\nn = gs.parse_command(\"t.info\", \n                     input=\"ndvi_monthly\", \n                     flags=\"g\")[\"number_of_maps\"]\nn\n```\n:::\n\n\n::: {.cell execution_count=29}\n``` {.python .cell-code}\ngs.mapcalc(exp=f\"ndvi_missing = (({n} - ndvi_count_valid) * 100.0)/{n}\")\n```\n:::\n\n\n:::{.callout-warning title=\"Tarea\"}\n- Mostrar el mapa que representa el porcentaje de datos faltantes y explorar \nlos valores. \n- Obtener estadísticas univariadas de este mapa.\n- Dónde estan los mayores porcentajes de datos faltantes? Por qué creen que \npuede ser?\n:::\n\n## Reconstrucción temporal: HANTS\n\n- Harmonic Analysis of Time Series (HANTS)\n- Implementado en la extensión [r.hants](https://grass.osgeo.org/grass-stable/manuals/addons/r.hants.html)\n\n![](../assets/img/evi_evi_hants.png){width=\"65%\"}\n\n\nInstalar la extensión *r.hants*\n\n::: {.cell execution_count=30}\n``` {.python .cell-code}\n# install extension\ngs.run_command(\"g.extension\",\n               extension=\"r.hants\")\n```\n:::\n\n\nListar los mapas y aplicar r.hants\n\n::: {.cell execution_count=31}\n``` {.python .cell-code}\n# list maps\nmaplist = gs.parse_command(\"t.rast.list\",\n                          input=\"ndvi_monthly\",\n                          columns=\"name\",\n                          method=\"comma\",\n                          flags=\"u\")\nmaplist = list(maplist.keys())\n```\n:::\n\n\n::: {.cell execution_count=32}\n``` {.python .cell-code}\n# gapfill: r.hants\ngs.run_command(\"r.hants\",\n               input=maplist,\n               range=[-2000,10000],\n               nf=5,\n               fet=500,\n               base_period=12)\n```\n:::\n\n\n::: {.cell execution_count=33}\n``` {.python .cell-code}\n# list filled maps\ngs.list_grouped(type=\"raster\",\n                pattern=\"*hants\")[\"modis_ndvi\"]\n```\n:::\n\n\n:::{.callout-warning title=\"Tarea\"}\nProbar diferentes ajustes de parámetros en\n[r.hants](https://grass.osgeo.org/grass-stable/manuals/addons/r.hants.html) y \ncomparar los resultados\n:::\n\nParcheo de serie original y reconstruída\n\n::: {.cell execution_count=34}\n``` {.python .cell-code}\n# patch original with filled (one map)\nNDVI_ORIG = \"MOD13C2.A2015001.006.single_Monthly_NDVI_filt\"\nNDVI_HANTS = \"MOD13C2.A2015001.006.single_Monthly_NDVI_filt_hants\"\n\ngs.run_command(\"r.patch\",\n               input=[NDVI_ORIG, NDVI_HANTS],\n               output=f\"{NDVI_HANTS}_patch\")\n```\n:::\n\n\nParcheo de serie original y reconstruída\n\n::: {.cell execution_count=35}\n``` {.python .cell-code}\n# list of maps\nORIG = gs.list_grouped(type=\"raster\",\n                     pattern=\"*_filt\")[\"modis_ndvi\"]\nFILL = gs.list_grouped(type=\"raster\",\n                       pattern=\"*_hants\")[\"modis_ndvi\"]\n```\n:::\n\n\n::: {.cell execution_count=36}\n``` {.python .cell-code}\n# patching\nfor i,j in zip(ORIG,FILL):\n    print(i, j)\n    out=f\"{j}_patch\"\n    gs.run_command(\"r.patch\",\n                   input=[i, j],\n                   output=out)\n```\n:::\n\n\nCrear serie de tiempo con los datos parcheados\n\n::: {.cell execution_count=37}\n``` {.python .cell-code}\n# create new time series \ngs.run_command(\"t.create\",\n               output=\"ndvi_monthly_patch\",\n               type=\"strds\",\n               temporaltype=\"absolute\",\n               title=\"Patched monthly NDVI\",\n               description=\"Filtered, gap-filled and patched monthly NDVI - MOD13C2 - Cordoba, 2015-2019\")\n```\n:::\n\n\nRegistrar los mapas en la serie de tiempo\n\n::: {.cell execution_count=38}\n``` {.python .cell-code}\n# list NDVI patched files\npatched_maps = gs.list_grouped(type=\"raster\",\n                               pattern=\"*patch\")[\"modis_ndvi\"]\npatched_maps[:5]\n```\n:::\n\n\n::: {.cell execution_count=39}\n``` {.python .cell-code}\n# register maps\ngs.run_command(\"t.register\",\n               flags=\"i\",\n               input=\"ndvi_monthly_patch\",\n               type=\"raster\",\n               maps=patched_maps,\n               start=\"2015-01-01\",\n               increment=\"1 months\")\n```\n:::\n\n\nImprimir información de la serie de tiempo\n\n::: {.cell execution_count=40}\n``` {.python .cell-code}\n# print time series info\nprint(gs.read_command(\"t.info\", \n                      input=\"ndvi_monthly_patch\"))\n```\n:::\n\n\n:::{.callout-warning title=\"Tarea\"}\n- Evaluar gráficamente los resultados de la reconstrucción de HANTS en pixeles con mayor porcentaje de datos faltantes \n- Obtener estadísticas univariadas para las nuevas series temporales\n:::\n\n![](https://www.mdpi.com/remotesensing/remotesensing-09-01333/article_deploy/html/images/remotesensing-09-01333-ag.png)\n\n:::{.callout-warning title=\"Tarea\"}\n- Ver la sección de métodos en @metz_new_2017 \n- Qué otros algoritmos existen o qué otra aproximación podría seguirse?\n:::\n\n## Agregación con granularidad\n\n:::{.callout-warning title=\"Tarea\"}\n- Obtener el promedio de NDVI cada dos meses\n- Visualizar la serie de tiempo resultante con `TimeSeriesMap`\n:::\n\n## Indicadores de fenología\n\n### Fecha de ocurrencia de máximos y mínimos\n\nIdentificamos primero los máximos y mínimos de la serie, luego reemplazamos \ncon `start_month()` los valores en la STRDS si coinciden con el mínimo o \nmáximo global y finalmente obtenemos el primer mes en el que aparecieron \nel máximo y el mínimo.\n\n::: {.cell execution_count=41}\n``` {.python .cell-code}\nmethods = [\"maximum\",\"minimum\"]\n\nfor me in methods:\n    # get maximum and minimum\n    gs.run_command(\"t.rast.series\",\n                   input=\"ndvi_monthly_patch\",\n                   method=me,\n                   output=f\"ndvi_{me}\")\n    # get month of maximum and minimum\n    gs.run_command(\"t.rast.mapcalc\",\n                   inputs=\"ndvi_monthly_patch\",\n                   output=f\"month_{me}_ndvi\",\n                   expression=f\"if(ndvi_monthly_patch == ndvi_{me}, start_month(), null())\",\n                   basename=f\"month_{me}_ndvi\")\n    # get the earliest month in which the maximum and minimum appeared\n    gs.run_command(\"t.rast.series\",\n                   input=f\"month_{me}_ndvi\",\n                   method=\"minimum\",\n                   output=f\"earliest_month_{me}_ndvi\")\n    # remove intermediate strds \n    gs.run_command(\"t.remove\",\n                   flags=\"rfd\",\n                   inputs=f\"month_{me}_ndvi\")\n```\n:::\n\n\n:::{.callout-warning title=\"Tarea\"}\n- Mostrar los mapas resultantes con `InteractiveMap`\n- Cuándo se observan los mínimos y máximos? Hay algun patrón? A qué se podría deber?\n:::\n\n:::{.callout-warning title=\"Tarea\"}\n- Asociar el máximo de LST con el máximo de NDVI y, la fecha de la máxima LST con la fecha del máximo NDVI\n- Agregar el mapset `modis_lst` a los mapsets accesibles.\n- Ver el módulo [r.covar](https://grass.osgeo.org/grass-stable/manuals/r.covar.html)\n:::\n\n### Tasa de crecimiento\n\nObtener series temporales de pendientes entre mapas consecutivos\n\n::: {.cell execution_count=42}\n``` {.python .cell-code}\n# time series of slopes\nexpression = \"slope_ndvi = (ndvi_monthly_patch[1] - ndvi_monthly_patch[0]) / td(ndvi_monthly_patch)\"\n\ngs.run_command(\"t.rast.algebra\", \n               expression=expression,\n               basename=\"slope_ndvi\",\n               suffix=\"gran\")\n```\n:::\n\n\nObtener la máxima pendiente por año\n\n::: {.cell execution_count=43}\n``` {.python .cell-code}\n# get max slope per year\ngs.run_command(\"t.rast.aggregate\",\n               input=\"slope_ndvi\",\n               output=\"ndvi_slope_yearly\",\n               basename=\"NDVI_max_slope_year\",\n               suffix=\"gran\",\n               method=\"maximum\",\n               granularity=\"1 years\")\n```\n:::\n\n\n:::{.callout-warning title=\"Tarea\"}\n- Obtener un mapa con la mayor tasa de crecimiento por píxel en el período 2015-2019\n- Qué modulo usarían?\n:::\n\n### Período de crecimiento\n\nInstalar la extensión *r.seasons*\n\n::: {.cell execution_count=44}\n``` {.python .cell-code}\n# install extension\ngs.run_command(\"g.extension\",\n               extension=\"r.seasons\")\n```\n:::\n\n\nDeterminar el comienzo, el final y la duración del período de crecimiento\n\n::: {.cell execution_count=45}\n``` {.python .cell-code}\n# start, end and length of growing season\ngs.run_command(\"r.seasons\",\n               input=patched_maps,\n               prefix=\"ndvi_season\",\n               n=3,\n               nout=\"ndvi_season\",\n               threshold_value=3000,\n               min_length=5)\n```\n:::\n\n\n:::{.callout-warning title=\"Tarea\"}\n- Qué nos dice cada mapa? Dónde es más larga la estación de crecimiento?\n- Exportar los mapas resultantes como .png\n:::\n\nCrear un mapa de umbrales para usar en *r.seasons*\n\n::: {.cell execution_count=46}\n``` {.python .cell-code}\n# create a threshold map: min ndvi + 0.1*ndvi\ngs.mapcalc(exp=\"threshold_ndvi = ndvi_min * 1.1\")\n```\n:::\n\n\n:::{.callout-warning title=\"Tarea\"}\nUtilizar el mapa de umbrales en [r.seasons](https://grass.osgeo.org/grass-stable/manuals/addons/r.seasons.html) y comparar los mapas de salida con los resultados de utilizar sólo un valor de umbral\n:::\n\n## Serie de tiempo de NDWI\n\nListas de mapas de reflectancia\n\n::: {.cell execution_count=47}\n``` {.python .cell-code}\nlist_nir = gs.list_grouped(type=\"raster\", \n                           pattern=\"*NIR*\")[\"modis_ndvi\"]\nlist_mir = gs.list_grouped(type=\"raster\", \n                           pattern=\"*MIR*\")[\"modis_ndvi\"]\n\nlen(list_nir,list_mir)\n```\n:::\n\n\nAsignamos *semantic labels* correspondientes a las bandas\n\n::: {.cell execution_count=48}\n``` {.python .cell-code}\n# asign semantic labels to NIR and MIR maps\nfor i in list_nir:\n    gs.run_command(\"r.support\",\n                   map=i,\n                   semantic_label=\"nir\")\n\nfor i in list_mir:\n    gs.run_command(\"r.support\",\n                   map=i,\n                   semantic_label=\"mir\")\n```\n:::\n\n\n::: {.cell execution_count=49}\n``` {.python .cell-code}\n# check\ngs.raster_info(\"MOD13C2.A2015001.006.single_Monthly_MIR_reflectance\")[\"semantic_label\"]\n```\n:::\n\n\nCrear series temporales de NIR y MIR\n\n::: {.cell execution_count=50}\n``` {.python .cell-code}\n# create time series of NIR and MIR altogether\ngs.run_command(\"t.create\",\n               output=\"modis_surf\",\n               type=\"strds\",\n               temporaltype=\"absolute\",\n               title=\"Monthly surface reflectance, NIR and MIR\",\n               description=\"NIR and MIR monthly - MOD13C2 - 2015-2019\")\n```\n:::\n\n\nRegistrar mapas\n\n::: {.cell execution_count=51}\n``` {.python .cell-code}\n# register maps\ngs.run_command(\"t.register\",\n               input=\"modis_surf\",\n               maps=list_nir,\n               start=\"2015-01-01\",\n               increment=\"1 months\",\n               flags=\"i\")\n\ngs.run_command(\"t.register\",\n               input=\"modis_surf\",\n               maps=list_mir,\n               start=\"2015-01-01\",\n               increment=\"1 months\",\n               flags=\"i\")\n```\n:::\n\n\nImprimir información de la serie de tiempo\n\n::: {.cell execution_count=52}\n``` {.python .cell-code}\n# print time series info\nprint(gs.read_command(\"t.info\", \n                      input=\"modis_surf\"))\n```\n:::\n\n\n::: {.cell execution_count=53}\n``` {.python .cell-code}\n# List only NIR maps\nprint(gs.read_command(\"t.rast.list\", \n                      input=\"modis_surf.nir\", \n                      columns=\"name,semantic_label\"))\n```\n:::\n\n\nEstimación de la serie temporal de NDWI\n\n::: {.cell execution_count=54}\n``` {.python .cell-code}\n# extract nir and mir strds\nsls = [\"nir\", \"mir\"]\n\nfor sl in sls:\n    gs.run_command(\"t.rast.extract\",\n                   input=\"modis_surf\",\n                   where=f\"semantic_label == '{sl}'\",\n                   output=sl)\n```\n:::\n\n\n::: {.cell execution_count=55}\n``` {.python .cell-code}\n# estimate NDWI time series\nexpression=\"ndwi_monthly = if(nir > 0 && mir > 0, (float(nir - mir) / float(nir + mir)), null())\"\n\ngs.run_command(\"t.rast.algebra\",\n               basename=\"ndwi_monthly\",\n               expression=expression,\n               suffix=\"gran\",\n               flags=\"n\")\n```\n:::\n\n\n::: {.cell execution_count=56}\n``` {.python .cell-code}\n# estimate NDWI time series\n#gs.run_command(\"t.rast.mapcalc\", \n#               inputs=\"modis_surf.mir,modis_surf.nir\", \n#               output=\"ndwi_monthly\", \n#               basename=\"ndwi\",\n#               expression=\"float(modis_surf.nir - modis_surf.mir) / (modis_surf.nir + modis_surf.mir)\")\n```\n:::\n\n\n::: {.cell execution_count=57}\n``` {.python .cell-code}\ngs.run_command(\"t.rast.colors\", \n               input=\"ndwi_monthly\", \n               color=\"ndwi\")\n```\n:::\n\n\n::: {.cell execution_count=58}\n``` {.python .cell-code}\nprint(gs.read_command(\"t.info\", \n                      input=\"ndwi_monthly\"))\n```\n:::\n\n\n:::{.callout-warning title=\"Tarea\"}\nObtener valores máximos y mínimos para cada mapa de NDWI y explorar el trazado de la serie de tiempo en diferentes puntos de forma interactiva\n\nVer el manual de [t.rast.univar](https://grass.osgeo.org/grass-stable/manuals/t.rast.univar.html)\n:::\n\n### Frecuencia de inundación\n\nReclasificar los mapas según un umbral\n\n::: {.cell execution_count=59}\n``` {.python .cell-code}\n# reclassify\ngs.run_command(\"t.rast.mapcalc\",\n               input=\"ndwi_monthly\",\n               output=\"flood\",\n               basename=\"flood\",\n               expression=\"if(ndwi_monthly > 0.8, 1, null())\",\n               flags=\"n\")\n```\n:::\n\n\nObtener frecuencia de inundación\n\n::: {.cell execution_count=60}\n``` {.python .cell-code}\n# flooding frequency\ngs.run_command(\"t.rast.series\",\n               input=\"flood\",\n               output=\"flood_freq\",\n               method=\"sum\")\n```\n:::\n\n\n:::{.callout-warning title=\"Tarea\"}\nCuáles son las áreas que se han inundado con más frecuencia?\n:::\n\n## Regresión NDVI-NDWI\n\nInstalar la extensión *r.regression.series*\n\n::: {.cell execution_count=61}\n``` {.python .cell-code}\n# install extension\ngs.run_command(\"g.extension\",\n               extension=\"r.regression.series\")\n```\n:::\n\n\nRealizar una regresión entre las series temporales de NDVI y NDWI\n\n::: {.cell execution_count=62}\n``` {.python .cell-code}\nxseries = patched_maps[1:]\nyseries = gs.list_grouped(type=\"raster\",\n                          pattern=\"ndwi_monthly*\")[\"modis_ndvi\"]\n\ngs.run_command(\"r.regression.series\",\n               xseries=xseries,\n               yseries=yseries,\n               output=\"ndvi_ndwi_rsq\",\n               method=\"rsq\")\n```\n:::\n\n\n::: {.cell execution_count=63}\n``` {.python .cell-code}\nrsq = gj.InteractiveMap(width = 400, use_region=True)\nrsq.add_raster(\"ndvi_ndwi_rsq\", opacity=0.8)\nrsq.add_layer_control(position = \"bottomright\")\nrsq.show()\n```\n:::\n\n\n:::{.callout-warning title=\"Tarea\"}\nDeterminar dónde está la mayor correlación entre NDVI y NDWI\n:::\n\n## Recursos (muy) útiles \n\n- [Temporal data processing wiki](https://grasswiki.osgeo.org/wiki/Temporal_data_processing)\n- [GRASS GIS and R for time series processing wiki](https://grasswiki.osgeo.org/wiki/Temporal_data_processing/GRASS_R_raster_time_series_processing)\n- [GRASS GIS temporal workshop at NCSU](http://ncsu-geoforall-lab.github.io/grass-temporal-workshop/)\n- [GRASS GIS course IRSAE 2018](http://training.gismentors.eu/grass-gis-irsae-winter-course-2018/index.html)\n- [GRASS GIS workshop held in Jena 2023](https://training.gismentors.eu/grass-gis-workshop-jena/)\n\n## Referencias\n\n::: {#refs .tiny}\n:::\n\n",
    "supporting": [
      "exercise_temporal_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}