{
  "hash": "c6555a1d5c7c4ac4215884560526d199",
  "result": {
    "markdown": "---\ntitle: Intro a series de tiempo\nauthor: Verónica Andreo\ndate: today\nformat:\n  html:\n    code-tools: true\n    code-copy: true\n    code-fold: false\nexecute:\n  eval: false\n  cache: false\n  keep-ipynb: true\n---\n\n## Procesamiento de series de tiempo en GRASS GIS\n\n\n### Contenidos\n\n- Nociones básicas\n- TGRASS framework\n- Creación de series de tiempo\n- Álgebra temporal y variables temporales\n- Distintos tipos de agregación\n- Estadística zonal e islas de calor urbanas\n- Conexión con R\n\n**GRASS GIS** es **el primer SIG de código abierto** que incorporó capacidades \npara **gestionar, analizar, procesar y visualizar datos espacio-temporales**,\nasí como las relaciones temporales entre series de tiempo.\n\n## TGRASS: GRASS Temporal\n\n- Completamente basado en metadatos, por lo que no hay duplicación de datos\n- Sigue una aproximación *Snapshot*, i.e., añade marcas de tiempo o *timestamps* a los mapas\n- Una colección de mapas de la misma variable con timestamps se llama space-time dataset o STDS\n- Los mapas en una STDS pueden tener diferentes extensiones espaciales y temporales\n- TGRASS utiliza una base de datos [SQLite](https://www.sqlite.org/index.html) para almacenar la extensión temporal y espacial de las STDS, así como las relaciones topológicas entre los mapas y entre las STDS en cada mapset.\n\n## Space-time datasets\n\n- Space time raster datasets (**STRDS**)\n- Space time 3D raster datasets (**STR3DS**)\n- Space time vector datasets (**STVDS**)\n\n## Otras nociones básicas en TGRASS\n\n- El tiempo puede definirse como intervalos (inicio y fin) o como instancias (sólo inicio)\n- El tiempo puede ser absoluto (por ejemplo, 2017-04-06 22:39:49) o relativo (por ejemplo, 4 años, 90 días)\n- Granularidad es el mayor divisor común de todas las extensiones temporales (y posibles gaps) de los mapas de un STDS\n- Topología se refiere a las relaciones temporales entre los intervalos de tiempo en una STDS\n\n<img src=\"../assets/img/temp_relation.png\">\n\n- Muestreo temporal se utiliza para determinar el estado de un proceso durante un segundo proceso.\n\n<img src=\"../assets/img/temp_samplings.png\" width=\"55%\">\n\n## Módulos temporales\n\n- **t.\\***: Módulos generales para manejar STDS de todos los tipos\n- **t.rast.\\***: Módulos que tratan con STRDS\n- **t.rast3d.\\***: Módulos que tratan con STR3DS\n- **t.vect.\\***: Módulos que tratan con STVDS\n\n\n## TGRASS: marco general y flujo de trabajo\n\n![](../assets/img/tgrass_flowchart.png)\n\n## Manos a la obra con series de tiempo raster en GRASS GIS\n\n### Datos para la sesión\n\n- Producto MODIS: <a href=\"https://lpdaac.usgs.gov/products/mod11b3v006/\">MOD11B3 Collection 6</a>\n- Tile: h12v12\n- Composiciones mensuales \n- Resolución espacial: 5600m\n- Mapset *`modis_lst`* \n\n\n![](../assets/img/mod11b3_h12v12.png)\n\n### Código para la sesión\n\n- [Comandos GRASS](https://gitlab.com/veroandreo/maie-procesamiento/-/raw/taller-grass-online/code/05_temporal_code.sh?inline=false)\n- [Comandos R](https://gitlab.com/veroandreo/maie-procesamiento/-/raw/taller-grass-online/code/05_temporal_code.r?inline=false)\n\nIniciar GRASS GIS directamente en el mapset *`modis_lst`*\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\n# paths\ngrassdata='/home/veroandreo/grassdata/'\nlocation='posgar2007_4_cba'\nmapset='modis_lst'\n```\n:::\n\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nimport os\nimport subprocess\nimport sys\n\n# Ask GRASS GIS where its Python packages are to be able to start it from the notebook\nsys.path.append(\n    subprocess.check_output([\"grass\", \"--config\", \"python_path\"], text=True).strip()\n)\n\n# Importar los paquetes python de GRASS\nimport grass.script as gs\nimport grass.jupyter as gj\n\n# Iniciar GRASS\nsession = gj.init(grassdata, location, mapset)\n```\n:::\n\n\nEstablecer región computacional y máscara\n\nListar los mapas raster y obtener información de uno de ellos\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\n# Get list of raster maps in the 'modis_lst' mapset\ng.list type=raster mapset=.\n\n# Get info from one of the raster maps\nr.info map=MOD11B3.A2015060.h12v12.single_LST_Day_6km\n```\n:::\n\n\nEstablecer la región computacional\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\n# Set region to Cba boundaries with LST maps' resolution\ng.region -p vector=provincia_cba \\\n  align=MOD11B3.A2015060.h12v12.single_LST_Day_6km\n```\n:::\n\n\nAplicar máscara\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\n# Set a MASK to Cba boundary\nr.mask vector=provincia_cba\n```\n:::\n\n\n### Crear un conjunto de datos espacio-temporales (STDS)\n\n**[t.create](https://grass.osgeo.org/grass-stable/manuals/t.create.html)**\n<br>\n- Crea una tabla SQLite en la base de datos temporal \n- Permite manejar grandes cantidades de mapas usando el STDS como entrada\n- Necesitamos especificar:\n  - *tipo de mapas* (raster, raster3d o vector)\n  - *tipo de tiempo* (absoluto o relativo)\n\nCrear la STRDS\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\n# Create the STRDS\nt.create type=strds temporaltype=absolute output=LST_Day_monthly \\\n  title=\"Monthly LST Day 5.6 km\" \\\n  description=\"Monthly LST Day 5.6 km MOD11B3.006 Cordoba, 2015-2019\"\n```\n:::\n\n\nChequear si la STRDS fue creada\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\n# Check if the STRDS is created\nt.list type=strds\n```\n:::\n\n\nObtener información sobre la STRDS\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\n# Get info about the STRDS\nt.info input=LST_Day_monthly\n```\n:::\n\n\n### Registrar mapas en una STDS (asignar *timestamps*)\n\n**[t.register](https://grass.osgeo.org/grass-stable/manuals/t.register.html)**\n<br>\n- Asigna o agrega timestamps a los mapas\n- Necesitamos: \n  - el *STDS vacío* como entrada, i.e., la tabla SQLite contenedora, \n  - la *lista de mapas* que se registrarán, \n  - la *fecha de inicio*,\n  - la opción de *incremento* junto con *-i* para la creación de intervalos \n\nAñadir timestamps a los mapas, i.e., registrar mapas\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\n# Add time stamps to maps (i.e., register maps)\nt.register -i input=LST_Day_monthly \\\n maps=`g.list type=raster pattern=\"MOD11B3*LST_Day*\" separator=comma` \\\n start=\"2015-01-01\" increment=\"1 months\"\n```\n:::\n\n\nChequear la información sobre la STRDS nuevamente\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\n# Check info again\nt.info input=LST_Day_monthly\n```\n:::\n\n\nObtener la lista de mapas en la STRDS\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\n# Check the list of maps in the STRDS\nt.rast.list input=LST_Day_monthly\n```\n:::\n\n\nChequear los valores mínimos y máximos de cada mapa\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\n# Check min and max per map\nt.rast.list input=LST_Day_monthly columns=name,min,max\n```\n:::\n\n\nPara más opciones, ver el manual de <a href=\"https://grass.osgeo.org/grass-stable/manuals/t.register.html\">t.register</a> y la wiki sobre <a href=\"https://grasswiki.osgeo.org/wiki/Temporal_data_processing/maps_registration\">opciones para registrar mapas en STDS</a>.\n\nRepresentación gráfica de STDS\n\nCrear una representación gráfica de la serie de tiempo\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\n# graphical representation of our STRDS\ng.gui.timeline inputs=LST_Day_monthly\n```\n:::\n\n\n![](../assets/img/g_gui_timeline_monthly.png)\n\nVer el manual de <a href=\"https://grass.osgeo.org/grass-stable/manuals/g.gui.timeline.html\">g.gui.timeline</a>\n\n\n### Operaciones con álgebra temporal: **[t.rast.algebra](https://grass.osgeo.org/grass-stable/manuals/t.rast.algebra.html)**\n\n- Realiza una amplia gama de operaciones de álgebra temporal y espacial basadas en la topología temporal de los mapas\n  - Operadores temporales: unión, intersección, etc.\n  - Funciones temporales: *start_time()*, *start_doy()*, etc.\n  - Operadores espaciales (subconjunto de [r.mapcalc](https://grass.osgeo.org/grass-stable/manuals/r.mapcalc.html))\n  - Modificador de vecindario temporal: *[x,y,t]*\n  - Otras funciones temporales como *t_snap()*, *buff_t()* o *t_shift()*\n\n**¡pueden combinarse en expresiones complejas!**\n\n\n#### Desde K*50 a Celsius usando la calculadora temporal\n\nRe-escalar a grados Celsius\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\n# Re-scale data to degrees Celsius\nt.rast.algebra basename=LST_Day_monthly_celsius suffix=gran \\\n  expression=\"LST_Day_monthly_celsius = LST_Day_monthly * 0.02 - 273.15\"\n```\n:::\n\n\nVer info de la nueva serie de tiempo\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\n# Check info\nt.info LST_Day_monthly_celsius\n```\n:::\n\n\n#### Gráfico temporal: LST vs tiempo\n\nGráfico temporal de LST para la ciudad de Córdoba, Argentina\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\n# LST time series plot for Cba city center\ng.gui.tplot strds=LST_Day_monthly_celsius \\\n  coordinates=4323478.531282977,6541664.09350761 \\\n  title=\"Monthly LST. City center of Cordoba\" \\\n  xlabel=\"Time\" ylabel=\"LST\"\n```\n:::\n\n\nPara un único punto, ver <a href=\"https://grass.osgeo.org/grass-stable/manuals/g.gui.tplot.html\">g.gui.tplot</a>. Para un vector de puntos, ver <a href=\"https://grass.osgeo.org/grass-stable/manuals/t.rast.what.html\">t.rast.what</a>.\n\n![](../assets/img/g_gui_tplot_final.png)\n\nLas coordenadas del punto pueden ser escritas directamente, copiadas desde el mapa o seleccionadas interactivamente.\n\n## Listas y selecciones\n\n- **[t.list](https://grass.osgeo.org/grass-stable/manuals/t.list.html)** para listar las STDS y los mapas registrados en la base de datos temporal,\n- **[t.rast.list](https://grass.osgeo.org/grass-stable/manuals/t.rast.list.html)** para mapas en series temporales de rasters, y\n- **[t.vect.list](https://grass.osgeo.org/grass-stable/manuals/t.vect.list.html)** para mapas en series temporales de vectores.\n\n### Variables usadas para hacer las listas y selecciones\n\nSTRDS:*id, name, creator, mapset, temporal_type, creation_time, start_time, end_time, north, south, west, east, nsres, ewres, cols, rows, number_of_cells, min, max*\n\nSTVDS:*id, name, layer, creator, mapset, temporal_type, creation_time, start_time, end_time, north, south, west, east, points, lines, boundaries, centroids, faces, kernels, primitives, nodes, areas, islands, holes, volumes*\n\n#### Ejemplos de listas y selecciones\n\nMapas cuyo valor mínimo es menor o igual a 10\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\n# Maps with minimum value lower than or equal to 10\nt.rast.list input=LST_Day_monthly_celsius order=min \\\n columns=name,start_time,min where=\"min <= '10.0'\"\n```\n:::\n\n\nMapas cuyo valor máximo es mayor a 30\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\n# Maps with maximum value higher than 30\nt.rast.list input=LST_Day_monthly_celsius order=max \\\n columns=name,start_time,max where=\"max > '30.0'\"\n```\n:::\n\n\nMapas contenidos entre dos fechas\n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\n# Maps between two given dates\nt.rast.list input=LST_Day_monthly_celsius columns=name,start_time \\\n where=\"start_time >= '2015-05' and start_time <= '2015-08-01 00:00:00'\"\n```\n:::\n\n\nTodos los mapas correspondientes al mes de Enero\n\n::: {.cell execution_count=20}\n``` {.python .cell-code}\n# Maps from January\nt.rast.list input=LST_Day_monthly_celsius columns=name,start_time \\\n where=\"strftime('%m', start_time)='01'\"\n```\n:::\n\n\n### Estadística descriptiva de STRDS\n\nImprimir estadísticas descriptivas univariadas para cada mapa dentro de la STRDS\n\n::: {.cell execution_count=21}\n``` {.python .cell-code}\n# Print univariate stats for maps within STRDS\nt.rast.univar input=LST_Day_monthly_celsius\n```\n:::\n\n\nObtener estadísticas extendidas con la opción -e\n\n::: {.cell execution_count=22}\n``` {.python .cell-code}\n# Get extended statistics\nt.rast.univar -e input=LST_Day_monthly_celsius\n```\n:::\n\n\nEscribir la salida a un archivo de texto\n\n::: {.cell execution_count=23}\n``` {.python .cell-code}\n# Write the univariate stats output to a csv file\nt.rast.univar input=LST_Day_monthly_celsius separator=comma \\\n  output=stats_LST_Day_monthly_celsius.csv\n```\n:::\n\n\n### Agregación temporal 1: Serie completa\n\n**[t.rast.series](https://grass.osgeo.org/grass-stable/manuals/t.rast.series.html)**\n\n- Agrega STRDS *completas* o partes de ellas usando la opción *where*.\n- Diferentes métodos disponibles: promedio, mínimo, máximo, mediana, moda, etc.\n\n\nLST máxima y mínima del período 2015-2019\n\nObtener el mapa de la máxima LST del período\n\n::: {.cell execution_count=24}\n``` {.python .cell-code}\n# Get maximum LST in the STRDS\nt.rast.series input=LST_Day_monthly_celsius \\\n  output=LST_Day_max method=maximum\n```\n:::\n\n\nObtener el mapa de la mínima LST del período\n\n::: {.cell execution_count=25}\n``` {.python .cell-code}\n# Get minimum LST in the STRDS\nt.rast.series input=LST_Day_monthly_celsius \\\n  output=LST_Day_min method=minimum\n```\n:::\n\n\nCambiar la paleta de colores a *celsius*\n\n::: {.cell execution_count=26}\n``` {.python .cell-code}\n# Change color pallete to celsius\nr.colors map=LST_Day_min,LST_Day_max color=celsius\n```\n:::\n\n\n> Comparar mapas con la herramienta Mapswipe\n\n![](../assets/img/g_gui_mapswipe_lstmin.png)\n\n### Operaciones usando variables temporales\n\n**[t.rast.mapcalc](https://grass.osgeo.org/grass-stable/manuals/t.rast.mapcalc.html)**\n\n- Ejecuta expresiones espacio-temporales tipo *r.mapcalc*\n- Permite *operadores espaciales y temporales*, así como *variables internas* en la expresión\n- Las variables temporales incluyen: *start_time(), end_time(), start_month(), start_doy()*, etc. \n\n\nCuál es el mes de máxima LST?\n\nObtener el mes en que ocurre el máximo de LST en cada pixel\n\n::: {.cell execution_count=27}\n``` {.python .cell-code}\n# Get month of maximum LST\nt.rast.mapcalc -n inputs=LST_Day_monthly_celsius \\\n  output=month_max_lst \\\n  expression=\"if(LST_Day_monthly_celsius == LST_Day_max, start_month(), null())\" \\\n  basename=month_max_lst\n```\n:::\n\n\nObtener información del mapa resultante\n\n::: {.cell execution_count=28}\n``` {.python .cell-code}\n# Get basic info\nt.info month_max_lst\n```\n:::\n\n\nObtener el primer mes en que aparece el máximo de LST\n\n::: {.cell execution_count=29}\n``` {.python .cell-code}\n# Get the earliest month in which the maximum appeared (method minimum)\nt.rast.series input=month_max_lst \\\n  method=minimum \\\n  output=max_lst_date\n```\n:::\n\n\nRemover la STRDS intermedia y los mapas que contiene: month_max_lst\n\n::: {.cell execution_count=30}\n``` {.python .cell-code}\n# Remove month_max_lst strds \n# we were only interested in the resulting aggregated map\nt.remove -rf inputs=month_max_lst\n```\n:::\n\n\nMostrar el mapa resultante desde la terminal\n\nAbrir un monitor wx\n\n::: {.cell execution_count=31}\n``` {.python .cell-code}\n# Open a monitor\nd.mon wx0\n```\n:::\n\n\nMostrar el mapa raster\n\n::: {.cell execution_count=32}\n``` {.python .cell-code}\n# Display the raster map\nd.rast map=max_lst_date\n```\n:::\n\n\nMostrar sólo los bordes del mapa vectorial de NC\n\n::: {.cell execution_count=33}\n``` {.python .cell-code}\n# Display boundary vector map\nd.vect map=provincia_cba type=boundary color=#4D4D4D width=2\n```\n:::\n\n\nAgregar leyenda\n\n::: {.cell execution_count=34}\n``` {.python .cell-code}\n# Add raster legend\nd.legend -t raster=max_lst_date title=\"Month\" \\\n  labelnum=6 title_fontsize=20 font=sans fontsize=16\n```\n:::\n\n\nAgregar barra de escala\n\n::: {.cell execution_count=35}\n``` {.python .cell-code}\n# Add scale bar\nd.barscale length=100 units=kilometers segment=4 fontsize=14\n```\n:::\n\n\nAgregar Norte\n\n::: {.cell execution_count=36}\n``` {.python .cell-code}\n# Add North arrow\nd.northarrow style=1b text_color=black\n```\n:::\n\n\nAgregar título\n\n::: {.cell execution_count=37}\n``` {.python .cell-code}\n# Add text\nd.text text=\"Month of maximum LST\" \\\n  color=black align=cc font=sans size=12\n```\n:::\n\n\n![](../assets/img/month_max_lst.png)\n\n> Podríamos haber hecho lo mismo pero anualmente para conocer en qué mes ocurre el máximo en cada año y así evaluar la ocurrencia de tendencias. Cómo lo harían?\n\n### Agregación temporal 2: granularidad\n\n**[t.rast.aggregate](https://grass.osgeo.org/grass-stable/manuals/t.rast.aggregate.html)**\n\n- Agrega mapas raster dentro de STRDS con diferentes **granularidades** \n- La opción *where* permite establecer fechas específicas para la agregación\n- Diferentes métodos disponibles: promedio, mínimo, máximo, mediana, moda, etc.\n\nDe LST mensual a estacional\n\nLST media estacional\n\n::: {.cell execution_count=38}\n``` {.python .cell-code}\n# 3-month mean LST\nt.rast.aggregate input=LST_Day_monthly_celsius \\\n  output=LST_Day_mean_3month \\\n  basename=LST_Day_mean_3month suffix=gran \\\n  method=average granularity=\"3 months\"\n```\n:::\n\n\nChequear info\n\n::: {.cell execution_count=39}\n``` {.python .cell-code}\n# Check info\nt.info input=LST_Day_mean_3month\n```\n:::\n\n\nChequear lista de mapas\n\n::: {.cell execution_count=40}\n``` {.python .cell-code}\n# Check map list\nt.rast.list input=LST_Day_mean_3month\n```\n:::\n\n\n> **Tarea** \n> \n> Comparar las líneas de tiempo mensual y estacional con [g.gui.timeline](https://grass.osgeo.org/grass-stable/manuals/g.gui.timeline.html)\n\n\n```{bash}\ng.gui.timeline inputs=LST_Day_monthly_celsius,LST_Day_mean_3month\n```\n\n\nGraficar LST estacional con monitores wx\n\nEstablecer la paleta de colores *celsius* para la STRDS estacional\n\n::: {.cell execution_count=41}\n``` {.python .cell-code}\n# Set STRDS color table to celsius degrees\nt.rast.colors input=LST_Day_mean_3month color=celsius\n```\n:::\n\n\nIniciar un monitor *Cairo*\n\n::: {.cell execution_count=42}\n``` {.python .cell-code}\n# Start a new graphics monitor\nd.mon cairo out=frames.png width=1400 height=500 resolution=4 --o\n```\n:::\n\n\nCrear el primer frame\n\n::: {.cell execution_count=43}\n``` {.python .cell-code}\n# create a first frame\nd.frame -c frame=first at=0,100,0,25\nd.rast map=LST_Day_mean_3month_2015_01\nd.vect map=provincia_cba type=boundary color=#4D4D4D width=2\nd.text text='Ene-Mar 2015' color=black font=sans size=6 bgcolor=white\n```\n:::\n\n\nCrear el segundo frame\n\n::: {.cell execution_count=44}\n``` {.python .cell-code}\n# create a second frame\nd.frame -c frame=second at=0,100,25,50\nd.rast map=LST_Day_mean_3month_2015_04\nd.vect map=provincia_cba type=boundary color=#4D4D4D width=2\nd.text text='Abr-Jun 2015' color=black font=sans size=6 bgcolor=white\n```\n:::\n\n\nCrear el tercer frame\n\n::: {.cell execution_count=45}\n``` {.python .cell-code}\n# create a third frame\nd.frame -c frame=third at=0,100,50,75\nd.rast map=LST_Day_mean_3month_2015_07\nd.vect map=provincia_cba type=boundary color=#4D4D4D width=2\nd.text text='Jul-Sep 2015' color=black font=sans size=6 bgcolor=white\n```\n:::\n\n\nCrear el cuarto frame\n\n::: {.cell execution_count=46}\n``` {.python .cell-code}\n# create a fourth frame\nd.frame -c frame=fourth at=0,100,75,100\nd.rast map=LST_Day_mean_3month_2015_10\nd.vect map=provincia_cba type=boundary color=#4D4D4D width=2\nd.text text='Oct-Dic 2015' color=black font=sans size=6 bgcolor=white\n```\n:::\n\n\nLiberar el monitor\n\n::: {.cell execution_count=47}\n``` {.python .cell-code}\n# release monitor\nd.mon -r\n```\n:::\n\n\n![](../assets/img/frames.png)\n\nLST estacional en 2015\n\n\n> **Tarea**\n>\n> Ahora que ya conocen [t.rast.aggregate](https://grass.osgeo.org/grass-stable/manuals/t.rast.aggregate.html), \n> extraigan el mes de máximo LST por año y luego vean si hay alguna tendencia positiva o negativa,\n> es decir, si los valores máximos de LST se observan más tarde o más temprano con el tiempo (años)\n\n\nUna solución podría ser...\n\n\n```{bash}\nt.rast.aggregate \\\n  input=LST_Day_monthly_celsius \\\n  output=month_max_LST_per_year \\\n  basename=month_max_LST suffix=gran \\\n  method=max_raster \\\n  granularity=\"1 year\" \n\nt.rast.series \\\n  input=month_max_LST_per_year \\\n  output=slope_month_max_LST \\\n  method=slope\n```\n\n\n\n### Animaciones\n\nAnimación de la serie estacional de LST\n\n::: {.cell execution_count=48}\n``` {.python .cell-code}\n# Animation of seasonal LST\ng.gui.animation strds=LST_Day_mean_3month\n```\n:::\n\n\nVer el manual de <a href=\"https://grass.osgeo.org/grass-stable/manuals/g.gui.animation.html\">g.gui.animation</a> para más opciones y ajustes.\n\n\n### Agregación vs Climatología\n\n<img src=\"../assets/img/aggregation.png\" width=\"50%\">\n\nAgregación por granularidad\n\n\n<img src=\"../assets/img/climatology.png\" width=\"50%\">\n\nAgregación tipo climatología\n\n\n### Climatologías mensuales\n\nLST promedio de Enero\n\n::: {.cell execution_count=49}\n``` {.python .cell-code}\n# January average LST\nt.rast.series input=LST_Day_monthly_celsius \\\n  method=average \\\n  where=\"strftime('%m', start_time)='01'\" \\\n  output=LST_average_jan\n```\n:::\n\n\nClimatología para todos los meses\n\n::: {.cell execution_count=50}\n``` {.python .cell-code}\n# for all months - *nix\nfor MONTH in `seq -w 1 12` ; do \n t.rast.series input=LST_Day_monthly_celsius method=average \\\n  where=\"strftime('%m', start_time)='${MONTH}'\" \\\n  output=LST_average_${MONTH}\ndone\n```\n:::\n\n\n> **Tarea**\n> \n> - Comparar las medias mensuales con las climatologías mensuales\n> - Las climatologías que creamos forman una STRDS?\n\n\n### Anomalías anuales\n\n`\\[AnomaliaStd_i = \\frac{Media_i - Media}{SD}\\]`\n\n\nSe necesitan:\n\n- promedio y desviación estándar general de la serie\n- promedios anuales\n\n\nObtener el promedio general de la serie\n\n::: {.cell execution_count=51}\n``` {.python .cell-code}\n# Get general average\nt.rast.series input=LST_Day_monthly_celsius \\\n method=average output=LST_average\n```\n:::\n\n\nObtener el desvío estándar general de la serie\n\n::: {.cell execution_count=52}\n``` {.python .cell-code}\n# Get general SD\nt.rast.series input=LST_Day_monthly_celsius \\\n method=stddev output=LST_sd\n```\n:::\n\n\nObtener los promedios anuales\n\n::: {.cell execution_count=53}\n``` {.python .cell-code}\n# Get annual averages\nt.rast.aggregate input=LST_Day_monthly_celsius \\\n method=average granularity=\"1 years\" \\\n output=LST_yearly_average basename=LST_yearly_average\n```\n:::\n\n\nEstimar las anomalías anuales\n\n::: {.cell execution_count=54}\n``` {.python .cell-code}\n# Estimate annual anomalies\nt.rast.algebra basename=LST_year_anomaly \\\n expression=\"LST_year_anomaly = (LST_yearly_average - map(LST_average)) / map(LST_sd)\"\n```\n:::\n\n\nEstablecer la paleta de colores *differences*\n\n::: {.cell execution_count=55}\n``` {.python .cell-code}\n# Set difference color table\nt.rast.colors input=LST_year_anomaly color=difference\n```\n:::\n\n\nAnimación\n\n::: {.cell execution_count=56}\n``` {.python .cell-code}\n# Animation of annual anomalies\ng.gui.animation strds=LST_year_anomaly\n```\n:::\n\n\n### Isla de calor superficial urbana (Surface Urban Heat Island - SUHI)\n\n- La temperatura del aire de una zona urbana es más alta que la de las zonas cercanas\n- La UHI tiene efectos negativos en la calidad del agua y el aire, la biodiversidad, la salud humana y el clima.\n- La SUHI también está muy relacionada con la salud, ya que influye en la UHI \n\n\n![](https://res.mdpi.com/remotesensing/remotesensing-11-01212/article_deploy/html/images/remotesensing-11-01212-g002-550.jpg)\n\nSUHI y área rural en Buenos Aires. Fuente: <a href=\"https://www.mdpi.com/2072-4292/11/10/1212/htm\">Wu et al, 2019.</a>\n\n### Estadística zonal en series de tiempo de datos raster\n\n**[v.strds.stats](https://grass.osgeo.org/grass7/manuals/addons/v.strds.stats.html)**\n- Permite obtener datos de series de tiempo agregados espacialmente para polígonos de un mapa vectorial\n\n\nSUHI estival para *Córdoba* y alrededores\n\nInstalar la extensión *v.strds.stats*\n\n::: {.cell execution_count=57}\n``` {.python .cell-code}\n# Install v.strds.stats add-on\ng.extension extension=v.strds.stats\n```\n:::\n\n\nListar mapas\n\n::: {.cell execution_count=58}\n``` {.python .cell-code}\n# List maps in seasonal time series\nt.rast.list input=LST_Day_mean_3month\n```\n:::\n\n\nExtraer LST promedio de verano para el Gran Córdoba\n\n::: {.cell execution_count=59}\n``` {.python .cell-code}\n# Extract summer average LST for Cba urban area\nv.strds.stats input=area_edificada_cba \\\n  strds=LST_Day_mean_3month \\\n  where=\"fna == 'Gran Córdoba'\" \\\n  t_where=\"strftime('%m', start_time)='01'\" \\\n  output=cba_summer_lst \\\n  method=average\n```\n:::\n\n\nCrear buffer externo - 30 km\n\n::: {.cell execution_count=60}\n``` {.python .cell-code}\n# Create outside buffer - 30 km\nv.buffer input=cba_summer_lst \\\n  distance=30000 \\\n  output=cba_summer_lst_buf30\n```\n:::\n\n\nCrear buffer interno - 15 km\n\n::: {.cell execution_count=61}\n``` {.python .cell-code}\n# Create inside buffer - 15 km\nv.buffer input=cba_summer_lst \\\n  distance=15000 \\\n  output=cba_summer_lst_buf15\n```\n:::\n\n\nRemover el área del buffer 15 km del buffer de 30 km\n\n::: {.cell execution_count=62}\n``` {.python .cell-code}\n# Remove 15km buffer area from the 30km buffer area\nv.overlay ainput=cba_summer_lst_buf15 \\\n  binput=cba_summer_lst_buf30 \\\n  operator=xor \\\n  output=cba_surr\n```\n:::\n\n\n![](../assets/img/suhi_buffers.png)\n\nLímites del Gran Córdoba y el área rural circundante\n\n\nExtraer estadísticas para los alrededores del Gran Córdoba\n\n::: {.cell execution_count=63}\n``` {.python .cell-code}\n# Extract zonal stats for Cba surroundings\nv.strds.stats input=cba_surr \\\n  strds=LST_Day_mean_3month \\\n  t_where=\"strftime('%m', start_time)='01'\" \\\n  method=average \\\n  output=cba_surr_summer_lst\n```\n:::\n\n\nChequear la LST estival promedio para el Gran Córdoba y alrededores\n\n::: {.cell execution_count=64}\n``` {.python .cell-code}\n# Take a look at mean summer LST in Cba and surroundings\nv.db.select cba_summer_lst\nv.db.select cba_surr_summer_lst\n```\n:::\n\n\n<!-- ### GRASS y R para hacer mapas -->\n\n<!-- Vamos a usar **R** y **RStudio** para crear mapas con los vectores resultantes -->\n\n\n<!-- En la terminal de GRASS GIS: `rstudio &` -->\n\n\n<!-- Mapas en R con datos de GRASS GIS -->\n\n<!-- Cargar las librerías *rgrass7* y *sf* -->\n<!-- ```{r} -->\n<!-- # Load rgrass and sf libraries -->\n<!-- library(rgrass) -->\n<!-- library(sf) -->\n<!-- ``` -->\n\n<!-- Listar los vectores disponibles en el mapset -->\n<!-- ```{r} -->\n<!-- # List available vectors -->\n<!-- execGRASS(\"g.list\", parameters = list(type=\"vector\", mapset=\".\")) -->\n<!-- ``` -->\n\n<!-- Leer e importar los mapas vectoriales desde GRASS GIS -->\n<!-- ```{r} -->\n<!-- # Read in GRASS vector maps as sf -->\n<!-- cba_summer_lst <- read_VECT(\"cba_summer_lst\") -->\n<!-- cba_surr_summer_lst <- read_VECT(\"cba_surr_summer_lst\") -->\n<!-- ``` -->\n\n<!-- Remover columnas extra -->\n<!-- ```{r} -->\n<!-- # Remove columns we don't need -->\n<!-- cba_summer_lst <- cba_summer_lst[,-c(2:9)] -->\n<!-- cba_surr_summer_lst <- cba_surr_summer_lst[,-c(2:3)] -->\n<!-- ``` -->\n\n<!-- Pegar los dos vectores -->\n<!-- ```{r} -->\n<!-- # Paste the 2 vectors together -->\n<!-- cba <- rbind(cba_summer_lst,cba_surr_summer_lst) -->\n<!-- ``` -->\n\n<!-- Gráfico rápido con *sf* -->\n<!-- ```{r} -->\n<!-- # Quick sf plot -->\n<!-- plot(cba[c(2:6)], border = 'grey', axes = TRUE, key.pos = 4) -->\n<!-- ``` -->\n\n<!-- ![](../assets/img/sf_plot.png) -->\n\n<!-- Usando la librería *ggplot* -->\n<!-- ```{r} -->\n<!-- # Let's try with ggplot library -->\n<!-- library(ggplot2) -->\n<!-- library(dplyr) -->\n<!-- library(tidyr) -->\n<!-- ``` -->\n\n<!-- Arreglar los datos desde formato *wide* a *long* -->\n<!-- ```{r} -->\n<!-- # Arrange data from wide to long format -->\n<!-- cba2 <- -->\n<!--   cba %>% -->\n<!--   select(LST_Day_mean_3month_2015_01_01_average, -->\n<!--          LST_Day_mean_3month_2016_01_01_average, -->\n<!--          LST_Day_mean_3month_2017_01_01_average, -->\n<!--          LST_Day_mean_3month_2018_01_01_average, -->\n<!--          LST_Day_mean_3month_2019_01_01_average, -->\n<!--          geom) %>% -->\n<!--   gather(YEAR, LST_summer, -geom) -->\n<!-- ``` -->\n\n<!-- Reemplazar valores en la columna *YEAR* -->\n<!-- ```{r} -->\n<!-- # Replace values in YEAR column -->\n<!-- cba2$YEAR <- rep(c(2015:2019),2) -->\n<!-- ``` -->\n\n<!-- Graficar -->\n<!-- ```{r} -->\n<!-- # Plot -->\n<!-- ggplot() + -->\n<!--   geom_sf(data = cba2, aes(fill = LST_summer)) + -->\n<!--   facet_wrap(~YEAR, ncol = 3) + -->\n<!--   scale_fill_distiller(palette = \"YlOrRd\", -->\n<!--                        direction = 1) + -->\n<!--   scale_y_continuous() -->\n<!-- ``` -->\n\n\n<!-- ![](../assets/img/ggplot.png) -->\n\n<!-- Usando la librería *tmap* -->\n<!-- ```{r} -->\n<!-- # Let's try also with tmap -->\n<!-- library(tmap) -->\n<!-- ``` -->\n\n<!-- Graficar -->\n<!-- ```{r} -->\n<!-- # Plot -->\n<!-- tm_shape(cba2) + -->\n<!--   tm_polygons(col = \"LST_summer\", style = \"cont\") + -->\n<!--   tm_facets(by = \"YEAR\", nrow = 1, free.coords = FALSE) -->\n<!-- ``` -->\n\n<!-- ![](../assets/img/tmap.png) -->\n\n<!-- Visualización rápida e interactiva con *mapview* -->\n<!-- ```{r} -->\n<!-- # mapview for quick visualizations with basemaps is really cool! -->\n<!-- library(mapview) -->\n<!-- mapview(cba) -->\n<!-- ``` -->\n\n\n<!-- ![](../assets/img/mapview1.png) -->\n<!-- ![](../assets/img/mapview2.png) -->\n\n<!-- Visualización con *mapview* y diferentes mapa base -->\n\n\n## Recursos (muy) útiles \n\n- [Temporal data processing wiki](https://grasswiki.osgeo.org/wiki/Temporal_data_processing)\n- [GRASS GIS and R for time series processing wiki](https://grasswiki.osgeo.org/wiki/Temporal_data_processing/GRASS_R_raster_time_series_processing)\n- [GRASS GIS temporal workshop at NCSU](http://ncsu-geoforall-lab.github.io/grass-temporal-workshop/)\n- [GRASS GIS workshop held in Jena 2018](http://training.gismentors.eu/grass-gis-workshop-jena-2018/index.html)\n- [GRASS GIS course IRSAE 2018](http://training.gismentors.eu/grass-gis-irsae-winter-course-2018/index.html)\n- [Space-time satellite data for disease ecology - OpenGeoHub Summer School 2019](https://www.youtube.com/watch?v=nu_ZFvmAFGw)\n\n## Referencias\n\n- Gebbert, S., Pebesma, E. (2014) *A temporal GIS for field based environmental modeling*. Environmental Modelling & Software, 53, 1-12. [DOI](https://doi.org/10.1016/j.envsoft.2013.11.001)\n- Gebbert, S., Pebesma, E. (2017) *The GRASS GIS temporal framework*. IJGIS 31, 1273-1292. [DOI](http://dx.doi.org/10.1080/13658816.2017.1306862)\n- Gebbert, S., Leppelt, T., Pebesma, E. (2019) *A Topology Based Spatio-Temporal Map Algebra for Big Data Analysis*. Data, 4, 86. [DOI](https://doi.org/10.3390/data4020086)\n\n",
    "supporting": [
      "intro_temporal_files"
    ],
    "filters": [],
    "includes": {}
  }
}