{
  "hash": "74a1b6ff7c880ecf1154c06274bf91b5",
  "result": {
    "markdown": "---\ntitle: Intro a series de tiempo\nauthor: Verónica Andreo\ndate: today\nformat:\n  html:\n    code-tools: true\n    code-copy: true\n    code-fold: false\nexecute:\n  eval: false\n  cache: false\n  keep-ipynb: true\n---\n\n# TGRASS: GRASS Temporal\n\n**GRASS GIS** es **el primer SIG de código abierto** que incorporó capacidades \npara **gestionar, analizar, procesar y visualizar datos espacio-temporales**,\nasí como las relaciones temporales entre series de tiempo.\n\n- Completamente [basado en metadatos]{style=\"color: #18bc9c;\"}, por lo que no \nhay duplicación de datos\n- Sigue una aproximación [*Snapshot*]{style=\"color: #18bc9c;\"}, i.e., añade \nmarcas de tiempo o *timestamps* a los mapas\n- Una colección de mapas de la misma variable con timestamps se llama \n[space-time dataset o STDS]{style=\"color: #18bc9c;\"}\n- Los mapas en una STDS pueden tener diferentes extensiones espaciales y \ntemporales\n- TGRASS utiliza una base de datos [SQLite](https://www.sqlite.org/index.html) \npara almacenar la extensión temporal y espacial de las STDS, así como las \nrelaciones topológicas entre los mapas y entre las STDS en cada mapset.\n\nTGRASS o GRASS GIS temporal framework fue desarrollado por Sören Gebbert como\nparte de un proyecto Google Summer of Code en 2012. Detalles técnicos de la \nimplementación pueden encontrarse en: @gebbert_temporal_2014, \n@gebbert_grass_2017 y @gebbert_topology_2019.\n\n## Space-time datasets\n\n- Space time raster datasets ([**STRDS**]{style=\"color: #18bc9c;\"})\n- Space time 3D raster datasets ([**STR3DS**]{style=\"color: #18bc9c;\"})\n- Space time vector datasets ([**STVDS**]{style=\"color: #18bc9c;\"})\n\n## Otras nociones básicas en TGRASS\n\n- El tiempo puede definirse como **intervalos** (inicio y fin) o como \n**instancias** (sólo inicio)\n- El tiempo puede ser **absoluto** (por ejemplo, 2017-04-06 22:39:49) o \n**relativo** (por ejemplo, 4 años, 90 días)\n- *Granularidad* es el mayor divisor común de todas las extensiones temporales\n(y posibles gaps) de los mapas de un STDS\n\n![Series de diferente granularidad y tipo de tiempo](https://grass.osgeo.org/grass-stable/manuals/timeline_2D.jpg){width=\"50%\" fig-align=\"center\"}\n\n- *Topología* se refiere a las relaciones temporales entre los intervalos de \ntiempo en una STDS\n\n![Relaciones topológicas entre STDS y entre mapas](../assets/img/temp_relation.png){width=70%}\n\n- *Muestreo temporal* se utiliza para determinar el estado de un proceso respecto \nun segundo proceso.\n\n![Muestreo temporal](../assets/img/temp_samplings.png){width=55%}\n\n## Módulos temporales\n\n- **t.\\***: Módulos generales para manejar STDS de todos los tipos\n- **t.rast.\\***: Módulos que tratan con STRDS\n- **t.rast3d.\\***: Módulos que tratan con STR3DS\n- **t.vect.\\***: Módulos que tratan con STVDS\n\n\n## TGRASS: marco general y flujo de trabajo\n\n![](../assets/img/tgrass_flowchart.png){width=80%}\n\n# Manos a la obra\n\nEn esta segunda parte de la sesión vamos a recorrer los módulos temporales de\nGRASS GIS y demostrar su funcionalidad por medio de una serie de datos de \ntemperatura de superficie (LST) de MODIS.\n\nAntes de empezar y para ganar tiempo, conectamos nuestro drive e instalamos \nGRASS en Google Colab.\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\n# import drive from google colab\nfrom google.colab import drive\n# mount drive\ndrive.mount(\"/content/drive\")\n```\n:::\n\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\n%%bash\nDEBIAN_FRONTEND=noninteractive \nsudo add-apt-repository ppa:ubuntugis/ubuntugis-unstable \napt update \napt install grass subversion grass-dev\napt remove libproj22\n```\n:::\n\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\n!grass --config path\n```\n:::\n\n\n### Datos para la sesión\n\n- Producto MODIS: <a href=\"https://lpdaac.usgs.gov/products/mod11b3v006/\">MOD11B3 Collection 6</a>\n- Tile: h12v12\n- Composiciones mensuales \n- Resolución espacial: 5600m\n- Mapset *`modis_lst`* \n\n\n![Tile h12v12 del producto MOD11B3](../assets/img/mod11b3_h12v12.png){width=85%}\n\n### Iniciamos GRASS\n\nDefinimos las rutas y el mapset *`modis_lst`*\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nimport os\n\n# data directory\nhomedir = \"/content/drive/MyDrive/curso_grass_2023\"\n\n# change to homedir so output files will be saved there\nos.chdir(homedir)\n\n# GRASS GIS database variables\ngrassdata = os.path.join(homedir, \"grassdata\")\nproject = \"posgar2007_4_cba\"\nmapset = \"modis_lst\"\n```\n:::\n\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\n# import standard Python packages we need\nimport sys\nimport subprocess\n\n# ask GRASS GIS where its Python packages are to be able to run it from the notebook\nsys.path.append(\n    subprocess.check_output([\"grass\", \"--config\", \"python_path\"], text=True).strip()\n)\n```\n:::\n\n\nImportamos los paquetes de GRASS e iniciamos una sesión:\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\n# import the GRASS GIS packages we need\nimport grass.script as gs\nimport grass.jupyter as gj\n\n# Start the GRASS GIS Session\nsession = gj.init(grassdata, project, mapset)\n```\n:::\n\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\n# show current GRASS GIS settings, this also checks if the session works\ngs.gisenv()\n```\n:::\n\n\n### Región computacional y máscara\n\nListar los mapas raster y obtener información de uno de ellos\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\n# get list of raster maps in the 'modis_lst' mapset\nlista_mapas = gs.list_grouped(type=\"raster\")[\"modis_lst\"]\nlista_mapas[:8]\n```\n:::\n\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\n# Get info from one of the raster maps\ngs.raster_info(map=\"MOD11B3.A2015001.h12v12.single_LST_Day_6km\")\n```\n:::\n\n\nVamos a agregar el *semantic label* a cada mapa de LST\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\n# list only LST maps\nlista_lst = gs.list_grouped(type=\"raster\",\n                            pattern=\"*LST_Day*\")[\"modis_lst\"]\n```\n:::\n\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\n# set semantic labels\nfor i in lista_lst:\n    gs.run_command(\"r.support\",\n                   map=i,\n                   semantic_label=\"LST\")\n```\n:::\n\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\n# Get info from one of the raster maps\ngs.raster_info(map=\"MOD11B3.A2015001.h12v12.single_LST_Day_6km\")[\"semantic_label\"]\n```\n:::\n\n\nEstablecemos la región computacional\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\n# set region to Cba boundaries with LST maps' resolution\nprint(gs.read_command(\"g.region\", \n                      vector=\"provincia_cba\",\n                      align=\"MOD11B3.A2015001.h12v12.single_LST_Day_6km\",\n                      flags=\"p\"))\n```\n:::\n\n\nAplicamos la máscara con los límites de la provincia de Córdoba\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\n# set a MASK to Cba boundary\ngs.run_command(\"r.mask\",\n               vector=\"provincia_cba\")\n```\n:::\n\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\n# plot\ncba_map=gj.InteractiveMap(width = 500, tiles=\"OpenStreetMap\")\ncba_map.add_raster(\"MOD11B3.A2015001.h12v12.single_LST_Day_6km\")\ncba_map.add_vector(\"provincia_cba\")\ncba_map.add_layer_control(position = \"bottomright\")\ncba_map.show()\n```\n:::\n\n\n### Crear un conjunto de datos espacio-temporales (STDS)\n\n**[t.create](https://grass.osgeo.org/grass-stable/manuals/t.create.html)**\n\n- Crea una tabla SQLite en la base de datos temporal \n- Permite manejar grandes cantidades de mapas usando el STDS como entrada\n- Necesitamos especificar:\n  - *tipo de mapas* (raster, raster3d o vector)\n  - *tipo de tiempo* (absoluto o relativo)\n\nCreamos la STRDS\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\n# Create the STRDS\ngs.run_command(\"t.create\",\n               type=\"strds\",\n               temporaltype=\"absolute\",\n               output=\"LST_Day_monthly\",\n               title=\"Monthly LST Day 5.6 km\",\n               description=\"Monthly LST Day 5.6 km MOD11B3.006 Cordoba, 2015-2019\")\n```\n:::\n\n\nChequear si la STRDS fue creada\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\n# Check if the STRDS is created\ngs.read_command(\"t.list\",\n                type=\"strds\")\n```\n:::\n\n\nObtener información sobre la STRDS\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\n# Get info about the STRDS\nprint(gs.read_command(\"t.info\", \n                input=\"LST_Day_monthly\"))\n```\n:::\n\n\n### Registrar mapas en una STDS (asignar *timestamps*)\n\n**[t.register](https://grass.osgeo.org/grass-stable/manuals/t.register.html)**\n\n- Asigna o agrega timestamps a los mapas\n- Necesitamos: \n  - el *STDS vacío* como entrada, i.e., la tabla SQLite contenedora, \n  - la *lista de mapas* que se registrarán, \n  - la *fecha de inicio*,\n  - la opción de *incremento* junto con *-i* para la creación de intervalos \n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\n# Add time stamps to maps (i.e., register maps)\ngs.run_command(\"t.register\",\n               input=\"LST_Day_monthly\",\n               maps=lista_lst,\n               start=\"2015-01-01\",\n               increment=\"1 months\",\n               flags=\"i\")\n```\n:::\n\n\nChequear la información sobre la STRDS nuevamente\n\n::: {.cell execution_count=20}\n``` {.python .cell-code}\n# Check info again\nprint(gs.read_command(\"t.info\", \n                input=\"LST_Day_monthly\"))\n```\n:::\n\n\nRevisamos la lista de mapas en la STRDS\n\n::: {.cell execution_count=21}\n``` {.python .cell-code}\n# Check the list of maps in the STRDS\nprint(gs.read_command(\"t.rast.list\", \n                      input=\"LST_Day_monthly\"))\n```\n:::\n\n\nChequeamos los valores mínimos y máximos de cada mapa\n\n::: {.cell execution_count=22}\n``` {.python .cell-code}\n# Check min and max per map\nprint(gs.read_command(\"t.rast.list\",\n                      input=\"LST_Day_monthly\",\n                      columns=\"name,min,max\"))\n```\n:::\n\n\n:::{.callout-note}\nPara más opciones sobre cómo registrar mapas, ver el manual de \n[t.register](https://grass.osgeo.org/grass-stable/manuals/t.register.html) \ny la wiki sobre \n[opciones para registrar mapas en STDS](https://grasswiki.osgeo.org/wiki/Temporal_data_processing/maps_registration).\n:::\n\n### Representación gráfica de STDS\n\nCrear una representación gráfica de la serie de tiempo\n\n::: {.cell execution_count=23}\n``` {.python .cell-code}\n!g.gui.timeline inputs=LST_Day_monthly\n```\n:::\n\n\n![](../assets/img/g_gui_timeline_monthly.png){width=60%}\n\n:::{.callout-note}\nVer el manual de <a href=\"https://grass.osgeo.org/grass-stable/manuals/g.gui.timeline.html\">g.gui.timeline</a> para más detalles.\n:::\n\n### Operaciones con álgebra temporal\n\n**[t.rast.algebra](https://grass.osgeo.org/grass-stable/manuals/t.rast.algebra.html)**\n\n- Realiza una amplia gama de operaciones de álgebra temporal y espacial basadas \nen la topología temporal de los mapas\n  - Operadores temporales: unión, intersección, etc.\n  - Funciones temporales: *start_time()*, *start_doy()*, etc.\n  - Operadores espaciales (subconjunto de [r.mapcalc](https://grass.osgeo.org/grass-stable/manuals/r.mapcalc.html))\n  - Modificador de vecindario temporal: *[x,y,t]*\n  - Otras funciones temporales como *t_snap()*, *buff_t()* o *t_shift()*\n\n**¡pueden combinarse en expresiones complejas!**\n\n\n#### Desde K*50 a Celsius usando la calculadora temporal\n\nRe-escalar a grados Celsius\n\n::: {.cell execution_count=24}\n``` {.python .cell-code}\n# Re-scale data to degrees Celsius\nexpression=\"LST_Day_monthly_celsius = LST_Day_monthly * 0.02 - 273.15\"\n\ngs.run_command(\"t.rast.algebra\",\n               basename=\"LST_Day_monthly_celsius\",\n               suffix=\"gran\",\n               expression=expression)\n```\n:::\n\n\nVer info de la nueva serie de tiempo\n\n::: {.cell execution_count=25}\n``` {.python .cell-code}\n# Check info\nprint(gs.read_command(\"t.info\", \n                      input=\"LST_Day_monthly_celsius\"))\n```\n:::\n\n\n### Gráfico temporal: LST vs tiempo\n\nGráfico temporal de LST para la ciudad de Córdoba, Argentina\n\n::: {.cell execution_count=26}\n``` {.python .cell-code}\n# LST time series plot for Cba city center\n!g.gui.tplot strds=LST_Day_monthly_celsius coordinates=4323478.531282977,6541664.09350761 title=\"Monthly LST. City center of Cordoba\" xlabel=\"Time\" ylabel=\"LST\"\n```\n:::\n\n\n![Salida de g.gui.tplot](../assets/img/g_gui_tplot_final.png){width=60%}\n\nEn la interfaz de `g.gui.tplot`, las coordenadas del punto pueden ser escritas\ndirectamente, copiadas desde el mapa o seleccionadas interactivamente en el\n*map display*.\n\n:::{.callout-note}\nPara un único punto, ver <a href=\"https://grass.osgeo.org/grass-stable/manuals/g.gui.tplot.html\">g.gui.tplot</a>. Para un vector de puntos, ver <a href=\"https://grass.osgeo.org/grass-stable/manuals/t.rast.what.html\">t.rast.what</a>.\n:::\n\n### Listas y selecciones\n\n- **[t.list](https://grass.osgeo.org/grass-stable/manuals/t.list.html)** para listar las STDS y los mapas registrados en la base de datos temporal,\n- **[t.rast.list](https://grass.osgeo.org/grass-stable/manuals/t.rast.list.html)** para mapas en series temporales de rasters, y\n- **[t.vect.list](https://grass.osgeo.org/grass-stable/manuals/t.vect.list.html)** para mapas en series temporales de vectores.\n\n#### Variables usadas para hacer las listas y selecciones\n\n:::{style=\"background-color: rgba(200, 230, 255, 0.75);\"}\n**STRDS:** *id, name, creator, mapset, temporal_type, creation_time, start_time, end_time, north, south, west, east, nsres, ewres, cols, rows, number_of_cells, min, max*\n:::\n\n:::{style=\"background-color: rgba(200, 230, 255, 0.75);\"}\n**STVDS:** *id, name, layer, creator, mapset, temporal_type, creation_time, start_time, end_time, north, south, west, east, points, lines, boundaries, centroids, faces, kernels, primitives, nodes, areas, islands, holes, volumes*\n:::\n\n#### Ejemplos de listas y selecciones\n\nMapas cuyo valor mínimo es menor o igual a 10\n\n::: {.cell execution_count=27}\n``` {.python .cell-code}\n# Maps with minimum value lower than or equal to 10\nprint(gs.read_command(\"t.rast.list\",\n                      input=\"LST_Day_monthly_celsius\",\n                      order=\"min\", \n                      columns=\"name,start_time,min\",\n                      where=\"min <= '10.0'\"))\n```\n:::\n\n\nMapas cuyo valor máximo es mayor a 30\n\n::: {.cell execution_count=28}\n``` {.python .cell-code}\n# Maps with maximum value higher than 30\nprint(gs.read_command(\"t.rast.list\",\n                      input=\"LST_Day_monthly_celsius\",\n                      order=\"max\",\n                      columns=\"name,start_time,max\",\n                      where=\"max > '30.0'\"))\n```\n:::\n\n\nMapas contenidos entre dos fechas\n\n::: {.cell execution_count=29}\n``` {.python .cell-code}\n# Maps between two given dates\nprint(gs.read_command(\"t.rast.list\",\n                      input=\"LST_Day_monthly_celsius\",\n                      columns=\"name,start_time\",\n                      where=\"start_time >= '2015-05' and start_time <= '2015-08-01 00:00:00'\"))\n```\n:::\n\n\nTodos los mapas correspondientes al mes de Enero\n\n::: {.cell execution_count=30}\n``` {.python .cell-code}\n# Maps from January\nprint(gs.read_command(\"t.rast.list\",\n                      input=\"LST_Day_monthly_celsius\",\n                      columns=\"name,start_time\",\n                      where=\"strftime('%m', start_time)='01'\"))\n```\n:::\n\n\n### Estadística descriptiva de STRDS\n\nImprimir estadísticas descriptivas univariadas para cada mapa dentro de la STRDS\n\n::: {.cell execution_count=31}\n``` {.python .cell-code}\n# Print univariate stats for maps within STRDS\nprint(gs.read_command(\"t.rast.univar\",\n                      input=\"LST_Day_monthly_celsius\"))\n```\n:::\n\n\nObtener estadísticas extendidas con la opción -e y escribir la salida a un\narchivo de texto\n\n::: {.cell execution_count=32}\n``` {.python .cell-code}\n# Write extended univariate stats output to a csv file\ngs.run_command(\"t.rast.univar\",\n                flags=\"e\",\n                input=\"LST_Day_monthly_celsius\",\n                output=os.path.join(homedir,\"ext_stats_LST_Day_monthly_celsius.csv\"),\n                separator=\"comma\")\n```\n:::\n\n\nGraficamos las series del promedio, mínimo y máximo por mapa:\n\n::: {.cell execution_count=33}\n``` {.python .cell-code}\n# Read the csv and plot\nimport pandas as pd\n\nlst = pd.read_csv(os.path.join(homedir,\"ext_stats_LST_Day_monthly_celsius.csv\"))\nlst['start'] = pd.to_datetime(lst.start, format=\"%Y-%m-%d\", exact=False)\nlst.plot.line(1, [3,4,5], subplots=False)\n```\n:::\n\n\n### Agregación temporal 1: Serie completa\n\n**[t.rast.series](https://grass.osgeo.org/grass-stable/manuals/t.rast.series.html)**\n\n- Agrega STRDS *completas* o partes de ellas usando la opción *where*.\n- Diferentes métodos disponibles: promedio, mínimo, máximo, mediana, moda, etc.\n\n\n#### LST máxima y mínima del período 2015-2019\n\nObtener los mapas de la máxima y mínima LST del período\n\n::: {.cell execution_count=34}\n``` {.python .cell-code}\n# Get maximum and minimum LST in the STRDS\nmethods=[\"maximum\",\"minimum\"]\n\nfor m in methods:\n    gs.run_command(\"t.rast.series\",\n                   input=\"LST_Day_monthly_celsius\",\n                   output=f\"LST_Day_{m}\",\n                   method=m)\n```\n:::\n\n\nCambiar la paleta de colores a *celsius*\n\n::: {.cell execution_count=35}\n``` {.python .cell-code}\n# Change color pallete to celsius\ngs.run_command(\"r.colors\",\n               map=\"LST_Day_minimum,LST_Day_maximum\",\n               color=\"celsius\")\n```\n:::\n\n\nGraficamos los mapas obtenidos\n\n::: {.cell execution_count=36}\n``` {.python .cell-code}\n# Plot\ncba_map=gj.InteractiveMap(width = 500, tiles=\"OpenStreetMap\")\ncba_map.add_raster(\"LST_Day_minimum\")\ncba_map.add_raster(\"LST_Day_maximum\")\ncba_map.add_vector(\"provincia_cba\")\ncba_map.add_layer_control(position = \"bottomright\")\ncba_map.show()\n```\n:::\n\n\nUsamos la calculadora de mapas temporal, `t.rast.mapcalc`,para obtener el \nmes de la LST mínima\n\n::: {.cell execution_count=37}\n``` {.python .cell-code}\n# Get month of maximum LST\nexpression=\"if(LST_Day_monthly_celsius == LST_Day_minimum, start_month(), null())\"\n\ngs.run_command(\"t.rast.mapcalc\",\n               flags=\"n\",\n               inputs=\"LST_Day_monthly_celsius\",\n               output=\"month_min_lst\",\n               expression=expression,\n               basename=\"month_min_lst\")\n```\n:::\n\n\nObtener información del mapa resultante\n\n::: {.cell execution_count=38}\n``` {.python .cell-code}\n# Get basic info\nprint(gs.read_command(\"t.info\", \n                      input=\"month_min_lst\"))\n```\n:::\n\n\nObtenemos el primer mes en que aparece el mínimo de LST\n\n::: {.cell execution_count=39}\n``` {.python .cell-code}\n# Get the earliest month in which the maximum appeared (method minimum)\ngs.run_command(\"t.rast.series\",\n               input=\"month_min_lst\",\n               method=\"minimum\",\n               output=\"min_lst_date\")\n```\n:::\n\n\nRemover la STRDS intermedia y los mapas que contiene:\n\n::: {.cell execution_count=40}\n``` {.python .cell-code}\n# Remove month_min_lst strds \n# we were only interested in the resulting aggregated map\ngs.run_command(\"t.remove\",\n               flags=\"rfd\",\n               inputs=\"month_min_lst\")\n```\n:::\n\n\nChequeamos que la serie fue removida\n\n::: {.cell execution_count=41}\n``` {.python .cell-code}\n# check STRDS in our mapset\nprint(gs.read_command(\"t.list\"))\n```\n:::\n\n\nMostrar el mapa resultante con la clase `Map` de `grass.jupyter`\n\n::: {.cell execution_count=42}\n``` {.python .cell-code}\n# display results\nmm = gj.Map(width=450, use_region=True)\nmm.d_rast(map=\"min_lst_date\")\nmm.d_vect(map=\"provincia_cba\", type=\"boundary\", color=\"#4D4D4D\", width=2)\nmm.d_legend(raster=\"min_lst_date\", title=\"Month\", fontsize=10, at=(2,15,2,10))\nmm.d_barscale(length=50, units=\"kilometers\", segment=4, fontsize=14, at=(73,7))\nmm.d_northarrow(at=(90,15))\nmm.d_text(text=\"Month of minimum LST\", color=\"black\", font=\"sans\", size=4, bgcolor=\"white\")\nmm.show()\n```\n:::\n\n\n:::{.callout-caution title=\"Tarea\"}\nPodríamos haber hecho lo mismo pero anualmente para conocer en qué mes ocurre el máximo en cada año y así evaluar la ocurrencia de tendencias. Cómo lo harían?\n:::\n\n### Agregación temporal 2: granularidad\n\n**[t.rast.aggregate](https://grass.osgeo.org/grass-stable/manuals/t.rast.aggregate.html)**\n\n- Agrega mapas raster dentro de STRDS con diferentes **granularidades** \n- La opción *where* permite establecer fechas específicas para la agregación\n- Diferentes métodos disponibles: promedio, mínimo, máximo, mediana, moda, etc.\n\n#### De LST mensual a estacional\n\nLST media estacional\n\n::: {.cell execution_count=43}\n``` {.python .cell-code}\n# 3-month mean LST\ngs.run_command(\"t.rast.aggregate\",\n               input=\"LST_Day_monthly_celsius\",\n               output=\"LST_Day_mean_3month\",\n               basename=\"LST_Day_mean_3month\",\n               suffix=\"gran\",\n               method=\"average\",\n               granularity=\"3 months\")\n```\n:::\n\n\nChequear info\n\n::: {.cell execution_count=44}\n``` {.python .cell-code}\n# Check info\nprint(gs.read_command(\"t.info\",\n                      input=\"LST_Day_mean_3month\"))\n```\n:::\n\n\nChequear lista de mapas\n\n::: {.cell execution_count=45}\n``` {.python .cell-code}\n# Check map list\nprint(gs.read_command(\"t.rast.list\",\n                      input=\"LST_Day_mean_3month\"))\n```\n:::\n\n\nEstablecer la paleta de colores *celsius* para la STRDS estacional\n\n::: {.cell execution_count=46}\n``` {.python .cell-code}\n# Set STRDS color table to celsius degrees\ngs.run_command(\"t.rast.colors\",\n               input=\"LST_Day_mean_3month\",\n               color=\"celsius\")\n```\n:::\n\n\nMostramos la serie recientemente creada con una animación. Para eso vamos\na usar la clase `TimeSeriesMap` de `grass.jupyter`\n\n::: {.cell execution_count=47}\n``` {.python .cell-code}\n## Display newly created NDVI time series map\nlstseries = gj.TimeSeriesMap(use_region=True)\nlstseries.add_raster_series(\"LST_Day_mean_3month\", fill_gaps=False)\nlstseries.d_legend(color=\"black\", at=(10,40,2,6))\nlstseries.show()  # Create TimeSlider\n\n# optionally, write out to animated GIF\nlstseries.save(\"lstseries.gif\")\n```\n:::\n\n\n:::{.callout-warning title=\"Tarea\"}\nAhora que ya conocen\n[t.rast.aggregate](https://grass.osgeo.org/grass-stable/manuals/t.rast.aggregate.html), \nextraigan el mes de máximo LST por año y luego vean si hay alguna tendencia\npositiva o negativa, es decir, si los valores máximos de LST se observan más \ntarde o más temprano con el tiempo (años).\n\nUna solución podría ser...\n\n::: {.cell execution_count=48}\n``` {.python .cell-code}\ngs.run_command(\"t.rast.aggregate\",\n               input=\"LST_Day_monthly_celsius\", \n               output=\"month_max_LST_per_year\",   \n               basename=\"month_max_LST\", \n               suffix=\"gran\", \n               method=\"max_raster\", \n               granularity=\"1 year\")\n\ngs.run_command(\"t.rast.series\", \n               input=\"month_max_LST_per_year\", \n               output=\"slope_month_max_LST\", \n               method=\"slope\")\n```\n:::\n\n\n:::\n\n### Agregación vs Climatología\n\n:::: columns\n:::{.column width=\"50%\"}\n![Agregación por granularidad](../assets/img/aggregation.png)\n:::\n\n:::{.column width=\"50%\"}\n![Agregación tipo climatología](../assets/img/climatology.png)\n:::\n::::\n\n#### Climatologías mensuales\n\nLST promedio de Enero\n\n::: {.cell execution_count=49}\n``` {.python .cell-code}\n# January average LST\ngs.run_command(\"t.rast.series\",\n               input=\"LST_Day_monthly_celsius\",\n               method=\"average\",\n               where=\"strftime('%m', start_time)='01'\",\n               output=\"LST_average_jan\")\n```\n:::\n\n\nClimatología para todos los meses\n\n::: {.cell execution_count=50}\n``` {.python .cell-code}\n# for all months\nmonths=['{0:02d}'.format(m) for m in range(1,13)]\nmethods=[\"average\"]\n\nfor m in months:\n    for me in methods:\n        gs.run_command(\"t.rast.series\", \n                       input=\"LST_Day_monthly_celsius\",\n                       method=me,\n                       where=f\"strftime('%m', start_time)='{m}'\",\n                       output=f\"LST_{me}_{m}\")\n```\n:::\n\n\n:::{.callout-warning title=\"Tarea\"}\n- Comparar las medias mensuales con las climatologías mensuales\n- Las climatologías que creamos forman una STRDS?\n:::\n\n\n### Anomalías anuales\n\nSe necesitan:\n\n- promedio y desviación estándar general de la serie\n- promedios anuales\n\n$$\nAnomaliaStd_i = \\frac{Media_i - Media}{SD}\n$$\n\nObtenemos primero el promedio y el desvío estándar general de la serie\n\n::: {.cell execution_count=51}\n``` {.python .cell-code}\n# Get general average and SD\nmethods=[\"average\",\"stddev\"]\n\nfor me in methods:\n    gs.run_command(\"t.rast.series\",\n                   input=\"LST_Day_monthly_celsius\",\n                   method=me,\n                   output=f\"LST_Day_{me}\")\n```\n:::\n\n\ny luego los promedios anuales\n\n::: {.cell execution_count=52}\n``` {.python .cell-code}\n# Get annual averages\ngs.run_command(\"t.rast.aggregate\",\n               input=\"LST_Day_monthly_celsius\",\n               method=\"average\",\n               granularity=\"1 years\",\n               output=\"LST_yearly_average\",\n               basename=\"LST_yearly_average\")\n```\n:::\n\n\nUtilizamos el álgebra temporal para estimar las anomalías anuales\n\n::: {.cell execution_count=53}\n``` {.python .cell-code}\n# Estimate annual anomalies\nexpression=\"LST_year_anomaly = (LST_yearly_average - map(LST_Day_average)) / map(LST_Day_stddev)\"\n\ngs.run_command(\"t.rast.algebra\",\n               basename=\"LST_year_anomaly\",\n               expression=expression)\n```\n:::\n\n\nEstablecer la paleta de colores *differences* para toda la serie \n(esto permite tomar el minimo y maximo general de la serie)\n\n::: {.cell execution_count=54}\n``` {.python .cell-code}\n# Set difference color table\ngs.run_command(\"t.rast.colors\",\n               input=\"LST_year_anomaly\",\n               color=\"difference\")\n```\n:::\n\n\nMostramos los resultados con una animación\n\n::: {.cell execution_count=55}\n``` {.python .cell-code}\n# Animation of annual anomalies\nanomalies = gj.TimeSeriesMap(use_region=True)\nanomalies.add_raster_series(\"LST_year_anomaly\", fill_gaps=False)\nanomalies.d_legend(color=\"black\", at=(10,40,2,6))\nanomalies.show()\n```\n:::\n\n\n### Isla de calor superficial urbana (Surface Urban Heat Island - SUHI)\n\n- La temperatura del aire de una zona urbana es más alta que la de las zonas cercanas\n- La UHI tiene efectos negativos en la calidad del agua y el aire, la biodiversidad, la salud humana y el clima.\n- La SUHI también está muy relacionada con la salud, ya que influye en la UHI \n\n![SUHI y área rural en Buenos Aires (<a href=\"https://www.mdpi.com/2072-4292/11/10/1212/htm\">Wu et al, 2019.</a>)\n](https://res.mdpi.com/remotesensing/remotesensing-11-01212/article_deploy/html/images/remotesensing-11-01212-g002-550.jpg){width=60%}\n\n\n### Estadística zonal en series de tiempo de datos raster\n\n**[v.strds.stats](https://grass.osgeo.org/grass7/manuals/addons/v.strds.stats.html)**\n\n- Permite obtener datos de series de tiempo agregados espacialmente para polígonos de un mapa vectorial\n\n\n#### SUHI estival para *Córdoba* y alrededores\n\nInstalar la extensión *v.strds.stats*\n\n::: {.cell execution_count=56}\n``` {.python .cell-code}\n# Install v.strds.stats add-on\ngs.run_command(\"g.extension\", extension=\"v.strds.stats\")\n```\n:::\n\n\nListar mapas\n\n::: {.cell execution_count=57}\n``` {.python .cell-code}\n# List maps in seasonal time series\nprint(gs.run_command(\"t.rast.list\",\n                     input=\"LST_Day_mean_3month\"))\n```\n:::\n\n\nExtraer LST promedio de verano para el Gran Córdoba\n\n::: {.cell execution_count=58}\n``` {.python .cell-code}\n# Extract summer average LST for Cba urban area\ngs.run_command(\"v.strds.stats\",\n               input=\"area_edificada_cba\",\n               strds=\"LST_Day_mean_3month\",\n               where=\"fna == 'Gran Córdoba'\",\n               t_where=\"strftime('%m', start_time)='02'\",\n               output=\"cba_summer_lst\",\n               method=\"average\")\n```\n:::\n\n\nCrear buffer externo - 30 km\n\n::: {.cell execution_count=59}\n``` {.python .cell-code}\n# Create outside buffer - 30 km\ngs.run_command(\"v.buffer\",\n               input=\"cba_summer_lst\",\n               distance=30000,\n               output=\"cba_summer_lst_buf30\")\n```\n:::\n\n\nCrear buffer interno - 15 km\n\n::: {.cell execution_count=60}\n``` {.python .cell-code}\n# Create inside buffer - 15 km\ngs.run_command(\"v.buffer\",\n               input=\"cba_summer_lst\",\n               distance=15000,\n               output=\"cba_summer_lst_buf15\")\n```\n:::\n\n\nRemover el área del buffer 15 km del buffer de 30 km\n\n::: {.cell execution_count=61}\n``` {.python .cell-code}\n# Remove 15km buffer area from the 30km buffer area\ngs.run_command(\"v.overlay\",\n               ainput=\"cba_summer_lst_buf15\",\n               binput=\"cba_summer_lst_buf30\",\n               operator=\"xor\",\n               output=\"cba_surr\")\n```\n:::\n\n\n![Límites del Gran Córdoba y el área rural circundante](../assets/img/suhi_buffers.png){width=50%}\n\nExtraer estadísticas para los alrededores del Gran Córdoba\n\n::: {.cell execution_count=62}\n``` {.python .cell-code}\n# Extract zonal stats for Cba surroundings\ngs.run_command(\"v.strds.stats\",\n               input=\"cba_surr\",\n               strds=\"LST_Day_mean_3month\",\n               t_where=\"strftime('%m', start_time)='02'\",\n               method=\"average\",\n               output=\"cba_surr_summer_lst\")\n```\n:::\n\n\nChequear la LST estival promedio para el Gran Córdoba y alrededores\n\n::: {.cell execution_count=63}\n``` {.python .cell-code}\n# Take a look at mean summer LST in Cba and surroundings\ngs.vector_db_select(\"cba_summer_lst\")[\"values\"]\n```\n:::\n\n\n::: {.cell execution_count=64}\n``` {.python .cell-code}\ngs.vector_db_select(\"cba_surr_summer_lst\")[\"values\"]\n```\n:::\n\n\n::: {.cell execution_count=65}\n``` {.python .cell-code}\ntabla1 = pd.DataFrame.from_dict(gs.vector_db_select(map=\"cba_summer_lst\")['values'], \n                               orient='index', \n                               columns=gs.vector_db_select(map=\"cba_summer_lst\")['columns'])\ntabla1\n```\n:::\n\n\n::: {.cell execution_count=66}\n``` {.python .cell-code}\n# crear un data frame a partir del vector\ntabla2 = pd.DataFrame.from_dict(gs.vector_db_select(map=\"cba_surr_summer_lst\")['values'], \n                               orient='index', \n                               columns=gs.vector_db_select(map=\"cba_surr_summer_lst\")['columns'])\ntabla2\n```\n:::\n\n\n::: {.cell execution_count=67}\n``` {.python .cell-code}\n# table massaging\ndf1 = tabla1.loc[1:,['cat', 'LST_Day_mean_3month_2015_02_01_average', 'LST_Day_mean_3month_2016_02_01_average', 'LST_Day_mean_3month_2017_02_01_average', 'LST_Day_mean_3month_2018_02_01_average', 'LST_Day_mean_3month_2019_02_01_average']]\ndf2 = tabla2.loc[1:,['cat', 'LST_Day_mean_3month_2015_02_01_average', 'LST_Day_mean_3month_2016_02_01_average', 'LST_Day_mean_3month_2017_02_01_average', 'LST_Day_mean_3month_2018_02_01_average', 'LST_Day_mean_3month_2019_02_01_average']]\n```\n:::\n\n\n::: {.cell execution_count=68}\n``` {.python .cell-code}\ntables = [df1,df2]\nsuhi = pd.concat(tables)\nsuhi['cat'] = suhi.index\nsuhi\n```\n:::\n\n\n::: {.cell execution_count=69}\n``` {.python .cell-code}\nsuhi_long = suhi.melt(id_vars=\"cat\", var_name=\"date\", value_name=\"LST_Day_mean_3month_average\")\nsuhi_long\n```\n:::\n\n\n:::{.callout-warning title=\"Tarea\"}\nSe animan a hacer un gráfico de barras con librerías de Python para representar los \nvalores promedios por año para la zona urbana y alrededores?\n:::\n\n::: {.cell execution_count=70}\n``` {.python .cell-code}\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport numpy as np\n\nsuhi_long['setting'] = np.where(suhi_long['cat']== 1, 'Non Urban', 'Urban')\n```\n:::\n\n\n::: {.cell execution_count=71}\n``` {.python .cell-code}\nplt.figure(figsize=(10, 10))\ng = sns.barplot(data= suhi_long, x=\"date\", y=\"LST_Day_mean_3month_average\",  hue=\"setting\")\ng.set_xticklabels([\"2015\", \"2016\", \"2017\", \"2018\", \"2019\"])\nplt.xlabel(\"Year\")\nplt.ylabel(\"LST Day mean 3month average\")\nsns.move_legend(g, \"upper right\", title= \"Setting\")\nplt.show()\n```\n:::\n\n\n# Recursos (muy) útiles \n\n- [Temporal data processing wiki](https://grasswiki.osgeo.org/wiki/Temporal_data_processing)\n- [GRASS GIS and R for time series processing wiki](https://grasswiki.osgeo.org/wiki/Temporal_data_processing/GRASS_R_raster_time_series_processing)\n- [GRASS GIS temporal workshop at NCSU](http://ncsu-geoforall-lab.github.io/grass-temporal-workshop/)\n- [GRASS GIS course IRSAE 2018](http://training.gismentors.eu/grass-gis-irsae-winter-course-2018/index.html)\n- [GRASS GIS workshop held in Jena 2023](https://training.gismentors.eu/grass-gis-workshop-jena/)\n- [Using Satellite Data for Species Distribution Modeling with GRASS GIS and R](https://veroandreo.github.io/grass_ncsu_2023/studio_index.html). Workshop en \nNCSU. Abril, 2023.\n\n# Referencias\n\n::: {#refs .tiny}\n:::\n\n",
    "supporting": [
      "intro_temporal_files"
    ],
    "filters": [],
    "includes": {}
  }
}